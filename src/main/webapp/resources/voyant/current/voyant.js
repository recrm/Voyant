/* This file created by JSCacher. Last modified: Fri Jan 12 16:45:34 UTC 2024 */
function Bubblelines(config) {
	this.container = config.container;
	this.externalClickHandler = config.clickHandler;
	
	this.INTERVAL = 50; // milliseconds between each redraw
	this.DISMISS_DELAY = 2500; // milliseconds before tooltip auto hides
	this.UNIFORM_LINE_LENGTH = true; // should all document lines be the same length?
	this.SEPARATE_LINES_FOR_TERMS = false; // draw a separate line for each term?
	
	// these 2 get set in the code
	this.MAX_LABEL_WIDTH = 0;
	this.MAX_LINE_WIDTH = 0;
	
	this.DRAW_TITLES = true; // where to draw the document titles for each graph; gets set to false if the corpus has only 1 document
	this.DRAW_SHORT_TITLES = false; // whether to use the docIndex for the title or not; gets set to true if the window is small enough
	
	this.MIN_GRAPH_SEPARATION = 50; // vertical separation between graphs
	this.graphSeparation = 50;
	
	this.yIndex = 0; // for tracking yIndex during the drawing process
	
	this.mouseOver = false; // is the mouse over the canvas
	this.intervalId = null;
	this.clearToolTipId = null;
	this.overBubbles = [];
	this.lastClickedBubbles = {};
	this.dragInfo = null;
	this.canvas = null;
	this.ctx = null;
	this.maxDocLength = 2;
	this.maxFreq = {term: null, value: 0};
	this.maxRadius = 0;
	
	/**
	 * The cache of docs. Each has the following properties:
	 * @param {String} id
	 * @param {String} title
	 * @param {Integer} index
	 * @param {Integer} totalTokens
	 * @param {Object} terms Stores the terms for this doc
	 * @param {Object} freqCounts Used for tool tip display
	 * @param {Float} height The height of the graph for this doc
	 * @param {Float} titleWidth The width of the title
	 * @param {Float} lineLength The length of the graph line for this doc
	 */
	this.cache = new Ext.util.MixedCollection();
	
	this.currentTerms = {}; // tracks what terms we're currently showing
	this.termsFilter = []; // tracks the subset of terms
	this.bubbleSpacing = 50;

	this.initialized = false;
}

Bubblelines.prototype = {
	constructor: Bubblelines,
	
	initializeCanvas: function() {
		var container = this.container;
		var height = container.getHeight();
		var width = container.getWidth();
		this.DRAW_SHORT_TITLES = width < 500;
		var id = Ext.id('bubblelines');
		container.add({
			xtype: 'container',
			width: width,
			height: height,
			html: '<canvas id="'+id+'" width="'+width+'" height="'+height+'"></canvas>',
			border: false,
        	listeners: {
        		afterrender: {
        			fn: function(cnt) {
    					this.canvas = document.getElementById(id);
        				this.ctx = this.canvas.getContext('2d');
        				this.canvas.addEventListener('click', this.clickHandler.bind(this), false);
        				this.canvas.addEventListener('mousedown', this.mouseDownHandler.bind(this), false);
        				this.canvas.addEventListener('mouseup', this.mouseUpHandler.bind(this), false);
        				this.canvas.addEventListener('mousemove', this.moveHandler.bind(this), false);
        				this.canvas.addEventListener('mouseenter', this.mouseEnterHandler.bind(this), false);
        				this.canvas.addEventListener('mouseleave', this.mouseLeaveHandler.bind(this), false);
        				            				
//        				this.findLongestDocumentTitle();
//        				
//        				var padding = 75;
//        				if (this.DRAW_SHORT_TITLES) padding = 50;
//        				this.setMaxLineWidth(width - this.MAX_LABEL_WIDTH - padding);
        			},
        			single: true,
        			scope: this
        		}
        	}
		});
		container.updateLayout();
		this.initialized = true;
	},
	
	doBubblelinesLayout: function() {
		if (this.initialized) {
			var width = this.container.getWidth();
			
			// width related calculations
			this.DRAW_SHORT_TITLES = width < 500;
			this.setTitleWidthsAndMaxTitleWidth();
			
			var children = Ext.DomQuery.jsSelect('div:not(div[class*=term])', this.container.el.dom);
			for (var i = 0; i < children.length; i++) {
				var child = Ext.fly(children[i]);
				child.setWidth(width);
			}
			this.canvas.width = width;
			
			var padding = 75;
			if (this.DRAW_SHORT_TITLES) padding = 50;
			this.setMaxLineWidth(width - this.MAX_LABEL_WIDTH - padding);
			this.setLineLengths();
			
			this.recache();
			
			// height related calculations
			this.setCanvasHeight();
			
			this.drawGraph();
		}
	},
	
	addDocToCache: function(doc) {
		this.cacheBubbles(doc);
		this.calculateBubbleRadii(doc);
		doc.lineLength = 600;
		doc.freqCounts = {}; // used for tool tip display
		if (this.cache.containsKey(doc.id) === false) {
			this.cache.add(doc);
		} else {
			this.cache.replace(doc.id, doc);
		}
		this.cache.sort('index', 'ASC');
	},
	
	addTermsToDoc: function(termsObj, docId) {
		var term;
		// only one key
		for (var key in termsObj) {
			term = key;
		}
		this.currentTerms[term] = true;
		
		var doc = this.cache.get(docId);
		Ext.apply(doc.terms, termsObj);
		var maxFreqChanged = this.cacheBubbles(doc);
		if (maxFreqChanged) {
			this.recache();
		} else {
			this.calculateBubbleRadii(doc);
		}
	},
	
	cacheBubbles: function(doc) {
		var maxFreqChanged = false;
		for (var term in doc.terms) {
			var termInfo = doc.terms[term];
			var bins = termInfo.distributions.length;
			var spacing = doc.lineLength / bins;
			
			var cachedPositions = [];
			var tokenPos = 0;
			var maxDistribution = 0;
			var xIndex = 0;
			for (var i = 0; i < bins; i++) {
				var d = termInfo.distributions[i];
				if (d > maxDistribution) {
					maxDistribution = d;
				}
				
				cachedPositions.push({id: Ext.id(null, 'bub'), x: xIndex, freq: d, radius: 0, bin: i, tokenPositions: termInfo.positions.slice(tokenPos, tokenPos+=d)});
				xIndex += spacing;
			}
			
			doc.terms[term].maxDistribution = maxDistribution;
			doc.terms[term].pos = cachedPositions;
			
			if (maxDistribution > this.maxFreq.value) {
				maxFreqChanged = true;
				this.setMaxFreq({term: term, value: maxDistribution});
			}
		}
		return maxFreqChanged;
	},
	
	calculateBubbleRadii: function(doc, newTerm) {
		var maxFreqLog = Math.log(this.maxFreq.value);
		var minFreq = Math.log(2) / 2;
//		this.cache.each(function(doc) {
			for (var t in doc.terms) {
				var term = doc.terms[t];
				if (term) {
					if (newTerm == null || t == newTerm) {
						for (var i = 0; i < term.pos.length; i++) {
							var bubble = term.pos[i];
							if (bubble.freq > 0) {
								var freqLog = Math.max(Math.log(bubble.freq), minFreq);
								var radius = freqLog / maxFreqLog * this.maxRadius;
								bubble.radius = radius;
							} else {
								bubble.radius = 0;
							}
						}
					}
				}
			}
//		}, this);
	},
	
	
	recache: function() {
		function doCache(doc) {
			this.cacheBubbles(doc);
			this.calculateBubbleRadii(doc);
		}
		
		this.cache.each(doCache, this);
	},
	
	/**
	 * Get the total height of the all the graphs
	 */
	getTotalHeight: function() {
		var totalHeight = this.maxRadius;
		this.cache.each(function(doc, index, length) {
			totalHeight += doc.height;
		}, this);
		return totalHeight;
	},
	

	/**
	 * Set the height for the canvas and associated elements
	 */
	setCanvasHeight: function() {
		this.calculateGraphHeights();
		var height = this.getTotalHeight();
		var container = this.container.dom;
		if (container !== undefined) {
			var children = Ext.DomQuery.jsSelect('div', container);
			for (var i = 0; i < children.length; i++) {
				var child = Ext.fly(children[i]);
				child.setHeight(height);
			}
		}
		if (this.canvas) {
			this.canvas.height = height;
		}
	},
	
	/**
	 * Set max line width as well as maxRadius
	 */
	setMaxLineWidth: function(width) {
		this.maxRadius = width / 30;
		this.MAX_LINE_WIDTH = width - this.maxRadius / 2;
	},
	
	/**
	 * Calculate graph heights, based on maxRadius
	 */
	calculateGraphHeights: function() {
		var graphSeparation = this.maxRadius * 0.5;
		if (this.SEPARATE_LINES_FOR_TERMS) {
			var terms = this.termsFilter;
			this.cache.each(function(doc, index, length) {
				var height = this.maxRadius * terms.length;
				for (var i = 0; i < terms.length; i++) {
					if (!doc.terms[terms[i]]) {
						height -= this.maxRadius;
					}
				}
				if (height == 0) height = this.maxRadius;
				
				doc.height = height + graphSeparation;
			}, this);
		} else {
			var height = Math.max(this.maxRadius, this.MIN_GRAPH_SEPARATION);
			this.cache.each(function(doc, index, length) {
				doc.height = height + graphSeparation;
			}, this);
		}
	},
	
	findLongestDocument: function(doc) {
		var twt = doc.getTotalWordTokens();
		if (twt > this.maxDocLength) {
			this.maxDocLength = twt;
		}
	},
	
	getTitleWidth: function(doc) {
		var title = doc.title;
		if (this.DRAW_SHORT_TITLES) {
			var index = this.cache.indexOf(doc);
			title = (index+1)+')';
		}
		this.ctx.textBaseline = 'top';
		this.ctx.font = 'bold 12px Verdana';
		var width = this.ctx.measureText(title).width;
		return width;
	},
	
	setTitleWidthsAndMaxTitleWidth: function() {
		function doTitle(doc, index) {
			var width = this.getTitleWidth(doc);
			doc.titleWidth = width;
			if (width > this.MAX_LABEL_WIDTH) {
				this.MAX_LABEL_WIDTH = width;
			}
		}
		this.cache.each(doTitle, this);
	},
	
	setLineLengths: function() {
		function doLength(doc, index) {
			var lineLength;
			if (this.UNIFORM_LINE_LENGTH) {
				lineLength = this.MAX_LINE_WIDTH;
			} else {
				var percentage = Math.log(doc.getTotalWordTokens()) / Math.log(this.maxDocLength);
				lineLength = percentage * this.MAX_LINE_WIDTH;
			}
			doc.lineLength = lineLength;
		}
		
		this.cache.each(doLength, this);
	},
	
	drawGraph: function(includeLegend) {
		if (this.intervalId != null) clearInterval(this.intervalId);
		
		if (this.mouseOver) {
			this.intervalId = setInterval(this.doDraw.bind(this, [includeLegend]), this.INTERVAL);
		} else {
			setTimeout(this.doDraw.bind(this, [includeLegend]), 5);
		}
	},
	
	doDraw: function(includeLegend) {
		this.clearCanvas();
		this.yIndex = this.maxRadius;
		if (includeLegend === true) this.yIndex += 30;
		this.cache.each(this.drawDocument, this);
		if (includeLegend === true) this.drawLegend();
		else this.drawToolTip();
		this.doDrag();
	},
	
	drawDocument: function(doc, index, totalDocs) {
		if (!doc.hidden) {
			var lineLength = doc.lineLength;
			var titleIndent = this.MAX_LABEL_WIDTH - doc.titleWidth;
			
			var xIndex = 5;
			
			this.ctx.textBaseline = 'top';
			this.ctx.font = 'bold 12px Verdana';
			
			if (this.dragInfo != null && this.dragInfo.oldIndex == index) {
				this.ctx.fillStyle = 'rgba(128, 128, 128, 0.5)';
				xIndex += titleIndent;
				this.ctx.fillText(doc.title, xIndex, this.yIndex);
				if (this.SEPARATE_LINES_FOR_TERMS) {
					this.yIndex += doc.height;
				}
			} else {			
				// draw label
				if (this.DRAW_TITLES) {
					xIndex += titleIndent;
	//				var c = this.getColor(this.getApplication().getCorpus().getDocument(doc.id).getIndex());
	//				this.ctx.strokeStyle = 'rgba('+c[0]+', '+c[1]+', '+c[2]+', 1.0)';
	//				this.ctx.lineWidth = 2;
	//				this.ctx.beginPath();
	//				this.ctx.moveTo(xIndex, this.yIndex+12);
	//				this.ctx.lineTo(this.MAX_LABEL_WIDTH, this.yIndex+12);
	//				this.ctx.stroke();
					
					this.ctx.fillStyle = 'rgba(128, 128, 128, 1.0)';
					var title = doc.title;
					if (this.DRAW_SHORT_TITLES) title = (index+1)+')';
					this.ctx.fillText(title, xIndex, this.yIndex);
				}
				
	//			this.ctx.fillStyle = 'rgba(0, 0, 128, 1.0)';
	//			this.ctx.fillRect(0, this.yIndex-this.maxRadius*0.75, 250, 2);
				
				// shift down slightly to vertically align line and bubbles with label
				this.yIndex += 4;
				
				// draw line
				var that = this;
				function drawLine() {
					xIndex = that.MAX_LABEL_WIDTH + that.maxRadius;
					that.ctx.strokeStyle = 'rgba(128, 128, 128, 1.0)';
					that.ctx.fillStyle = 'rgba(128, 128, 128, 1.0)';
					that.ctx.lineWidth = 0.25;
					
					that.ctx.beginPath();
					that.ctx.moveTo(xIndex, that.yIndex-6);
					that.ctx.lineTo(xIndex, that.yIndex+6);
					that.ctx.stroke();
					
					that.ctx.beginPath();
					that.ctx.moveTo(xIndex, that.yIndex);
					that.ctx.lineTo(xIndex + lineLength, that.yIndex);
					that.ctx.stroke();
					
					that.ctx.beginPath();
					that.ctx.moveTo(xIndex + lineLength, that.yIndex-6);
					that.ctx.lineTo(xIndex + lineLength, that.yIndex+6);
					that.ctx.stroke();
				}
				
	//			var filter = this.getApiParamValue('typeFilter');
	//			var filter = [];
	//			for (var term in this.currentTerms) {
	//				filter.push(term);
	//			}
				
				if (!this.SEPARATE_LINES_FOR_TERMS) {
					drawLine();
				} else if (this.termsFilter == null || this.termsFilter.length === 0) {
					drawLine();
				}
				
				// draw bubbles
				var pi2 = Math.PI * 2;
				
				var freqTotal = 0;
				doc.freqCounts = {};
				var terms = doc.terms;
				var checkClickedBubbles = this.lastClickedBubbles[index] != null;
				var termsDrawn = 0;
				for (var t in terms) {
					if (this.termsFilter.indexOf(t) !== -1) {
						var info = terms[t];
						if (info) {
							termsDrawn++;
							if (this.SEPARATE_LINES_FOR_TERMS) {
								drawLine();
							}
							
							var freqForType = 0;
							
							var c = info.color.join(',');
							this.ctx.strokeStyle = 'rgba('+c+', 1)';
							this.ctx.fillStyle = 'rgba('+c+', 0.35)';
							this.ctx.lineWidth = 0.25;
							
							freqTotal += info.rawFreq;
							freqForType += info.rawFreq;
							
							var checkCurrentType = checkClickedBubbles && this.lastClickedBubbles[index][t];
							
							for (var i = 0; i < info.pos.length; i++) {
								var b = info.pos[i];
								if (b.radius > 0) {
									var doClickedBubble = false;
									if (checkCurrentType && this.lastClickedBubbles[index][t] == b.id) {
										this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.75)';
										this.ctx.fillStyle = 'rgba('+c+', 0.5)';
										this.ctx.lineWidth = 1;
										doClickedBubble = true;
									}
									
									this.ctx.beginPath();
									this.ctx.arc(b.x+xIndex, this.yIndex, b.radius, 0, pi2, true);
									this.ctx.closePath();
									this.ctx.fill();
									this.ctx.stroke();
									
									if (doClickedBubble) {
										this.ctx.strokeStyle = 'rgba('+c+', 1)';
										this.ctx.fillStyle = 'rgba('+c+', 0.35)';
										this.ctx.lineWidth = 0.25;
									}
								}
							}
							doc.freqCounts[t] = freqForType;
							
							if (this.SEPARATE_LINES_FOR_TERMS) {
								this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
								this.ctx.font = '10px Verdana';
								this.ctx.fillText(freqForType, xIndex + lineLength + 5, this.yIndex-4);
								
								this.yIndex += this.maxRadius;
							}
						}
					}
				}
				
				if (this.SEPARATE_LINES_FOR_TERMS && termsDrawn == 0) {
					drawLine();
					
					this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
					this.ctx.font = '10px Verdana';
					this.ctx.fillText(0, xIndex + lineLength + 5, this.yIndex-4);
					
					this.yIndex += this.maxRadius;
				}
				
				xIndex += lineLength;
				
				if (!this.SEPARATE_LINES_FOR_TERMS) {
					this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
					this.ctx.font = '10px Verdana';
					this.ctx.fillText(freqTotal, xIndex + 5, this.yIndex-4);
				}
			}
			
			if (!this.SEPARATE_LINES_FOR_TERMS) {
				this.yIndex += doc.height;
			} else {
				this.yIndex += this.maxRadius * 0.5;
			}
			
			// undo previous shift
			this.yIndex -= 4;
			
	//		this.ctx.fillStyle = 'rgba(128, 0, 0, 1.0)';
	//		this.ctx.fillRect(0, this.yIndex-this.maxRadius*0.75, 350, 2);
		}
	},
	
	drawLegend: function() { // obsolete code?
		var x = this.MAX_LABEL_WIDTH + this.maxRadius;
		var y = 5;
		this.ctx.textBaseline = 'top';
		this.ctx.font = '16px serif';
		if (this.typeStore) {
			this.typeStore.each(function(record) {
				var color = record.get('color').join(',');
				this.ctx.fillStyle = 'rgb('+color+')';
				var type = record.get('type');
				this.ctx.fillText(type, x, y);
				var width = this.ctx.measureText(type).width;
				x += width + 8;
			}, this);
		}
	},
	
	drawToolTip: function() {
		if (this.overBubbles.length > 0) {
			this.ctx.lineWidth = 0.5;
			this.ctx.fillStyle = 'rgba(224, 224, 224, 0.8)';
			this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
			
			var x = this.overBubbles[0].x;
			var y = this.overBubbles[0].y;
			var width = 110;
			if (x + width > this.canvas.width) {
				x -= width;
			}
			var height;
			var summary = this.overBubbles[0].label == null;
			if (summary) {
				var doc = this.cache.get(this.overBubbles[0].docIndex);
				var count = 1;
				for (var t in doc.freqCounts) {
					count++;
				}
				height = count * 16;// + 10;
				if (y + height > this.canvas.height) {
					y -= height;
				}
				this.ctx.fillRect(x, y, width, height);
				this.ctx.strokeRect(x, y, width, height);
				x += 10;
				y += 10;
				this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				this.ctx.font = '10px Verdana';
//				var total = 0;
				for (var t in doc.freqCounts) {
					var freq = doc.freqCounts[t];
//					total += freq;
					this.ctx.fillText(t+': '+freq, x, y, 90);
					y += 16;
				}
//				this.ctx.fillText(this.localize('total')+': '+total, x, y, 90);
				
			} else {
				height = this.overBubbles.length * 16 + 10;
				if (y + height > this.canvas.height) {
					y -= height;
				}
				this.ctx.fillRect(x, y, width, height);
				this.ctx.strokeRect(x, y, width, height);
				x += 10;
				y += 10;
				this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
				this.ctx.font = '10px Verdana';
				for (var i = 0; i < this.overBubbles.length; i++) {
					var b = this.overBubbles[i];
					this.ctx.fillText(b.label+': '+b.freq, x, y, 90);
					y += 16;
				}
			}
			
			if (this.clearToolTipId == null) {
				this.clearToolTipId = setTimeout(this.clearToolTip.bind(this), this.DISMISS_DELAY);
			}
		}
	},
	
	clearToolTip: function() {
		this.overBubbles = [];
		clearTimeout(this.clearToolTipId);
		this.clearToolTipId = null;
	},
	
	mouseEnterHandler: function(event) {
		this.mouseOver = true;
		this.drawGraph();
	},
	
	mouseLeaveHandler: function(event) {
		this.mouseOver = false;
		if (this.intervalId != null) clearInterval(this.intervalId);
		// draw once to remove any popup
		this.overBubbles = [];
		this.drawGraph();
	},
	
	moveHandler: function(event) {
		this.clearToolTip();
		
		this.overBubbles = [];
		var x = event.layerX - this.MAX_LABEL_WIDTH;
		var y = event.layerY;
		
		var docHeight = this.maxRadius*0.25; // where the first graph actually starts
		
		var docIndex = -1;
		this.cache.each(function(doc, index, length) {
			if (y < docHeight) {
				return false;
			} else {
				docHeight += doc.height;
				if (y < docHeight) {
					docIndex = index;
					return false;
				}
			}
		}, this);
		
		if (this.dragInfo != null) {
			this.dragInfo.x = event.layerX;
			this.dragInfo.y = y;

			if (docIndex >= this.cache.getCount()) {
				docIndex = this.cache.getCount()-1;
			} else if (docIndex < 0) {
				if (y + this.maxRadius > this.canvas.height) {
					docIndex = this.cache.getCount()-1;
				} else {
					docIndex = 0;
				}
			}
			
			this.dragInfo.newIndex = docIndex;
			document.body.style.cursor = 'move';
		} else {
			if (docIndex >= 0 && docIndex < this.cache.getCount()) {
				if (x >= 0) {
					var showPointer = false;
					x -= this.maxRadius; // re-adjust x to the start of the doc line 
					var hits = [];
					var doc = this.cache.get(docIndex);
					if (x >= doc.lineLength) {
						this.overBubbles = [{
							docIndex: docIndex,
							x: event.layerX+10,
							y: event.layerY+10
						}];
					} else {
						var spacing = doc.lineLength / this.bubbleSpacing;
						var xIndex = Math.round(x / spacing);
						var prevDocHeight = this.maxRadius;
						if (docIndex > 0) {
							prevDocHeight = docHeight - (this.cache.get(docIndex).height - this.maxRadius*0.75);
						}
						var yIndex = Math.round((y - prevDocHeight) / this.maxRadius);
						
						var count = 0;
						for (var t in doc.terms) {
							if (this.termsFilter.indexOf(t) !== -1) {
								var type = doc.terms[t];
								if (type) {
									if (this.SEPARATE_LINES_FOR_TERMS && count == yIndex || !this.SEPARATE_LINES_FOR_TERMS) {
										if (type.pos[xIndex] && type.pos[xIndex].radius > 0) {
											showPointer = true;
											this.overBubbles.push({
												label: t,
												type: type,
												docId: doc.id,
												docIndex: docIndex,
												xIndex: xIndex,
												yIndex: yIndex,
												freq: type.pos[xIndex].freq,
												id: type.pos[xIndex].id,
												tokenPositions: type.pos[xIndex].tokenPositions,
												x: event.layerX+10,
												y: event.layerY+10
											});
										}
									}
								} else if (this.SEPARATE_LINES_FOR_TERMS) count--;
								count++;
							}
						}
					}
					if (showPointer) {
						document.body.style.cursor = 'pointer';
					} else {
						document.body.style.cursor = 'auto';
					}
				} else {
					document.body.style.cursor = 'move';
				}
			} else {
				document.body.style.cursor = 'auto';
			}
		}
	},
	
	mouseDownHandler: function(event) {
		var x = event.layerX;
		var y = event.layerY;
		if (x < this.MAX_LABEL_WIDTH) {
			
			var docHeight = this.maxRadius*0.25;
			var docIndex = -1;
			this.cache.each(function(doc, index, length) {
				if (y < docHeight) {
					return false;
				} else {
					docHeight += doc.height;
					if (y < docHeight) {
						docIndex = index;
						return false;
					}
				}
			}, this);

			if (docIndex >= 0 && docIndex < this.cache.getCount()) {
				var xOffset = x - 5;
				var yOffset = 5;
				this.dragInfo = {
					oldIndex: docIndex,
					newIndex: docIndex,
					xOffset: xOffset,
					yOffset: yOffset,
					x: x,
					y: y
				};
			}
		}
	},
	
	mouseUpHandler: function(event) {
		this.dragInfo = null;
	},
	
	doDrag: function() {
		if (this.dragInfo != null) {
			var ordering = {};
			for (var i = 0; i < this.cache.getCount(); i++) {
				if (i < this.dragInfo.oldIndex && i < this.dragInfo.newIndex) {
					ordering[i] = i;
				} else if (i < this.dragInfo.oldIndex && i >= this.dragInfo.newIndex) {
					ordering[i] = i + 1;
				} else if (i == this.dragInfo.oldIndex) {
					ordering[i] = this.dragInfo.newIndex;
				} else if (i > this.dragInfo.oldIndex && i > this.dragInfo.newIndex) {
					ordering[i] = i;
				} else if (i > this.dragInfo.oldIndex && i <= this.dragInfo.newIndex) {
					ordering[i] = i - 1;
				}
			}
			this.dragInfo.oldIndex = this.dragInfo.newIndex;
			
			this.cache.reorder(ordering);
			
			var doc = this.cache.get(this.dragInfo.oldIndex);
			this.ctx.fillStyle = 'rgba(128, 128, 128, 1)';
			this.ctx.textBaseline = 'top';
			this.ctx.font = 'bold 12px Verdana';

			this.ctx.fillText(doc.title, this.dragInfo.x - this.dragInfo.xOffset, this.dragInfo.y - this.dragInfo.yOffset);
		}
	},
	
	clickHandler: function(event) {
		this.lastClickedBubbles = {};
		if (this.overBubbles.length > 0 && this.overBubbles[0].label) {
			var hits = [];
			var tokenPositions = [];
			var termData = [];
			for (var i = 0; i < this.overBubbles.length; i++) {
				var b = this.overBubbles[i];
				
				termData.push({term: b.label, docIndex: b.docIndex, docId: b.docId, tokenPositions: b.tokenPositions});
				
				if (this.lastClickedBubbles[b.docIndex] == null) {
					this.lastClickedBubbles[b.docIndex] = {};
				}
				this.lastClickedBubbles[b.docIndex][b.label] = b.id;
				hits.push(b.docId+':'+b.label);
				tokenPositions.push(b.tokenPositions);
			}
			tokenPositions = Ext.flatten(tokenPositions);
			tokenPositions.sort();
			
			if (this.externalClickHandler !== undefined) {
				this.externalClickHandler(termData);
			}
		}
		this.overBubbles = [];
	},
	
	setMaxFreq: function(maxObj) {
		if (maxObj == null) {
			maxObj = this.findMaxFreq();
		}
		this.maxFreq = maxObj;
	},
	
	findMaxFreq: function() {
		var max = {term: '', value: 0};
		this.cache.each(function(doc) {
			for (var t in doc.terms) {
				var maxDistribution = doc.terms[t].maxDistribution;
				if (maxDistribution > max.value) {
					max = {term: t, value: maxDistribution};
				}
			}
		}, this);
		return max;
	},
	
	getNewColor: function() {
		var color = null;
		for (var i = 0; i < this.colors.length; i++) {
			color = this.colors[i];
			var match = this.typeStore.findExact('color', color);
			if (match == -1) break;
			else color = null;
		}
		if (color == null) color = [128, 128, 128];
		return color;
	},
	
	removeAllTerms: function() {
		this.cache.each(function(doc) {
			doc.terms = {};
		}, this);
		this.currentTerms = {};
		this.termsFilter = [];
	},
	
	removeTerm: function(term) {
//		var types = this.store.query('type', type);
//		types.each(function(type) {
//			this.store.remove(type);
//		}, this);
		
		delete this.currentTerms[term];
		
//		var types = this.getApiParamValue('type');
//		types = types.remove(type);
//		this.setApiParams({type: types});
		
		var getNewMax = false;
		this.cache.each(function(doc) {
			for (var t in doc.terms) {
				if (t == term) {
					if (this.maxFreq.term == term) {
						this.maxFreq = {term: null, value: 0};
						getNewMax = true;
					}
					delete doc.terms[t];
				}
			}
		}, this);
		
		for (var i in this.lastClickedBubbles) {
			var lcTypes = this.lastClickedBubbles[i];
			for (var lcType in lcTypes) {
				if (lcType == term) {
					delete this.lastClickedBubbles[i][lcType];
				}
			}
			
		}
		
		if (getNewMax) {
			this.setMaxFreq();
			this.calculateBubbleRadii();
			this.drawGraph();
		}
	},
	
	clearCanvas: function() {
		this.canvas.width = this.canvas.width;
	}
};
function Knots(config) {
	this.container = config.container;
	this.externalClickHandler = config.clickHandler;
	
	this.MAX_LINE_LENGTH = 0;
	this.LINE_SIZE = 2.5;
	
	this.progressiveDraw = true;
	this.progDrawDone = false;
	this.drawStep = 0;
	
	this.mouseOver = false;
	this.refreshInterval = 100;
	this.forceRedraw = false;
	this.lastDrawTime = new Date().getTime();
	this.intervalId = null;
	this.startAngle = 315;
	this.angleIncrement = 15;
	
	this.canvas = null;
	this.ctx = null;
	this.currentDoc = {
		terms: {},
		lineLength: undefined
	};
	this.maxDocLength = 0;
	
	this.offset = {x: 0, y: 0};

	this.termsFilter = [];
	
	this.initialized = false;
	
	this.audio = config.audio;
	this.audioCtx = null;
}


Knots.prototype = {
	constructor: Knots,
	
	initializeCanvas: function() {
		var container = this.container;
		var height = container.getHeight()-5;
		var width = container.getWidth();
		this.MAX_LINE_LENGTH = Math.sqrt((width * width) + (height * height));
		
		var id = Ext.id('knots');
		container.add({
			xtype: 'container',
			width: width,
			height: height,
			html: '<canvas id="'+id+'" width="'+width+'" height="'+height+'"></canvas>',
			border: false,
        	listeners: {
        		afterrender: {
        			fn: function(cnt) {
    					this.canvas = document.getElementById(id);
        				this.ctx = this.canvas.getContext('2d');
        				this.canvas.addEventListener('click', this.clickHandler.bind(this), false);
        				this.canvas.addEventListener('mousedown', this.mouseDownHandler.bind(this), false);
        				this.canvas.addEventListener('mouseup', this.mouseUpHandler.bind(this), false);
        				this.canvas.addEventListener('mousemove', this.moveHandler.bind(this), false);
        			},
        			single: true,
        			scope: this
        		}
        	}
		});
		container.updateLayout();
		this.initialized = true;
	},
	
	doLayout: function() {
		if (this.initialized) {
			var width = this.container.getWidth();
			var height = this.container.getHeight()-5;
			this.canvas.width = width;
			this.canvas.height = height;
			this.recache();
			this.buildGraph();
		}
	},
	
	buildGraph: function(drawStep) {
		if (this.intervalId != null) {
			this.progDrawDone = false;
			clearInterval(this.intervalId);
		}
		this.forceRedraw = true;

		this.drawStep = drawStep || 0;
		
		for (var t in this.currentDoc.terms) {
			var term = this.currentDoc.terms[t];
			term.done = false;
		}
		
		if (!this.progressiveDraw) {
			this.doDraw(false);
		} else {
			this.intervalId = setInterval(this.doDraw.createDelegate(this, [false]), 50);
		}
	},
	
	drawGraph: function(includeLegend) {
		if (this.intervalId != null) {
			this.progDrawDone = false;
			clearInterval(this.intervalId);
		}
		this.forceRedraw = true;
		
		if (!this.progressiveDraw) {
			this.doDraw(false, includeLegend);
		} else {
			this.intervalId = setInterval(this.doDraw.createDelegate(this, [includeLegend]), 50);
		}
	},
	
	doDraw: function(includeLegend) {
		var time = new Date().getTime();
		if (this.forceRedraw || time - this.lastDrawTime >= this.refreshInterval) {
			this.forceRedraw = false;
			
			this.clearCanvas();
			
			this.ctx.save();
			this.ctx.translate(this.offset.x, this.offset.y);
			
			this.drawDocument(this.currentDoc);
			
			// animate the origin
	//		this.originOpacity -= 0.01;
	//		if (this.originOpacity < 0) {
	//			this.originOpacity = 1.0;
	//		}
			this.originOpacity = 0.5;
			this.originColor = '128,128,128';
			this.ctx.lineWidth = Math.abs(this.originOpacity - 1) * 15;
			this.ctx.fillStyle = 'rgba('+this.originColor+',1.0)';
			this.ctx.strokeStyle = 'rgba('+this.originColor+','+this.originOpacity+')';
			this.ctx.beginPath();
			this.ctx.arc(0, 0, this.LINE_SIZE*2, 0, Math.PI*2, true);
			this.ctx.closePath();
			this.ctx.fill();
			
			if (!includeLegend) this.ctx.stroke();
			this.ctx.restore();
			this.ctx.lineWidth = 1;
			
			if (includeLegend === true) {
				this.drawLegend();
			}
			
			this.lastDrawTime = new Date().getTime();
			
			// test to see if each doc term is done
			if (this.progressiveDraw) {
				var done = true;
				for (var t in this.currentDoc.terms) {
					done = done && this.currentDoc.terms[t].done;
				}
				this.progDrawDone = done;
				if (done) {
					clearInterval(this.intervalId);
					this.intervalId = null;
					this.muteTerms();
				} else {
					this.drawStep++;
				}
			}
		}
	},
	
	setAudio: function(audio) {
		this.audio = audio;
		if (!audio) {this.muteTerms();}
	},
	
	muteTerms: function() {
		for (t in this.currentDoc.terms) {
			if (this.currentDoc.terms[t].audio) {
				this.currentDoc.terms[t].audio.gainNode.gain.value=0;
			}
		}
	},
	
	drawDocument: function(doc) {
		var terms = doc.terms;
		
		for (var t in terms) {
			if (this.termsFilter.indexOf(t) != -1) {
				var info = terms[t];
				if (info && info.pos) {
					var prevXY = [[0,0],[0,0]];
					if (this.progressiveDraw) {
						var length = this.drawStep + 1;
						if (info.pos.length <= this.drawStep) {
							info.done = true;
							length = info.pos.length;
							if (info.audio) {info.audio.gainNode.gain.value=0};
						} else {
							if (this.audio && info.audio) {
								info.audio.gainNode.gain.value=.1;
								setTimeout(function() {
									info.audio.gainNode.gain.value=0;
								}, this.refreshInterval*.75)
							}
							info.done = false;
						}
						for (var i = 0; i < length; i++) {
							var xy = info.pos[i];
							this.drawPolygon(xy, prevXY, info.color);
							prevXY = [[xy.polygon[0][3], xy.polygon[1][3]], [xy.polygon[0][2], xy.polygon[1][2]]];
						}
					} else {
						for (var i = 0; i < info.pos.length; i++) {
							var xy = info.pos[i];
							this.drawPolygon(xy, prevXY, info.color);
							prevXY = [[xy.polygon[0][3], xy.polygon[1][3]], [xy.polygon[0][2], xy.polygon[1][2]]];
						}
					}
				}
			}
		}
	},
	
	drawPolygon: function(xy, prevXY, color) {
		var polyX = xy.polygon[0];
		var polyY = xy.polygon[1];
		
		// connect to previous polygon to make smoother turns
		this.ctx.beginPath();
		this.ctx.moveTo(prevXY[0][0], prevXY[0][1]);
		this.ctx.lineTo(polyX[0], polyY[0]);
		this.ctx.lineTo(polyX[1], polyY[1]);
		this.ctx.lineTo(prevXY[1][0], prevXY[1][1]);
		this.ctx.closePath();
		
		this.ctx.fillStyle = 'rgba('+color+', 0.6)';
		this.ctx.fill();

		// draw the current polygon
		this.ctx.beginPath();
		this.ctx.moveTo(polyX[0], polyY[0]);
		this.ctx.lineTo(polyX[1], polyY[1]);
		this.ctx.lineTo(polyX[2], polyY[2]);
		this.ctx.lineTo(polyX[3], polyY[3]);
		this.ctx.closePath();

		if (xy.over) this.ctx.fillStyle = 'rgba('+color+', 1.0)';
		this.ctx.fill();
	},
	
	drawLegend: function() {
		var x = 5;
		var y = 5;
		this.ctx.textBaseline = 'top';
		this.ctx.font = '16px serif';
		this.termStore.each(function(record) {
			var color = record.get('color');
			this.ctx.fillStyle = 'rgb('+color+')';
			var term = record.get('term');
			this.ctx.fillText(term, x, y);
			var width = this.ctx.measureText(term).width;
			x += width + 8;
		}, this);
	},
	
	setCurrentDoc: function(doc) {
		this.currentDoc = doc;
		this.cacheCurrentDocument();
	},
	
	addTerms: function(termsObj) {
		Ext.apply(this.currentDoc.terms, termsObj);
		this.recache();
	},
	
	removeTerm: function(term) {
		if (this.currentDoc.terms[term].audio) {this.currentDoc.terms[term].audio.oscillator.stop();}
		delete this.currentDoc.terms[term];
		this.recache();
	},
	
	removeAllTerms: function() {
		for (term in this.currentDoc.terms) {
			if (this.currentDoc.terms[term].audio) {
				this.currentDoc.terms[term].audio.oscillator.stop();
			}
		}
		this.currentDoc.terms = {};
		this.recache();
	},
	
	recache: function() {
		this.MAX_LINE_LENGTH = Math.sqrt((this.canvas.width * this.canvas.width) + (this.canvas.height * this.canvas.height));
		this.cacheCurrentDocument();
		this.determineGraphSizeAndPosition();
	},
	
	cacheCurrentDocument: function() {
		var lineLength = this.MAX_LINE_LENGTH;
		
		this.currentDoc.lineLength = lineLength;
		
		if (this.audio && this.audioCtx == null) {
			try {
				this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
			} catch(e) {
			}
		}
		
		for (var term in this.currentDoc.terms) {
			if (this.audio && this.audioCtx && !this.currentDoc.terms[term].audio) {
				var oscillator = this.audioCtx.createOscillator();
				var gainNode = this.audioCtx.createGain();
				oscillator.connect(gainNode);
				gainNode.connect(this.audioCtx.destination);
				oscillator.frequency.value = (Math.random()*500)+150; // value in hertz
				oscillator.start();
				gainNode.gain.value = 0;
				this.currentDoc.terms[term].audio = {oscillator: oscillator, gainNode: gainNode}
			} 
			this.cacheTurns(this.currentDoc.terms[term], lineLength);
		}
	},
	
	cacheTurns: function(info, lineLength) {
		var rawFreq = info.rawFreq;
		if (rawFreq > 0) {
			var doc = this.currentDoc;
			
			var term = info.term;
			var color = info.color;

			var cachedPositions = [];
			
			var tokenIds = info.positions;
			var lastTokenId = tokenIds[tokenIds.length-1];
			
			var angle = this.startAngle;
			var angleIncrement = this.angleIncrement;
			var prevX = 0;
			var prevY = 0;
			var x = 0;
			var y = 0;
			var prevLength = 0;
			
			for (var i = 0; i < tokenIds.length; i++) {
				var o = tokenIds[i];
				
				var length = o / lastTokenId * lineLength;
				var segment = length - prevLength;
				
				prevX = x;
				prevY = y;
				
				var newPoint = this.findEndPoint([x, y], segment, angle);
				x = newPoint[0];
				y = newPoint[1];
				
				var polygon = this.getPolygonFromLine([prevX, prevY], [x, y], angle, this.LINE_SIZE);
				
				cachedPositions.push({tokenId: o, polygon: polygon, over: false});
				
				prevLength = length;
				angle += angleIncrement;
			}
			
//			doc.terms[term] = {pos: cachedPositions, rawFreq: rawFreq, color: color, done: false};
			doc.terms[term].pos = cachedPositions;
			doc.terms[term].done = false;
		}
	},
	
	findEndPoint: function(point, length, angle) {
		var radians = this.degreesToRadians(angle);
		var x2 = point[0] + (length * Math.cos(radians));
		var y2 = point[1] + (length * Math.sin(radians));
		return [x2, y2];
	},
	
	determineGraphSizeAndPosition: function() {		
		var bb = this.findBoundingBoxForGraph();

		// find the size ratio between the graph and the canvas
		var width = bb.maxX - bb.minX;
		var height = bb.maxY - bb.minY;
		var widthRatio = this.canvas.width / width;
		var heightRatio = this.canvas.height / height;
		var ratio = Math.min(widthRatio, heightRatio);
		ratio -= 0.05; // create some space around the borders
		
		width *= ratio;
		height *= ratio;
		
		this.offset.x = Math.abs(bb.minX * ratio - (this.canvas.width / 2 - width / 2));
		this.offset.y = Math.abs(bb.minY * ratio - (this.canvas.height / 2 - height / 2));
		
		this.MAX_LINE_LENGTH = Math.sqrt((this.canvas.width * this.canvas.width) + (this.canvas.height * this.canvas.height)) * ratio;
		
		this.cacheCurrentDocument();
	},
	
	findBoundingBoxForGraph: function() {
		var minX = null;
		var maxX = null;
		var minY = null;
		var maxY = null;
		for (var t in this.currentDoc.terms) {
			var pos = this.currentDoc.terms[t].pos;
			for (var i = 0; i < pos.length; i++) {
				var polygon = pos[i].polygon;
				var bb = this.getBoundingBox(polygon[0], polygon[1]);
				if (minX == null || bb[0] < minX) minX = bb[0];
				if (maxX == null || bb[2] > maxX) maxX = bb[2];
				if (minY == null || bb[1] < minY) minY = bb[1];
				if (maxY == null || bb[3] > maxY) maxY = bb[3];
			}
		}
		
		return {minX: minX, minY: minY, maxX: maxX, maxY: maxY};
	},
	
	getBoundingBox: function(polyX, polyY) {
		var minX = Math.min(polyX[0], polyX[2]);
		var maxX = Math.max(polyX[0], polyX[2])
		var minY = Math.min(polyY[0], polyY[2]);
		var maxY = Math.max(polyY[0], polyY[2]);
		return [minX, minY, maxX, maxY];
	},
	
	degreesToRadians: function(d) {
		return d * (Math.PI / 180);
	},
	
	clickHandler: function(event) {
		var x = event.layerX - this.offset.x;
		var y = event.layerY - this.offset.y;
		var hit = null;
		var tokenId = 0;
		for (var t in this.currentDoc.terms) {
			if (this.termsFilter.indexOf(t) != -1) {
				var pos = this.currentDoc.terms[t].pos;
				for (var i = 0; i < pos.length; i++) {
					var polygon = pos[i].polygon;
					var test = this.isPointInPolygon(polygon[0], polygon[1], x, y);
					if (test) {
						hit = t;
						tokenId = pos[i].tokenId;
						break;
					}
				}
			}
		}

		if (hit) {
			if (this.externalClickHandler !== undefined) {
				this.externalClickHandler({term: hit, tokenId: tokenId});
			}
		}
	},
	
	moveHandler: function(event) {
		var x = event.layerX - this.offset.x;
		var y = event.layerY - this.offset.y;
		if (this.dragInfo != null) {
			document.body.style.cursor = 'move';
			this.dragInfo.lastX = this.dragInfo.x;
			this.dragInfo.lastY = this.dragInfo.y;
			this.dragInfo.x = event.layerX;
			this.dragInfo.y = event.layerY;
			var xDiff = this.dragInfo.x - this.dragInfo.lastX;
			var yDiff = this.dragInfo.y - this.dragInfo.lastY;
			this.offset.x += xDiff;
			this.offset.y += yDiff;
		} else {
			this.mouseOver = false;
			for (var t in this.currentDoc.terms) {
				if (this.termsFilter.indexOf(t) != -1) {
					var pos = this.currentDoc.terms[t].pos;
					for (var i = 0; i < pos.length; i++) {
						if (!this.mouseOver) {
							var polygon = pos[i].polygon;
							var test = this.isPointInPolygon(polygon[0], polygon[1], x, y);
							if (test) {
								this.currentDoc.terms[t].pos[i].over = true;
								this.mouseOver = true;
							} else {
								this.currentDoc.terms[t].pos[i].over = false;
							}
						} else {
							this.currentDoc.terms[t].pos[i].over = false;
						}
					}
				}
			}
			if (this.mouseOver) {
				document.body.style.cursor = 'pointer';
				if (!this.progressiveDraw || (this.progressiveDraw && this.progDrawDone)) {
					clearInterval(this.intervalId);
					this.intervalId = setInterval(this.doDraw.createDelegate(this, [false]), 50);
				}
			} else {
				document.body.style.cursor = 'auto';
				if (!this.progressiveDraw || (this.progressiveDraw && this.progDrawDone)) {
					clearInterval(this.intervalId);
					this.doDraw(false);
				}
			}
		}
	},
	
	mouseDownHandler: function(event) {
		var x = event.layerX;
		var y = event.layerY;
		this.dragInfo = {
			lastX: x,
			lastY: y,
			x: x,
			y: y
		};
	},
	
	mouseUpHandler: function(event) {
		this.dragInfo = null;
	},
	
	getPolygonFromLine: function(point1, point2, angle, size) {
		var perpDown = angle + 90;
		var perpUp = angle - 90;
		
		var p1 = this.findEndPoint(point1, size, perpDown);
		var p2 = this.findEndPoint(point1, size, perpUp);
		var p3 = this.findEndPoint(point2, size, perpUp);
		var p4 = this.findEndPoint(point2, size, perpDown);
		
		var polyX = [p1[0], p2[0], p3[0], p4[0]];
		var polyY = [p1[1], p2[1], p3[1], p4[1]];
		return [polyX, polyY];
	},
	
	// from http://alienryderflex.com/polygon/
	isPointInPolygon: function(polyX, polyY, x, y) {
		var i = 0;
		var j = 3; // number of polygon sides minus 1
		var oddNodes = false;
		for (i = 0; i < 4; i++) {
			if ((polyY[i] < y && polyY[j] >= y) ||
				(polyY[j] < y && polyY[i] >= y)) {
				if (polyX[i] + (y - polyY[i]) / (polyY[j] - polyY[i]) * (polyX[j] - polyX[i]) < x) {
					oddNodes = !oddNodes;
				}
			}
			j = i;
		}
		return oddNodes;
	},
	
	clearCanvas: function() {
		this.canvas.width = this.canvas.width;
	}
};
/*
 * Author: Andrew MacDonald
 * Licensed for use under the GNU General Public License
 * http://creativecommons.org/licenses/GPL/2.0/
 */

function Cirrus(config) {
    var that = this;
    this.config = config;
    var canvasId = Ext.id(null, 'cirrusCanvas');
    if (this.config.containerId == null) {
        alert('You must provide a valid container ID!');
        return;
    }
    var containerId = '#'+this.config.containerId;
    var wordController = null;
    var resizeTimer = null;
    
    this.clear = function() {
        this.canvas.width = this.canvas.width;
    };
    
    this.addWords = function(words) {
        wordController.addWords(words);
    };
    
    this.arrangeWords = function() {
        wordController.arrangeWords();
    };

    this.clearAll = function() {
        wordController.setWords([]);
        wordController.grid = [];
        this.clear();
    };

    this.resizeWords = function() {
        that.setCanvasDimensions();
        wordController.resetWordCoordinates();
        wordController.calculateSizeAdjustment();
        wordController.resizeWords();
        wordController.arrangeWords();
        resizeTimer = null;
    };

    this.setCanvasDimensions = function() {
        var container = $(containerId)[0];
        var width = Math.max(container.offsetWidth, container.clientWidth);
        var height = Math.max(container.offsetHeight, container.clientHeight);
        this.canvas.width = width;
        this.canvas.height = height;
    };

    function hex2RGB(hex) {
        hex = hex.charAt(0) == '#' ? hex.substring(1,7) : hex;
        var rgb = [];
        rgb.push(parseInt(hex.substring(0, 2), 16));
        rgb.push(parseInt(hex.substring(2, 4), 16));
        rgb.push(parseInt(hex.substring(4, 6), 16));
        return rgb;
    }
    
    function init() {
        
        if ($('#'+that.config.containerId).length == 0) {
            alert('You must provide a valid container ID!');
            return;
        }
        
        // create the canvas
        that.canvas = document.createElement('canvas');
        that.canvas.setAttribute('id', canvasId);
        that.canvas.setAttribute('tabIndex', 1);
        that.setCanvasDimensions();
        $(containerId).append(that.canvas);
        canvasId = '#'+canvasId;
        
        that.context = that.canvas.getContext('2d');
        var isLocal = false; // should we call the server for words or use local ones?
        that.wordData = new Array(); // the word data to input into the app
        that.useFadeEffect = true; // should we use a fade effect for displaying words?
        that.colors = [[116,116,181], [139,163,83], [189,157,60], [171,75,75], [174,61,155]];
        wordController = new WordController(that);
        
        for (var key in that.config) {
            if (key == 'words') that.wordData = that.config[key];
            if (key == 'layout') {
                if (that.config[key] == 'circle') wordController.layout = wordController.CIRCLE;
                else if (that.config[key] == 'square') wordController.layout = wordController.SQUARE;
            }
            if (key == 'colors') {
                // expects an array of hex colors
                if ($.isArray(that.config[key]) && that.config[key].length > 0) {
                    that.colors = [];
                    for (var c in that.config[key]) {
                        that.colors.push(hex2RGB(that.config[key][c]));
                    }
                }
            }
            if (key == 'background') {
                $(canvasId).css("background-color", that.config[key]);
            }
            if (key == 'fade') {
                if (that.config[key] == 'true') that.useFadeEffect = true;
                else if (that.config[key] == 'false') that.useFadeEffect = false;
            }
            if (key == 'smoothness') {
                wordController.wordsToArrange = Math.max(1, Math.min(20, parseInt(that.config[key]))); // set to value between 1-20
            }
        }
        
        if (isLocal && testData) {
            var cnt = 0;
            for (var key in testData) {
                that.wordData.push({word: key, size: testData[key] / 13, label: key});
                cnt++;
                if (cnt == 100) break;
            }
        }
        
        if (that.wordData.length > 0) {
            that.clear();
            wordController.addWords(that.wordData);
            wordController.arrangeWords();
        }
        
        $(window).resize(function() {
            if (resizeTimer != null) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(that.resizeWords, 1000);
        });

        $(canvasId).keypress(function(event) {
            if (event.which == 114) wordController.arrangeWords(); // r was pressed
        });
        
        $(canvasId).click(function(event) {
            var matchingWord = wordController.handleWordClick(event);
            if (matchingWord !== undefined) {
	            if (that.config.clickHandler) {
	            	that.config.clickHandler({term: matchingWord.text, value: matchingWord.value});
	            }
            }
        });
        
        $(canvasId).mouseover(function(event) {
        	wordController.startUpdates();
        });
        $(canvasId).mouseout(function(event) {
        	wordController.stopUpdates();
        });
        
        $(canvasId).mousemove(function(event) {
            wordController.handleMouseMove(event);
        });
    }
    
    $(document).ready(init);
}

/**
 * The word object.  Stores various properties related to diplaying the word.
 * @author Andrew
 */
function Word(_text, _origSize, _color, _rolloverText, _value) {
    this.height = 0;					// the height of the label
    this.width = 0;						// the width of the label
    this.rotation = 0; 					// rotation of the label, in radians
    this.relativeSize = 0;				// the size relative to the largest and smallest word sizes
    this.mask = null;					// a 2 dimensional array containing the local xy co-ordinates of opaque pixels
    this.size = 0;						// the largest of either the height or width, used in the circle layout
    
    /* Init */
    this.text = _text;					// the actual word
    this.color = _color;				// the color of the label
    this.origSize = _origSize;			// the original size (used when re-calculating relative sizes of words)
    this.rolloverText = _rolloverText;	// the text to show on rollover
    this.value = _value || 0;			// a value associated with the word (can be anything)
    this.x = 0;							// the x co-ordinate
    this.y = 0;							// the y co-ordinate
    this.tx = 0;						// the translation value for x
    this.ty = 0;						// the translation value for y
    this.fontFamily = 'Arial';			// the font family
    this.fontSize = 12;					// the font family
    this.alpha = 1;						// alpha of the label
    this.live = false;					// true if the word should be displayed
    this.isOver = false;				// true if the mouse if over the word
    
    this.draw = function(ctx) {
        ctx.save();
        ctx.fillStyle = 'rgba('+this.color[0]+','+this.color[1]+','+this.color[2]+','+this.alpha+')';
        ctx.textBaseline = 'alphabetic';
        ctx.font = this.fontSize + 'px '+ this.fontFamily;
        ctx.translate(this.x + this.tx, this.y + this.ty);
        ctx.rotate(this.rotation);
        ctx.fillText(this.text, 0, 0);
        ctx.restore();
    };
}

function WordController(parentApp) {
    var that = this;
    
    var app = parentApp;
    
    var myFont = 'Impact';
    
    this.CIRCLE = 0; // circle layout
    
    this.ratio = 1; // the width to height ratio
    
    var _layout = this.CIRCLE; // what layout to use
    this.getLayout = function() {
        return _layout;
    };
    this.setLayout = function(value) {
        _layout = value;
    };
    
    this.HORIZONTAL = 0;
    this.MIXED = 1; // horizontal and vertical
    
    var _wordOrientation = this.MIXED;
    this.getWordOrientation = function() {
        return _wordOrientation;
    };
    this.setWordOrientation = function(value) {
    	_wordOrientation = value;
    };
    
    this.UPDATE_RATE = 25; // update frequency in milliseconds
    this.COARSENESS = 5; // how many pixels do we skip when creating the mask?
//    if ($.browser.webkit) this.COARSENESS = 3; 
    this.grid = new Array(); // a multidimensional array ([x][y]), holding co-ords for words
    var timer_i = 0;
    var timer; // timer used to incrementally call the arrange method
    this.doingArrange = false;
    this.wordsToArrange = 5; // how many words to arrange for each call to the arrange method
    var overWord = null; // what word is the user mousing over?
    var overX = 0; // position of the mouse when over a word
    var overY = 0;
    
    var _words = new Array(); // the list of word objects
    this.getWords = function() {
        return _words;
    }
    this.setWords = function(value) {
        _words = value;
    }
    
    this.sizeAdjustment = 100; // amount to multiply a word's relative size by
    
    this.minFontSize = 12;
    
    // for tracking sizes in word data
    this.largestWordSize = 0;
    this.smallestWordSize = 10000;
    
    var _uniqueWords = new Object(); // stores words as properties, making sure we don't have duplicates
    
    /**
     * Creates a word object and adds it to the list.
     * If the size value is outside the current max/min value, returns true (meaning we have to resize all the words).
     * @param	word
     * @param	size
     * @param	color
     * @param	label
     * @param	value
     * @return
     */
    function addWord(word, size, color, label, value) {
        var sizeChanged = false;
        if (_uniqueWords[word] == null) {
            _uniqueWords[word] = true;
            
            if (size > that.largestWordSize) {
                that.largestWordSize = size;
                sizeChanged = true;
            }
            if (size < that.smallestWordSize) {
                that.smallestWordSize = size * 0.8; // set the smallest size a bit smaller than the actual smallest size; this will insure all words are legible.
                sizeChanged = true;
            }
            var wordObj = new Word(word, size, color, label, value);
            _words.push(wordObj);
        }
        return sizeChanged;
    }
    
    /**
     * Adds an array of objects with the following properties: word, size, color, label, value.
     * @param	words
     */
    this.addWords = function(newWords) {
        var sizeChanged = false;
        for (var i = 0; i < newWords.length; i++) {
            var wordObj = newWords[i];
            
            var color;
            if (typeof(wordObj.color) == undefined || wordObj.color == null || wordObj.color == '') {
                color = app.colors[Math.floor(Math.random() * (app.colors.length))];
            } else color = wordObj.color;
            
            var size;
            if (typeof(wordObj.size) == undefined || wordObj.size == null || wordObj.size == '') {
                size = Math.floor(Math.random() * 40);
            } else size = parseFloat(wordObj.size);
            
            sizeChanged = addWord(wordObj.word, size, color, wordObj.label, wordObj.value) || sizeChanged;
        }
        sortWords();
        
        this.setRelativeSizes();
        this.calculateSizeAdjustment();
        if (sizeChanged) this.resizeWords();
        else createAllGraphics();
    }
    
    this.resetWordCoordinates = function() {
        app.clear();
        clearTimeout(timer);
        for (var i = 0; i < _words.length; i++) {
            var word = _words[i];
            word.x = 0;
            word.y = 0;
            word.tx = 0;
            word.ty = 0;
        }
    }
    
    this.calculateSizeAdjustment = function() {
    	this.ratio = app.canvas.width / app.canvas.height;
        var stageArea = app.canvas.width * app.canvas.height;
        if (stageArea < 100000) this.minFontSize = 8;
        else this.minFontSize = 12;
        var pixelsPerWord = stageArea / _words.length;
        var totalWordsSize = 0;
        for (var i = 0; i < _words.length; i++) {
            var word = _words[i];
            var wordArea = calculateWordArea(word);
            totalWordsSize += wordArea;
        }
        this.sizeAdjustment = stageArea / totalWordsSize;
    }
    
    function calculateWordArea(word) {
        var baseSize = Math.log(word.relativeSize * 10) * Math.LOG10E; // take the relativeSize (0.1 to 1.0), multiply by 10, then get the base-10 log of it
        var height = (baseSize + word.relativeSize) / 2; // find the average between relativeSize and the log
        var width = 0; //(baseSize / 1.5) * word.text.length;
        for (var i = 0; i < word.text.length; i++ ) {
            var letter = word.text.charAt(i);
            if (letter == 'f' || letter == 'i' || letter == 'j' || letter == 'l' || letter == 'r' || letter == 't') width += baseSize / 3;
            else if (letter == 'm' || letter == 'w') width += baseSize / (4 / 3);
            else width += baseSize / 1.9;
        }
        var wordArea = height * width;
        return wordArea;
    }
    
    // based on post from http://stackoverflow.com/questions/1134586/how-can-you-find-the-height-of-text-on-an-html-canvas
    // not really working yet
    function measureTextHeight(label) {
        app.context.fillStyle = 'rgb(255,255,255)';
        app.context.fillRect(label.x, label.y, label.width, label.height);
        label.draw(app.context);
        var imageData = app.context.getImageData(label.x, label.y, label.width, label.height);
        var first = false;
        var last = false;
        var y = label.height;
        var x = 0;
        while (!last && y) {
            y--;
            for (x = 0; x < label.width; x++) {
                var pixel = getPixel(x, y, imageData);
                if (pixel[0] != 255 || pixel[1] != 255 || pixel[2] != 255) {
                    last = y;
                    break;
                }
            }
        }
        while (y) {
            y--;
            for (x = 0; x < label.width; x++) {
                var pixel = getPixel(x, y, imageData);
                if (pixel[0] != 255 || pixel[1] != 255 || pixel[2] != 255) {
                    first = y;
                    break;
                }
            }
            if (first != y) {
                return last - first;
            }
        }
        return 0;
    }
    
    function measureDimensions(word) {
        app.context.save();
        app.context.textBaseline = 'alphabetic';
        app.context.font = word.fontSize + 'px '+ word.fontFamily;
        word.width = app.context.measureText(word.text).width;
        word.height = Math.ceil(app.context.measureText('m').width * 1.15); // initial estimate (make it bigger for when we actually measure the height)
        app.context.restore();
    }
    
    // returns an array [r, g, b, a]
    function getPixel(x, y, imageData) {
        var index = (x + y * imageData.width) * 4;
        return [imageData.data[index], imageData.data[index+1], imageData.data[index+2], imageData.data[index+3]];
    }
    
    function setPixel(imageData, x, y, r, g, b, a) {
        var index = (x + y * imageData.width) * 4;
        imageData.data[index] = r;
        imageData.data[index+1] = g;
        imageData.data[index+2] = b;
        imageData.data[index+3] = a;
    }
    
    function findNewRelativeSize(word, areaMultiplier) {
        var area = calculateWordArea(word) * areaMultiplier;
        // given the area = (x+6)*(2*x/3*y), solve for x
        var newRelativeSize = (Math.sqrt(6) * Math.sqrt(6 * Math.pow(word.text.length, 2) + area * word.text.length) - 6 * word.text.length) / (2 * word.text.length);
        return newRelativeSize;
    }
    
    /**
     * Determines the relative size for each word.
     * Call after all/new words are added and before createAllGraphics.
     */
    this.setRelativeSizes = function() {
    	for (var i = 0; i < _words.length; i++) {
            var word = _words[i];
            word.relativeSize = mapValue(word.origSize, this.smallestWordSize, this.largestWordSize, 0.1, 1);
        }
    }
    
    /**
     * Re-adds words using new adjusted sizes.
     * Run after the largestWordSize and/or smallestWordSize have changed.
     * Need to run manually, since it's intensive.
     */
    this.resizeWords = function() {
        app.clear();
        createAllGraphics();
        sortWords();
    }
    
    /**
     * Sort the word list by size, largest first.
     */
    function sortWords() {
        _words.sort(function(a, b) {
            if (a.origSize > b.origSize) return -1;
            else if (a.origSize < b.origSize) return 1;
            else return 0;
        });
    }
    
    /**
     * Creates the Label that gets displayed on the stage.
     * Randomly selects an angle from possible values.
     * Calculates the mask of the word (used in hit detection).
     * @param	wordObj
     */

    function createWordGraphics(wordObj) {
        var adjustedSize = findNewRelativeSize(wordObj, that.sizeAdjustment);
        wordObj.fontSize = adjustedSize > that.minFontSize ? adjustedSize : that.minFontSize;
        wordObj.fontFamily = myFont;
        
        measureDimensions(wordObj);
        // these values are needed for accurate x and y co-ordinates after rotating the word
        wordObj.tx = 0;
        wordObj.ty = wordObj.height;
        //~ var trueHeight = measureTextHeight(wordObj);
        //~ console.log(wordObj.height, trueHeight);
        //~ wordObj.height = trueHeight;
        
        var angle = 0;
        
        if (that.getWordOrientation() === that.MIXED) {
	        if (wordObj.text.match(/\s/) == null) {
				if (Math.random() > 0.66) {
					var tempHeight = wordObj.height;
					var tempWidth = wordObj.width;
					wordObj.height = tempWidth;
					wordObj.width = tempHeight;
					if (Math.round(Math.random()) == 0) {
						angle = 90;
						wordObj.ty = 0;
					} else {
						angle = -90;
						wordObj.ty = wordObj.height;
						wordObj.tx = wordObj.width;
					}
				}
			}
        }
        
        

        wordObj.size = Math.max(wordObj.height, wordObj.width);
        wordObj.rotation = degreesToRadians(angle);
        
        // find the pixels that aren't transparent and store them as the mask
        app.context.fillStyle = app.canvas.style.backgroundColor;
        app.context.fillRect(0, 0, app.canvas.width, app.canvas.height);
        wordObj.draw(app.context);
        var imageData = app.context.getImageData(wordObj.x, wordObj.y, wordObj.width, wordObj.height);
        var mask = new Array();
        for (var x = 0; x < wordObj.width; x++) {
            var xm = Math.floor(x / that.COARSENESS) * that.COARSENESS;
            if (mask[xm] == null) mask[xm] = {};
            for (var y = 0; y < wordObj.height; y++) {
                var ym = Math.floor(y / that.COARSENESS) * that.COARSENESS;
                var pixel = getPixel(x, y, imageData);
                var pixelColor = 'rgb('+pixel[0]+', '+pixel[1]+', '+pixel[2]+')';
                if (pixelColor != app.canvas.style.backgroundColor) {
                    mask[xm][ym] = true;
                }
                if (mask[xm][ym]) {
                    y = ym + that.COARSENESS; // there's a match, so skip ahead
                    continue;
                }
            }
        }
        wordObj.mask = mask;
    }
    
    /**
     * Helper method which runs createWordGraphics for all the words.
     */
    function createAllGraphics() {
    	for (var i = 0; i < _words.length; i++) {
            createWordGraphics(_words[i]);
        }
    }
    
    /**
     * Arrange the words on the stage using the chosen layout scheme.
     */
    this.arrangeWords = function() {
//    	console.profile();
        clearTimeout(timer);
        app.clear(); // reset canvas
        
        this.toggleLoadingText();

        if (_words.length > 0) {
            
            this.grid = [];
            timer_i = 0; // used as the increment for the word list
      
            function doArrange() {                
                // common variables between the layout schemes
                var x;
                var y;
                var word;
                var breakOut;
                var fail;
                var wordCount = this.wordsToArrange - 1;
                var appCanvasWidth = app.canvas.width;
                var appCanvasHeight = app.canvas.height;
                var halfWidth = appCanvasWidth * 0.5;
                var halfHeight = appCanvasHeight * 0.5;
                var dd = 0.05;

                do {
                    word = _words[timer_i];
                    if (word !== undefined) {
	                    var a = Math.random() * Math.PI; // angle?
	                    var d = Math.random() * (word.size * 0.25); // diameter?
	                    var da = (Math.random() - 0.5) * 0.5;
	                    var halfWordWidth = word.width * 0.5;
	                    var halfWordHeight = word.height * 0.5;
	
	                    while (true) {
	                        x = Math.floor((halfWidth + (Math.cos(a) * d * this.ratio) - halfWordWidth) / this.COARSENESS) * this.COARSENESS;
	                        y = Math.floor((halfHeight + (Math.sin(a) * d) - halfWordHeight) / this.COARSENESS) * this.COARSENESS;
	
	                        fail = false;
	                        if (x + halfWordWidth >= appCanvasWidth || y + halfWordHeight >= appCanvasHeight) {
	                            fail = true;
	                        } else {
	                        	fail = hitTest(x, y, word.height, word.width, word.mask);
	                        }
	                        if (!fail) {
	                            break;
	                        }
	                        a += da;
	                        d += dd;
	                    }
	
	                    finalizeWord(x, y, word);
	                    if (app.useFadeEffect) {
	                    	word.alpha = 0;
		                    for (var w = 0; w < timer_i; w++) {
		                        var wrd = _words[w];
		                        if (wrd.alpha < 1) fadeWord(wrd);
		                    }
	                    } else {
	                    	word.alpha = 1;
	                    	word.draw(app.context);
	                    }
                    }
                    timer_i++;
                    if (timer_i >= _words.length) {
                        clearTimeout(timer);
//                        console.profileEnd();
                        this.doingArrange = false;
                        
                        this.toggleLoadingText(false);                               
                        
                        drawWords();
                        
                        break;
                    }
                } while (wordCount--);
            }
            
            /**
             * Test the mask of a word against the overall grid to see if they intersect.
             * @param	x
             * @param	y
             * @param	h
             * @param	w
             * @param	mask
             * @return
             */
            function hitTest(x, y, h, w, mask) {
                for (var xt = 0; xt <= w; xt += this.COARSENESS) {
                    for (var yt = 0; yt <= h; yt += this.COARSENESS) {
                        if (mask[xt] && mask[xt][yt] && this.grid[xt + x] != null && this.grid[xt + x][yt + y] != null) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            /**
             * Set the new position of the word, and make it visible.
             * @param	x
             * @param	y
             * @param	word
             * @param   drawIt
             */
            function finalizeWord(x, y, word, drawIt) {
                set_grid(x, y, word);

                word.x = x;
                word.y = y;

                word.live = true;
                if (drawIt) {
                	/*
                    if ($.browser.webkit) {
                        // cover the canvas with a transparent rectangle
                        // forces webkit to show the words
                        app.context.fillStyle = 'rgba(0,0,0,0)';
                        app.context.fillRect(0, 0, app.canvas.width, app.canvas.height);
                    }
                    */
                    word.draw(app.context);
                }
            }
            
            function fadeWord(word) {
                word.alpha += 0.25;
//                if ($.browser.webkit) {
                    // cover the canvas with a transparent rectangle
                    // forces webkit to show the words
//                    app.context.fillStyle = 'rgba(0,0,0,0)';
//                    app.context.fillRect(0, 0, app.canvas.width, app.canvas.height);
//               }
                word.draw(app.context);
            }

            /**
             * Mark the spots on the grid where the word is located.
             * @param	x
             * @param	y
             * @param	word
             */
            function set_grid(x, y, word) {
                for (var xt = 0; xt < word.width; xt += this.COARSENESS) {
                    for (var yt = 0; yt < word.height; yt += this.COARSENESS) {
                        if (word.mask[xt] && word.mask[xt][yt]) {
                            if (!this.grid[xt + x]) this.grid[xt + x] = [];
                            this.grid[xt + x][yt + y] = word;
                        }
                    }
                }
            }
            
            doArrange = doArrange.createDelegate(this);
            hitTest = hitTest.createDelegate(this);
            finalizeWord = finalizeWord.createDelegate(this);
            fadeWord = fadeWord.createDelegate(this);
            set_grid = set_grid.createDelegate(this);
            this.doingArrange = true;
            
//            if ($.browser.mozilla) {
//                // FF needs more time to perform each layout run
//                timer = setInterval(doArrange, 250);
//            } else {
                timer = setInterval(doArrange, 50);
//            }
            
        } else {
            alert("Error: There are no words to arrange.");
        }
    }
    
    this.toggleLoadingText = function(show) {
        app.context.save();
        
        if (show) app.context.fillStyle = 'black';
        else app.context.fillStyle = app.canvas.style.backgroundColor;
        
        app.context.textBaseline = 'top';
        app.context.font = '10px Arial';
        var offset = app.context.measureText('Loading').width + 10;
        app.context.fillText('Loading', app.canvas.width - offset, 10);
        
        app.context.restore();
    }
    
    this.startUpdates = function() {
    	timer = setInterval(drawWords, that.UPDATE_RATE);
    }
    
    this.stopUpdates = function() {
    	if (overWord != null) {
	    	// remove existing tooltip
	    	overWord = null;
	    	drawWords();
    	}
    	clearTimeout(timer);
    }
    
    function drawWords() {
        app.clear();
        var i = _words.length;
        while(i--) {
        	var word = _words[i];
            word.alpha = 1;
            if (word.live) word.draw(app.context);
        }
        var $canvasEl = $(app.canvas);
        if (overWord != null) {
        	// add pointer cursor
        	$canvasEl.css('cursor', 'pointer');
        	
            // draw the tooltip
            app.context.save();
            app.context.textBaseline = 'alphabetic';
            app.context.font = '12px Arial';
            
            var wordWidth = app.context.measureText(overWord.text).width;
            var valueWidth = app.context.measureText(overWord.value).width;
            var maxWidth = wordWidth > valueWidth ? wordWidth : valueWidth;
            maxWidth += 20;
            
            var x = overX + 15;
            var y = overY + 25;
            var appWidth = $canvasEl.width();
            var appHeight = $canvasEl.height();
            if (x + maxWidth >= appWidth) {
            	x -= maxWidth;
            }
            if (y + 40 >= appHeight) {
            	y -= 40;
            }
            
            app.context.fillStyle = 'rgba(255,255,255,0.9)';
            app.context.strokeStyle = 'rgba(100,100,100,0.9)';
            app.context.translate(x, y);
            app.context.fillRect(0, 0, maxWidth, 40);
            app.context.strokeRect(0, 0, maxWidth, 40);
            app.context.fillStyle = 'rgba(0,0,0,0.9)';
            app.context.fillText(overWord.text+':', 8, 18);
            app.context.fillText(overWord.value, 8, 30);
            app.context.restore();
        } else {
        	$canvasEl.css('cursor', 'default');
        }
    }
    
    /**
     * Checks to see if the mouse is currently over a word.
     * @param	event
     */
    this.handleMouseMove = function(event) {
        if (!this.doingArrange) {
        	var i = _words.length;
            while(i--) {
                _words[i].isOver = false;
            }
            var offset = $(app.canvas).offset();
            var remainder = (event.pageX - offset.left) % this.COARSENESS;
            var x = (event.pageX - offset.left) - remainder;
            remainder = (event.pageY - offset.top) % this.COARSENESS;
            var y = (event.pageY - offset.top) - remainder;
            overWord = this.findWordByCoords(x, y);
            if (overWord != null) {
                overWord.isOver = true;
                overX = x;
                overY = y;
            }
        }
    }
    
    /**
     * Checks to see if a word was clicked on, and then sends out the corresponding event.
     * @param	event
     * @return
     */
    this.handleWordClick = function(event) {
        var offset = $(app.canvas).offset();
        var remainder = (event.pageX - offset.left) % this.COARSENESS;
        var x = (event.pageX - offset.left) - remainder;
        remainder = (event.pageY - offset.top) % this.COARSENESS;
        var y = (event.pageY - offset.top) - remainder;
        var matchingWord = this.findWordByCoords(x, y);
        
        if (matchingWord != null) {
            return {text: matchingWord.text, value: matchingWord.value};
        }
    }
    
    /**
     * Returns the word which occupies the co-ordinates that were passed in.
     * @param	x
     * @param	y
     * @return
     */
    this.findWordByCoords = function(x, y) {
        var matchingWord = null;
        if (this.grid[x] !=  null) {
            if (this.grid[x][y] != null) {
                matchingWord = this.grid[x][y];
            } else if (this.grid[x][y + this.COARSENESS] != null) {
                matchingWord = this.grid[x][y + this.COARSENESS];
            }
        }
        if (matchingWord == null && this.grid[x + this.COARSENESS] != null) {
            if (this.grid[x + this.COARSENESS][y] != null) {
                matchingWord = this.grid[x + this.COARSENESS][y];
            } else if (this.grid [x + this.COARSENESS][y + this.COARSENESS] != null) {
                matchingWord = this.grid[x + this.COARSENESS][y + this.COARSENESS];
            }
        }
        
        return matchingWord;
    }
    
    /**
     * Convert an angle in degrees to radians.
     * @param	degrees
     * @return
     */
    function degreesToRadians(degrees) {
        var radians = degrees * (Math.PI / 180);
        return radians;
    }
    
    /**
     * Convenience function to map a variable from one coordinate space to another (from processing).
     */
    function mapValue(value, istart, istop, ostart, ostop) {
        return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
    }
    
}

// from Ext
Function.prototype.createDelegate = function(obj, args, appendArgs){
    var method = this;
    return function() {
        var callArgs = args || arguments;
        if (appendArgs === true){
            callArgs = Array.prototype.slice.call(arguments, 0);
            callArgs = callArgs.concat(args);
        }else if (typeof appendArgs=="number"){
            callArgs = Array.prototype.slice.call(arguments, 0); // copy arguments first
            var applyArgs = [appendArgs, 0].concat(args); // create method call params
            Array.prototype.splice.apply(callArgs, applyArgs); // splice them in
        }
        return method.apply(obj || window, callArgs);
    };
}
/**
 * Voyant changes & additions:
 * - height setter, height no longer calculated based on content
 * - replaced tree.size with tree.nodeSize
 * - pointer cursor for node
 * - rect now behind text, made opaque to block paths obscuring text
 * - branch length based on text length on per node basis
 * - click handler
 * - zoom fixes
 * - redraw checks for tries before re-running setup
 * - prevent negative height error
 */

/*
 * (This is the new BSD license.) Copyright (c) 2012-2014, Chris Culy All rights
 * reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: *
 * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer. * Redistributions in binary
 * form must reproduce the above copyright notice, this list of conditions and
 * the following disclaimer in the documentation and/or other materials provided
 * with the distribution. * Neither the name of the Chris Culy nor the names of
 * its contributors may be used to endorse or promote products from this
 * software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY Chris Culy ``AS IS'' AND ANY OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
 * EVENT SHALL Chris Culy BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";
/**
 * @namespace doubletree All of the functionality is in the doubletree namespace
 */
var doubletree = {};

(function() {

// TBD what about visWidth? to be fixed visWidth is really width and width
// is really just the width of one side of the doubletree

/**
 * @class doubletree.DoubleTree This is the class for the DoubleTree
 *        visualization
 */
doubletree.DoubleTree = function() {
	var containers = []; // nominally for allowing the same tree in
							// multiple places, but not tested and probably
							// doesn't work right (e.g. for search)
	// defaults. see below for getter/setters
	var visWidth = 600;
	var visHt = 400; // calculated, not settable
	var prefixesOnRight = false; // true for right to left writing systems
	var filters = {
		"left" : [],
		"right" : []
	};
	var handlers = {
		"alt" : noOp,
		"shift" : noOp,
		"click" : noOp
	};
	var showTokenExtra = true;
	var scaleLabels = true;
	var sortFun = doubletree.sortByStrFld("token");
	var nodeText = doubletree.tokenText; // default
	var tokenExtraText = function(info) {
		return doubletree.fieldText(info, "POS");
	};
	var rectColor = function(info) {
		return "rgba(255,255,255,1)";
	};
	var rectBorderColor = function(info) {
		return "rgba(255,255,255,1)";
	};
	var continuationColor = function(info) {
		return "red";
	};
	var basicStyles = {
		"node" : {
			"fill" : "white",
			"stroke" : "steelblue",
			"stroke-width" : "1.5px"
		},
		"branch" : {
			"stroke" : "#aaa",
			"stroke-width" : "1.5px"
		}
	};

	var succeeded = false; // did we succeed in building a DoubleTree? we
							// need this flag, since we no longer return
							// true/false from setupFromX (since we do
							// chaining)

	var dispatch = d3.dispatch("idsUpdated");
	dispatch.on("idsUpdated", function() {
		if (this == leftTree) {
			rtTree.setIds(leftTree.continuationIDs);
			rtTree.updateContinuations();
		} else if (this == rtTree) {
			leftTree.setIds(rtTree.continuationIDs);
			leftTree.updateContinuations();
		}
	});

	var leftTrie, rtTrie, leftTree, rtTree;
	var visibleIDs; // the ids of the results that are showing

	// tmp, until we can do sizing right. the font sizes are specified in
	// doubletree.css and manually copied here
	var kFontSize = 14; // normal
	var kBigFontSize = 1.15 * kFontSize; // for found text and
											// continuations (was 18) NB:
											// this is 0.05 bigger than in
											// doubletree.css
	var kMinFontSize = 8; // smallest that we'll scale to
	var textScale;

	/** @exports mine as doubletree.DoubleTree */
	/** @ignore */
	function mine(selection) {
		// generate container and data independent part of chart here, using
		// `width` and `height` etc

		selection.each(function(d, i) {
			// generate chart here; `d` is the data and `this` is the
			// element
			// really, storing containers. Use updateData and redraw to
			// really do the generation
			containers.push(this.node());
		});

	}

	/**
	 * initialize the visualization in one or more html containers
	 * <p>
	 * 
	 * @param containerPattern
	 *            CSS selector for the containers
	 */
	mine.init = function(containerPattern) {
		d3.select(d3.selectAll(containerPattern)).call(this);
		return mine;
	};

	/**
	 * redraw the visualization
	 */
	mine.redraw = function() {
		if (leftTrie !== undefined && rtTrie !== undefined) {
			mine.setupFromTries(leftTrie, rtTrie);
		}

		return mine;
	};

	/**
	 * set up the visualization using 2 {@link doubletree.Trie}s
	 * 
	 * @param leftOne
	 *            the left {@link doubletree.Trie}
	 * @param rtOne
	 *            the right {@link doubletree.Trie}
	 */
	mine.setupFromTries = function(leftOne, rtOne) {
		leftTrie = leftOne.getUniqRoot();
		rtTrie = rtOne.getUniqRoot();

		var leftTrieTree = leftTrie.toTree(filters.left);
		var rtTrieTree = rtTrie.toTree(filters.right);

		var copyIDs = true;
		if (Object.keys(rtTrieTree.pruned).length > 0) {
			new_pruneTree(rtTrieTree, rtTrieTree.pruned, copyIDs);
			new_pruneTree(leftTrieTree, rtTrieTree.pruned, copyIDs);
			copyIDs = false;
		}

		if (Object.keys(leftTrieTree.pruned).length > 0) {
			new_pruneTree(leftTrieTree, leftTrieTree.pruned, copyIDs);
			new_pruneTree(rtTrieTree, leftTrieTree.pruned, copyIDs);
		}

		// combine the info's from the two trees
		var newInfo = {}; // rtTrieTree.info;

		for ( var k in rtTrieTree.info) {
			if (k != "continuations" && k != "ids" && k != "count") {
				newInfo[k] = rtTrieTree.info[k];
			}
		}

		newInfo["right continuations"] = rtTrieTree.info.continuations;
		newInfo["left continuations"] = leftTrieTree.info.continuations;

		newInfo.ids = {};
		addTo(newInfo.ids, rtTrieTree.info.ids);
		addTo(newInfo.ids, leftTrieTree.info.ids);
		newInfo.count = Object.keys(newInfo.ids).length;
		visibleIDs = Object.keys(newInfo.ids);

		if (rtTrieTree.info.origIDs || leftTrieTree.info.origIDs) {
			newInfo.origIDs = {};
			addTo(newInfo.origIDs, rtTrieTree.info.origIDs);
			addTo(newInfo.origIDs, leftTrieTree.info.origIDs);
			newInfo.origCount = Object.keys(newInfo.origIDs).length;
		}

		rtTrieTree.info = newInfo;
		leftTrieTree.info = newInfo;

		var maxChildren = Math.max(leftTrieTree.maxChildren,
				rtTrieTree.maxChildren);
		if (isNaN(maxChildren) || maxChildren == 0) {
			succeeded = false;
			return mine;
		}

		if (scaleLabels) {
			textScale = d3.scaleLog().range([ kMinFontSize, kFontSize ]);
		} else {
			textScale = function() {
				return kFontSize;
			};
			textScale.domain = function() {
			};
		}

		var minCount = Math.min(leftTrieTree.minCount, rtTrieTree.minCount);
		textScale.domain([ minCount, leftTrieTree.info.count ]);

		// TBD ?? margin, width, height, duplicated in Tree
		var margin = {
			top : 20,
			right : 20,
			bottom : 20,
			left : 20
		};
		var width = visWidth - margin.right - margin.left;
		var height = visHt - margin.top - margin.bottom;

		containers.forEach(function(d, i) {
			var thisContainer = d;
			var thisVis;

			var tmp = d3.select(thisContainer).select("svg");
			if (tmp.node() == null) {
				thisVis = d3.select(thisContainer).append("svg")
					.attr("width", width + margin.right + margin.left)
					.attr("height", height + margin.top + margin.bottom)
					.attr("cursor", "move")
					.call(d3.zoom().scaleExtent([1,1]).on('zoom', function() {
						var x = d3.event.transform.x + width/2; // need offset because of initial offset in g element
						var y = d3.event.transform.y + height/2;
						d3.select(thisContainer).select("svg > g").attr("transform", 'translate('+x+','+y+')');
					}));

				thisVis.append("g") // container for both trees
					.attr('transform', 'translate('+width/2+','+height/2+')'); // initial offset

			} else {
				thisVis = tmp;
				thisVis
					.attr("width", width + margin.right + margin.left)
					.attr("height", height + margin.top + margin.bottom);
				thisVis.selectAll("g *").remove(); // clear
													// previous
			}

			leftTree = new doubletree.Tree(thisVis.select("g"),
					visWidth, visHt, leftTrieTree, true,
					sortFun, dispatch, textScale, showTokenExtra,
					nodeText, tokenExtraText, rectColor,
					rectBorderColor, continuationColor, basicStyles);
			rtTree = new doubletree.Tree(thisVis.select("g"),
					visWidth, visHt, rtTrieTree, false,
					sortFun, dispatch, textScale, showTokenExtra,
					nodeText, tokenExtraText, rectColor,
					rectBorderColor, continuationColor, basicStyles);
		});

		leftTree.handleAltPress = handlers.alt;
		rtTree.handleAltPress = handlers.alt;

		leftTree.handleShiftPress = handlers.shift;
		rtTree.handleShiftPress = handlers.shift;
		
		leftTree.handleClick = handlers.click;
		rtTree.handleClick = handlers.click;

		succeeded = true;
		return mine;
	};

	// hitArray is an array of items, prefixArray and suffixArray are arrays
	// of arrays of items
	/**
	 * set up the visualization from arrays corresponding to the hit, the
	 * prefix, and the suffix of a key word in context result.
	 * <p>
	 * The ith elements should correspond with each other. Each item
	 * consists of fields separated by a field delimiter. For example we
	 * might have word/tag (with / as the delimiter) or word\tlemma\tauthor
	 * (with tab (\t) as the delimiter) Only certain fields are relevant for
	 * deciding whether two items are to be considered the same (e.g. we
	 * might ignore an author field)
	 * 
	 * @param prefixArray
	 *            the array of arrays of the prefixes of the hits
	 * @param hitArray
	 *            the array of the hits
	 * @param suffixArray
	 *            the array of arrays of the suffixes of the hits
	 * @param idArray
	 *            the array of ids of the hits (or null, if there are no ids
	 *            for the hits)
	 * @param caseSensitive
	 *            are the hits case sensitive
	 * @param fieldNames
	 *            the names of the fields
	 * @param fieldDelim
	 *            the field delimiter
	 * @param distinguishingFieldsArray
	 *            the fields that determine identity
	 * @param prefixesOnRight
	 *            display the prefixes on the right, for right-to-left
	 *            writing systems. Default is false
	 */
	mine.setupFromArrays = function(prefixArray, hitArray, suffixArray, idArray, caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray) {

		if (undefined == caseSensitive && leftTrie) {
			caseSensitive = leftTrie.caseSensitive();
		}
		if (undefined == fieldNames && leftTrie) {
			fieldNames = leftTrie.fieldNames();
		}
		if (undefined == fieldDelim && leftTrie) {
			fieldDelim = leftTrie.fieldDelim();
		}
		if (undefined == distinguishingFieldsArray && leftTrie) {
			distinguishingFieldsArray = leftTrie.distinguishingFieldsArray();
		}

		leftTrie = new doubletree.Trie(caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);
		rtTrie = new doubletree.Trie(caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);

		var n = hitArray.length;
		for ( var i = 0; i < n; i++) {
			var thisID = idArray ? idArray[i] : i;
			var thisHit = hitArray[i];
			var thesePrefixes = prefixArray[i].slice();
			var theseSuffixes = suffixArray[i].slice();

			thesePrefixes.push(thisHit);
			thesePrefixes.reverse();
			theseSuffixes.unshift(thisHit);

			/*
			 * if (prefixesOnRight) { //e.g. for Arabic, Hebrew, N'Ko, ...
			 * thesePrefixes.push(thisHit); thesePrefixes.reverse();
			 * 
			 * rtTrie.addNgram( thesePrefixes, thisID);
			 * 
			 * theseSuffixes.unshift(thisHit); leftTrie.addNgram(
			 * theseSuffixes, thisID);
			 *  } else { thesePrefixes.push(thisHit);
			 * thesePrefixes.reverse(); leftTrie.addNgram( thesePrefixes,
			 * thisID);
			 * 
			 * theseSuffixes.unshift(thisHit); rtTrie.addNgram(
			 * theseSuffixes, thisID); }
			 */

			if (prefixesOnRight) {
				rtTrie.addNgram(thesePrefixes, thisID);
				leftTrie.addNgram(theseSuffixes, thisID);
			} else {
				leftTrie.addNgram(thesePrefixes, thisID);
				rtTrie.addNgram(theseSuffixes, thisID);
			}
		}

		mine.setupFromTries(leftTrie, rtTrie);
		return mine;
	};

	/**
	 * @returns just the <em>ids</em> of the data that satisfies the
	 *          current filters
	 */
	mine.filteredIDs = function() {
		return visibleIDs;
	};

	// return how many found
	/**
	 * search the nodes of the visualization for a pattern
	 * <p>
	 * The found nodes will get the CSS class foundText
	 * 
	 * @param searchRE
	 *            the regular expression to look for
	 * @returns how many nodes were found
	 */
	mine.search = function(searchRE) {
		leftTree.search(searchRE);
		rtTree.search(searchRE);

		var thisVis = d3.select(containers[0]);
		var found = thisVis.selectAll("text.foundText");

		if (found.empty()) {
			return 0;
		}

		var what = found[0].length;

		var foundRt = thisVis.selectAll("text.rtNdText.foundText");

		if (foundRt.node() != null) {
			what--; // root node, and we have 2 of those, so subtract one
					// from the count
		}
		return what;
	};

	/**
	 * clear the visualization of the search results
	 * <p>
	 * the CSS class foundText is removed
	 */
	mine.clearSearch = function() {
		leftTree.clearSearch();
		rtTree.clearSearch();
		return mine;
	};

	/**
	 * update the showing/hiding of extra information associated with the
	 * basic item, e.g. part of speech information
	 * <p>
	 * Notes:
	 * <ul>
	 * <li>This <em>DOES</em> redraw the visualization.</li>
	 * <li>Safari does not update the visualization correctly by itself, so
	 * we force it to rebuild the entire visualization, unlike in other
	 * browsers.</li>
	 * </ul>
	 */
	mine.updateTokenExtras = function() {
		leftTree.showTokenExtras(showTokenExtra);
		rtTree.showTokenExtras(showTokenExtra);

		// Safari doesn't update reshowing correctly, so we'll force it to
		// build this again :( (Chrome works correctly, so it's not a webkit
		// issue)
		var thisVis = d3.select(containers[0]);
		var tokExtra = thisVis.select('.tokenExtra[display="inline"]');
		if (!tokExtra.empty()) {
			var ht = tokExtra.style("height");
			if (ht == "0px") {
				mine.redraw();
			}
		}

		return mine;
	};

	// ////////// getter/setters
	/**
	 * Getter/setter for the maximum width of the DoubleTree area
	 * 
	 * @param value
	 *            the maximum width
	 */
	mine.visWidth = function(value) {
		if (!arguments.length)
			return visWidth;
		visWidth = value;
		return mine;
	};

	// ADDED
	mine.visHeight = function(value) {
		if (!arguments.length)
			return visHt;
		visHt = value;
		return mine;
	};

	/**
	 * Getter/setter for whether the prefixes are displayed on the right or
	 * the left.
	 * <p>
	 * The default value is false, i.e. the prefixes are displayed on the
	 * left, as in English. <em>prefixesOnRight</em> should be set to true
	 * for right-to-left writing systems such as Arabic, Hebrew, N'Ko, etc.
	 * 
	 * @param value
	 *            true or false
	 */
	mine.prefixesOnRight = function(value) {
		if (!arguments.length)
			return prefixesOnRight;
		prefixesOnRight = value;
		return mine;
	};

	// NB: doesn't redraw
	/**
	 * Getter/setter for the filter functions.
	 * <p>
	 * The filter functions get an information object as their argument, and
	 * return true/false. Each position away from the root has its own
	 * filter, and the left and right sides also have their own filters. The
	 * filters are specified via an object with "left" and "right" keys
	 * whose values are arrays of functions The function at index <em>i</em>
	 * filters position <em>i + 1</em> away from the root. Default is no
	 * filtering (via empty arrays)
	 * <p>
	 * Note: setting the filters does <em>not</em> redraw the
	 * visualization. See {@link #redraw}
	 * 
	 * @param value
	 *            an object containing the filters
	 */
	mine.filters = function(value) {
		if (!arguments.length)
			return filters;
		filters = value;
		return mine;
	};

	/**
	 * Getter/setter for the handlers for alt-click and shift-click on the
	 * nodes.
	 * <p>
	 * The handlers get an information object as their argument. The
	 * handlers are specified via an object with "alt" and "shift" keys
	 * whose values are functions The default is no handlers, i.e.
	 * <em>NO</em> interaction
	 * 
	 * @param value
	 *            an object containing the handlers
	 */
	mine.handlers = function(value) {
		if (!arguments.length)
			return handlers;
		handlers = value;
		return mine;
	};

	// NB: doesn't redraw
	/**
	 * Getter/setter for showing/hiding extra information associated with
	 * the main value, e.g. part of speech information.
	 * <p>
	 * Note: setting this value does <em>not</em> redraw the
	 * visualization. See {@link #redraw} Default is true
	 * 
	 * @param value
	 *            a boolean specifying whether to show the information or
	 *            not
	 */
	mine.showTokenExtra = function(value) {
		if (!arguments.length)
			return showTokenExtra;
		showTokenExtra = value;
		return mine;
	};

	/**
	 * Getter/setter for scaling the node labels by their frequency.
	 * <p>
	 * Default is true
	 * 
	 * @param value
	 *            a boolean specifying whether to scale the labels or not
	 */
	mine.scaleLabels = function(value) {
		if (!arguments.length)
			return scaleLabels;
		scaleLabels = value;
		return mine;
	};

	// succeeded is read only
	/**
	 * Reports whether the DoubleTree was constructed successfully
	 * <p>
	 * 
	 * @returns true if the DoubleTree was constructed successfully and
	 *          false otherwise
	 */
	mine.succeeded = function() {
		return succeeded;
	};

	/**
	 * Getter/setter for the function determining the sort order of sibling
	 * nodes.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return -1 for precedes, 1 for follows and 0 for don't care The nodes
	 * are displayed in "preceding" (i.e. ascending) order, from top to
	 * bottom. The default is alphabetical by a "token" field if there is
	 * one: doubletree.sortByStrFld("token")
	 * 
	 * @param the
	 *            sort order function
	 */
	mine.sortFun = function(value) {
		if (!arguments.length)
			return sortFun;
		sortFun = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the content of the node
	 * labels.
	 * <p>
	 * The function gets an information object as its first argument and a
	 * boolean indicating whether the node is the root or not as its second
	 * argument. The function should return a string. The default is
	 * {@link #tokenText}
	 * 
	 * @param the
	 *            content function
	 */
	mine.nodeText = function(value) {
		if (!arguments.length)
			return nodeText;
		nodeText = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the content of the "extra"
	 * information for the labels labels
	 * <p>
	 * The function gets an information object as its first argument and a
	 * boolean indicating whether the node is the root or not as its second
	 * argument. The function should return a string. The default is the POS
	 * field of the information object
	 * 
	 * @param the
	 *            content function
	 */
	mine.tokenExtraText = function(value) {
		if (!arguments.length)
			return tokenExtraText;
		tokenExtraText = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the color of the
	 * background rectangles for the nodes.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return a CSS color in a string, e.g. "rgba(255,128,0,0.5)" The
	 * default is transparent white (i.e., effectively no color);
	 * 
	 * @param value
	 *            the background color function
	 */
	mine.rectColor = function(value) {
		if (!arguments.length)
			return rectColor;
		rectColor = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the color of the borders
	 * of the background rectangles for the nodes.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return a CSS color in a string, e.g. "rgba(255,128,0,0.5)" The
	 * default is transparent white (i.e., effectively no color);
	 * 
	 * @param value
	 *            the border color function
	 */
	mine.rectBorderColor = function(value) {
		if (!arguments.length)
			return rectBorderColor;
		rectBorderColor = value;
		return mine;
	};

	/**
	 * Getter/setter for the function determining the color of the text of
	 * the nodes that are continuations of the clicked node.
	 * <p>
	 * The function gets an information object as its argument, and should
	 * return a CSS color in a string, e.g. "rgba(255,128,0,0.5)" The
	 * default is transparent white (i.e., effectively no color);
	 * 
	 * @param value
	 *            the border color function
	 */
	mine.continuationColor = function(value) {
		if (!arguments.length)
			return continuationColor;
		continuationColor = value;
		return mine;
	};

	/**
	 * Getter/setter for the styles of the nodes and branches. For now these
	 * are constant throughout the tree. Takes an object of the form:
	 * {"node":{"fill":cssColor, "stroke":cssColor,
	 * "stroke-width":cssWidth}, "branch":{"stroke":cssColor,
	 * "stroke-width":cssWidth}} All of the attributes are optional Defaults
	 * are: {"node":{"fill":"white", "stroke":"steelblue",
	 * "stroke-width":"1.5px"}, "branch":{"stroke":"#777",
	 * "stroke-width":"1.5px"}};
	 */
	mine.basicStyles = function(stylesObj) {
		if (!arguments.length)
			return basicStyles;

		Object.keys(basicStyles).forEach(
			function(aspect) {
				if (aspect in stylesObj) {
					Object.keys(basicStyles[aspect]).forEach(
						function(attr) {
							if (attr in stylesObj[aspect]) {
								basicStyles[aspect][attr] = stylesObj[aspect][attr];
							}
						});
				}
			});
		return mine;
	};

	return mine;
};

// ////// tree for doubletree
/** @private */
doubletree.Tree = function(vis, visWidth, visHt, data, toLeft,
		sortFun, dispatch, textScale, showTokenXtra, nodeTextFun,
		tokenExtraTextFun, rectColorFun, rectBorderFun, contColorFun,
		baseStyles) {
	var showTokenExtra = false || showTokenXtra;
	var continuationIDs = {};
	var clickedNode;
	var nodeText = nodeTextFun;
	var tokenExtraText = tokenExtraTextFun;
	var rectColor = rectColorFun;
	var rectBorderColor = rectBorderFun;
	var continuationColor = contColorFun;
	var basicStyles = baseStyles;

	var margin = {
		top : 20,
		right : 20,
		bottom : 20,
		left : 20
	}, width = visWidth - margin.right - margin.left, height = visHt - margin.top - margin.bottom, i = 0, duration = 200, root;
	var dx;

	if (!sortFun) {
		sortFun = doubletree.sortByStrFld("token");
	}

	var i = 0;
	var tree = d3.tree()
	.size([height, width])
	.nodeSize([ 40, 40 ]);
	//.sort(sortFun);

	var diagonal = d3.linkHorizontal()
		.x(function(d) { return positionX(d.y); })
		.y(function(d) { return positionY(d.x); });

	vis = vis.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	// //////
	this.readJSONTree = function(json) {
		root = d3.hierarchy(json);
		root.x0 = 0;
		root.y0 = 0;

		root.children.forEach(collapse);
		this.update(root);
	};

	// CC had been inside readJSONTree
	function collapse(d) {
		if (d.children) {
			d._children = d.children;
			d._children.forEach(collapse);
			d.children = null;
		}
	}

	// CC new
	function collapseSiblings(nd) {
		if (nd.parent) {
			nd.parent.children.forEach(function(d) {
				if (d != nd) {
					collapse(d);
				}
			});
		}
	}

	this.update = function(source) {
		// seems unnecessary
//		if (!source) {
//			source = root;
//		}

		// Compute the new tree layout.
		var treeData = tree(root);
		var nodes = treeData.descendants();

		var baseBranchSegmentWidth = 25;
		// Normalize for fixed-depth.
		nodes.forEach(function(d) {
			var textSize = d.textSize;
			if (textSize == undefined) {
				textSize = 0;
				var parent = d.parent;
				while (parent != null) {
					var measured = Ext.draw.TextMeasurer.measureText(parent.data.name, 'arial').width;
					textSize += measured;
					parent = parent.parent;
				}
				d.textSize = textSize; // cache the size so we don't recalculate each time
			}
			d.y = (d.depth * baseBranchSegmentWidth) + textSize;
		});
		
		
		// Update the nodes…
		var node = vis.selectAll("g.node_" + toLeft)
			.data(nodes, function(d) {
				return d.id || (d.id = ++i);
			});

		// Enter any new nodes at the parent's previous position.
		var nodeEnter = node.enter().append("g").attr("class", "node node_" + toLeft).attr("cursor", "pointer")
			.attr("transform", function(d) {
				return "translate(" + positionX(source.y0) + "," + positionY(source.x0) + ")";
			})
			.on("click", click);

		nodeEnter.append("title").text(function(d) {
			var what = doubletree.infoToText(d.data.info);
			return what;
		});

		nodeEnter.append("circle")
			.attr("r", 1e-6)
			.style("fill", function(d) {
				return d._children ? "#fff" : basicStyles.node.fill;
			})
			.style("stroke", function(d) {
				return basicStyles.node.stroke;
			});

		var txtNode = nodeEnter.append("text").attr("class", function(d) {
			if (d.depth == 0) {
				return "rtNdText";
			} else {
				return "";
			}
		}).attr("x", function(d) {
			if (d.children || d._children) {
				return 0;
			} else {
				return toLeft ? 10 : -10;
			}
		}).attr("text-anchor", function(d) {
			if (!d.parent) {
				return "middle";
			}
			if (d.children || d._children) {
				return toLeft ? "end" : "start";
			} else {
				return toLeft ? "start" : "end";
			}
		}).style("font-size", function(d) {
			/*
			 * if (d.depth == 0 && toLeft) { return 0; //suppress left side
			 * root -- do this because of differences in counts when
			 * filtering }
			 */
			return textScale(d.data.info.count) + "pt";
		});

		txtNode.append("tspan").attr("dy", ".35em").attr("class", "tokenText").text(function(d) {
			return nodeText(d.data.info, d.depth < 1);
		}).style("fill-opacity", 1e-6);

		txtNode.append("tspan").attr("dx", ".35em").attr("class", "tokenExtra").text(function(d) {
			return tokenExtraText(d.data.info, d.depth < 1);
		}).style("fill-opacity", 1e-6);

		
		this.drawRects();

		var nodeUpdate = nodeEnter.merge(node);
		
		// Transition nodes to their new position.
		nodeUpdate.transition().duration(duration)
			.attr("transform", function(d) {
				return "translate(" + positionX(d.y) + "," + positionY(d.x) + ")";
			});

		nodeUpdate.select("circle")
			// .attr("r", 4.5)
			.attr("r", function(d) {
				return (d.children || d._children) ? 1e-6 : 4.5;
			})
			.style("fill", function(d) {
				return d._children ? "#fff" : basicStyles.node.fill;
			}) // function(d) { return d._children ? "lightsteelblue" : "#fff";
				// })
			.style("stroke-width", basicStyles.node["stroke-width"]);

		nodeUpdate.selectAll("tspan").style("fill-opacity", 1);

		// Transition exiting nodes to the parent's new position.
		var nodeExit = node.exit().transition().duration(duration).attr("transform", function(d) {
			return "translate(" + positionX(source.y) + "," + positionY(source.x) + ")";
		}).remove();

		nodeExit.select("circle").attr("r", 1e-6);

		// nodeExit.select("text")
		nodeExit.selectAll("tspan").style("fill-opacity", 1e-6);

		// Update the links…
		var link = vis.selectAll("path.link_" + toLeft)
			.data(root.links(), function(d) {
				var id = d.source.id+'-'+d.target.id;
				return id;
			});

		// Enter any new links at the parent's previous position.
		var linkEnter = link.enter().insert("path", "g").attr("class", "link link_" + toLeft)
			.attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return diagonal({source: o, target: o});
			})
			.style("fill", "none").style("stroke", basicStyles.branch.stroke).style("stroke-width", basicStyles.branch["stroke-width"]);

		var linkUpdate = linkEnter.merge(link);
		
		// Transition links to their new position.
		linkUpdate.transition().duration(duration).attr("d", diagonal);

		// Transition exiting nodes to the parent's new position.
		var linkExit = link.exit().transition().duration(duration)
			.attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return diagonal({source: o, target: o});
			})
			.remove();

		// Stash the old positions for transition.
		nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
		});

		this.updateContinuations();		
	};
	
	this.drawRects = function() {
		var which = showTokenExtra ? "inline" : "none";
		vis.selectAll(".tokenExtra").attr("display", which);

		var node = vis.selectAll("g.node_" + toLeft);
		
		node.selectAll("rect").remove(); // remove previous rects

		var nodeRect = node
				.insert("rect", "text")
				.attr("class", "nodeRect")
				.attr("height", function() {
					var height = this.parentElement.getBBox().height;
					if (height < 6) {
						// end of branch, need to prevent negative height
						height = 6.1;
					}
					return height - 6;
				})
				.attr("y", function(d) {
					if (!d.parent) {
						return -0.5 * this.parentElement.getBBox().height / 2 - 2;
					} else {
						return -0.5 * this.parentElement.getBBox().height / 2;
					}
				})
				.attr("width", function() {
					return this.parentElement.getBBox().width;
				})
				.attr("x", function(d) {
					var parentW = this.parentElement.getBBox().width;
					if (!d.parent) {
						return -0.33333 * parentW;
					}
					if (!toLeft) {
						return 0;
					}
					return -0.5 * parentW;
				})
				// .style("stroke-opacity", 1e-6)
				.style("stroke-opacity", 1).style("stroke-width", 1)
				.style("stroke", function(d) {
					return rectBorderColor(d.data.info);
				}).style("fill", function(d) {
					return rectColor(d.data.info);
				}).style("fill-opacity", function(d) {
					return 1;
//					if (!d.parent && !toLeft) {
//						return 1e-6;
//					} else {
//						return 1;
//					}
				});
	};

	var that = this;
	
	// Toggle children on click.
	function click(d, i) {
		if (d3.event.altKey) {
			that.handleAltPress(d, i);
			// that.showTokenExtras(showTokenExtra);
			return;
		}
		if (d3.event.shiftKey) {
			that.handleShiftPress(d, i);
			// that.showTokenExtras(showTokenExtra);
			return;
		}

		that.handleClick(d, i);
		
		if (!d.parent) {
			return;
		}
		if (that.continuationIDs != d.data.info.ids) {
			that.setIds(d.data.info.ids);
			that.clickedNode = d.id;
			dispatch.call('idsUpdated', that);
		}

		collapseSiblings(d); // CC new
		/*
		 * if (d.children) { d._children = d.children; d.children = null; }
		 * else { d.children = d._children; d._children = null; }
		 * that.update(d);
		 */
		toggleChildren(d, true);
	}

	function toggleChildren(d, update) { // we only update the clicked
											// node, not recursively
		// collapseSiblings(d); //CC we don't do this here, since after the
		// top level there's no point

		if (d.children) {
			if (d.children && d.children.length == 1) {
				toggleChildren(d.children[0], true); // need true to make
														// sure we toggle
														// all the way down
			}
			d._children = d.children;
			d.children = null;

		} else {
			d.children = d._children;
			d._children = null;

			// expand all if there is only one path
			if (d.children && d.children.length == 1) {
				toggleChildren(d.children[0], false);
			}
		}
		if (update) {
			that.update(d);
		}
	}

	this.setIds = function(ids) {
		that.continuationIDs = ids;
	};
	this.updateContinuations = function() {
		vis.selectAll("g.node_" + toLeft + " text")
			.classed("continuation", function(d) {
					var isContinuation = overlap(d.data.info.ids, that.continuationIDs || {});
					return isContinuation;
			})
			.style("fill", function(d) {
				if (d3.select(this).classed("continuation")) {
					return continuationColor(d.data.info);
				}
				return "#444"; // default text color
			}); // this is duplicated from above, nodeUpdate
	};

	this.search = function(searchRE) {
		vis.selectAll("g.node text").classed("foundText", function(d) {
			var what = searchRE.test(nodeText(d.data.info));
			return what;
		});
	};

	this.clearSearch = function() {
		vis.selectAll("g.node text").classed("foundText", false);
	};

	this.showTokenExtras = function(show) {
		if (arguments.length == 0) {
			return showTokenExtra;
		}
		showTokenExtra = show;

		this.drawRects();
		return this;
	};

	this.setRectColor = function(rectColorFun) {
		if (arguments.length == 0) {
			return rectColor;
		}
		rectColor = rectColorFun;
		this.drawRects();
		return this;
	};

	// /////////////
	function positionX(x) {
		return toLeft ? -x : x;
	}
	function positionY(y) {
		return y;
	}

	// //default modifier handlers
	this.handleAltPress = function() {
	};
	this.handleShifttPress = function() {
	};
	this.handleClick = function() {
	};

	this.readJSONTree(data);
	return this;
};

// /////////////////////////////// tree sorting functions
/**
 * function to sort the nodes (case insenstive) by a field in the
 * information object
 * 
 * @param fld
 *            the field to sort by
 */
doubletree.sortByStrFld = function(fld) {
	var field = fld;
	return function(a, b) {
		var aUndefined = (undefined == a.data.info[field]);
		var bUndefined = (undefined == b.data.info[field]);
		if (aUndefined && bUndefined) {
			return 0;
		} else if (aUndefined) {
			return -1;
		} else if (bUndefined) {
			return 1;
		}
		var aVal = a.data.info[field].join(" ").toLowerCase();
		var bVal = b.data.info[field].join(" ").toLowerCase();
		if (aVal < bVal) {
			return -1;
		} else if (aVal > bVal) {
			return 1;
		}
		return 0;
	};
};
/**
 * function to sort the nodes according to the count field in the
 * information object
 */
doubletree.sortByCount = function() {
	return function(a, b) {
		return b.data.info.count - a.data.info.count;
	};
};

/**
 * function to sort the nodes according to the continuations field in the
 * information object
 */
doubletree.sortByContinuations = function() {
	return function(a, b) {
		return b.data.info.continuations - a.data.info.continuations;
	};
};

// /////////////////////////////// some tree filtering functions
/**
 * function to filter the nodes according to a minimum for the count field
 * 
 * @param n
 *            the minimum count to include
 */
doubletree.filterByMinCount = function(n) {
	return function(inf) {
		return inf.count >= n;
	};
};

/**
 * function to filter the nodes according to a maximum for the count field
 * 
 * @param n
 *            the maximum count to include
 */
doubletree.filterByMaxCount = function(n) {
	return function(inf) {
		return inf.count <= n;
	};
};

/**
 * function to filter the nodes according to the "POS" field (if it exists)
 * 
 * @param n
 *            a string for a regular expression of the POS values to include
 */
doubletree.filterByPOS = function(pos) {
	var re = new RegExp(pos);
	return function(inf) {
		return inf["POS"] && inf["POS"].filter(function(p) {
			return p.search(re) > -1;
		}).length > 0; // end of ng has no POS
	};
};

// /////////////////////////////// formatting functions

// doubletree.nodeText = function(info) {
// return doubletree.tokenText(info); //default
// }

// extracts a field
/**
 * return the value of a field in the provided information object
 * 
 * @param info
 *            the information object
 * @param the
 *            field to get
 * @returns the value of the field in the information object
 */
doubletree.fieldText = function(info, fieldName) {
	return info[fieldName];
};
// extracts the "token" field
/**
 * convenience function to return the value of the "token" field (if it
 * exists). The same as doubletree.fieldText(info, "token")
 * 
 * @param info
 *            the information object
 * @returns the value of the "token" field of the information object
 */
doubletree.tokenText = function(info) {
	var tokenText = '';
	if (info.token !== undefined) {
		tokenText = info.token;//info.token[0]; // don't return all token values, just the first
	}
	return tokenText;
};

/**
 * converts an information object to a string
 * 
 * @param the
 *            information object
 * @returns a string with one key/value pair per line
 */
doubletree.infoToText = function(info) {
	var what = "";
	for ( var infp in info) {
		if (infp == "ids" || infp == "origIDs") {
			what += infp + "\t:\t" + Object.keys(info[infp]).join(",")
					+ "\n";
		} else {
			what += (infp + "\t:\t" + info[infp] + "\n");
		}
	}
	return what;
};
// //////////////// internal utility functions

function old_pruneTree(tree, ids) {

	if (!tree.children) {
		return;
	}

	var n = tree.children.length;
	for ( var i = 0; i < n; i++) {
		var c = tree.children[i];

		if (containedIn(c.info.ids, ids)) {
			tree.children[i] = null;
		} else {
			old_pruneTree(c, ids);
		}
	}
	tree.children = tree.children.filter(function(c) {
		return c != null;
	});

	// recalculate maxChildren
	var cMax = d3.max(tree.children.map(function(c) {
		return c.maxChildren;
	}));
	tree.maxChildren = Math.max(tree.children.length, cMax);
}

function new_pruneTree(tree, ids, copyIDs) {

	if (!tree.children) {
		return;
	}

	// copy over original ids
	if (copyIDs) {
		if (!tree.info.origIDs) {
			tree.info.origIDs = {};
			addTo(tree.info.origIDs, tree.info.ids);
			tree.info.origCount = Object.keys(tree.info.origIDs).length;
		} else {
			tree.info.ids = {};
			addTo(tree.info.ids, tree.info.origIDs);
			tree.info.count = Object.keys(tree.info.ids).length;
		}
	}

	// adjust IDs
	var idNums = Object.keys(ids);
	for ( var i = 0, n = idNums.length; i < n; i++) {
		var cid = idNums[i];
		delete tree.info.ids[cid];
	}
	tree.info.count = Object.keys(tree.info.ids).length;

	// recurse and prune
	var n = tree.children.length;
	for ( var i = 0; i < n; i++) {
		var c = tree.children[i];

		if (containedIn(c.info.ids, ids)) {
			tree.children[i] = null;
		} else {
			new_pruneTree(c, ids, false);
		}
	}
	tree.children = tree.children.filter(function(c) {
		return c != null;
	});
	tree.info.continuations = tree.children.length;

	// recalculate maxChildren
	var cMax = d3.max(tree.children.map(function(c) {
		return c.maxChildren;
	}));
	tree.maxChildren = Math.max(tree.children.length, cMax);
}

function restoreTree(tree) {

	if (tree.info.origCount) { // otherwise tree was suppressed, so its ids
								// never got switched around
		// restore originals
		tree.info.ids = {};
		addTo(tree.info.ids, tree.info.origIDs);
		// delete tree.info.origIDs;
		tree.info.count = tree.info.origCount;
		// delete tree.info.origCount;

		var n = tree.children.length;
		tree.info.continuations = n;
		for ( var i = 0; i < n; i++) {
			var c = tree.children[i];
			restoreTree(c);
		}
	}

}

// do the keys in o1 and o2 overlap
function overlap(o1, o2) {
	for ( var k in o1) {
		if (k in o2) {
			return true;
		}
	}
	return false;
}
// are all the keys in o1 also in o2
function containedIn(o1, o2) {
	if (!o1 || !o2) {
		return false;
	}
	for ( var k in o1) {
		if (!(k in o2)) {
			return false;
		}
	}
	return true;
}

// add key/vals of o2 to o1 and return o1; (top level key-value only, o2
// values maintained over o1)
// same as in Trie.js
function addTo(o1, o2) {
	for ( var k in o2) {
		o1[k] = o2[k];
	}
}

function noOp() {
}

// ////////////////

})();
/* (This is the new BSD license.)
* Copyright (c) 2012-2014, Chris Culy
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the Chris Culy nor the 
*		names of its contributors may be used to endorse or promote 
*		products from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY Chris Culy
* ``AS IS'' AND ANY OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
* THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
* ARE DISCLAIMED. IN NO EVENT SHALL Chris Culy
* BE LIABLE FOR ANY, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
* CONSEQUENTIAL DAMAGES INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
* GOODS OR SERVICES; OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
* CAUSED AND ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
* TORT INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

"use strict";
var doubletree = doubletree || {};

(function(){
    
    /**
     * @class doubletree.Trie
     * This is the class for the specialized trie that is the data for {@link doubletree.DoubleTree}.
 * The Trie will get pieces of data that contain fields. Some (possibly all) of those fields will be used for distinguishing among items.
 * For example, we might have an "author" field, but not use it when distinguishing among items for the Trie.
 * @param caseSensitive are the elements in the first distinguishing field compared in a case sensitive fashion
 * @param fldNames the names of the fields
 * @param fldDelim the field delimiter
 * @distinguishingFldsArray the distinguishing fields
 * @undistinguishedRoot true if the root should be calculated without using the distinguishing fields
 */
doubletree.Trie = function(caseSensitive, fldNames, fldDelim, distinguishingFldsArray, undistinguishedRoot) {
    var endNG = " ";
    var rootName = "_root_";
    var noCase = (! caseSensitive) && true;
    if (! fldNames) {
        fldNames = ["item"];
    }
    var fieldNames = fldNames;
    if (! fieldDelim) {
        fieldDelim = "\t"; //default
    }
    var fieldDelim = fldDelim;
    if (! distinguishingFieldsArray) {
        distinguishingFieldsArray = [ fieldNames[0] ];
    }
    var distinguishingFieldsArray = distinguishingFldsArray;
    var undistinguishedRt = undistinguishedRoot;
    if (undefined == undistinguishedRt) {
        undistinguishedRt = true; //TBD: check to make sure this doesn't break anything
    }
    
    var trie = new TrieNode(rootName,-1,0);
    
    /** @private */
    function TrieNode(item, id, count) {
        this.id = id;
        this.count = count;        
        this.info = {"count":count, "ids":{}};
        
        if (item == null) {
            this.item = rootName;        
        } else {
            this.item = item;
            this.info.ids = {};
            this.info.ids[id] = true;
            var flds = item.split(fieldDelim);
            for(var i in flds) {
                this.info[ fieldNames[i] ] = [ flds[i] ];
            }
        }
        this.nodes = {};
        
         /** @private */
        this.addNgram = function(itemArray, id, count) {
            if (! count) {
                count = 1;
            }
            var thisItem, thisKey;
            if (itemArray.length > 0) {
                thisItem = itemArray.shift();
                    
                var theseFlds = thisItem.split(fieldDelim);

                if (undistinguishedRt && this.item == rootName) {
                    thisKey = "";
                } else {
                    thisKey = theseFlds.filter(function(f,i) {
                            return distinguishingFieldsArray.indexOf( fieldNames[i] ) > -1;
                        })
                    .map(function(f) {
                            if (noCase) {
                                return f.toLocaleLowerCase();
                            }
                            return f;
                        })
                    .join(fieldDelim);
                }
                
            } else {
                thisItem = endNG;
                thisKey = thisItem;
            }
            
            var subTrie;
            if (thisKey in this.nodes && this.nodes[thisKey] instanceof TrieNode) { //we need the instanceof TrieNode so we can override Object properties -- hope that none are already arrays
                subTrie = this.nodes[thisKey];
                subTrie.info.count += count;
                subTrie.info.ids[id] = true;
                
                for(var f in theseFlds) {
                    var thisFld = theseFlds[f];
                    if (subTrie.info[ fieldNames[f] ].indexOf( thisFld ) == -1 ){
                        subTrie.info[ fieldNames[f] ].push(thisFld);
                    }                
                }
                
                
            } else {
                subTrie = new TrieNode(thisItem, id, count);            
                this.nodes[thisKey] = subTrie;
            }
            if (thisItem != endNG) {
                subTrie.addNgram(itemArray,id, count);
            }
        };
            
         /** @private */
        this.getUniqRoot = function() {
            if (this.item == rootName) {
                var children = Object.keys(this.nodes);
                if (children.length == 1) {
                    return this.nodes[ children[0] ];
                }
            }
        
            return this;
        };
        
        /** @private */
        this.toTree = function(filterFuns) {
            
            function toTreeHelper(filterFuns, descendentLevel, trieData) {
                
                var what = {"children":[]};
                what.name = trieData.item;
                what.info = {};
                for(var k in trieData.info) {
                    if (typeof(trieData.info[k]) === 'Object') {
                        what.info[k] = {};
                        for(var k2 in trieData.info[k]) {
                            what.info[k][k2] = this.info[k][k2];
                        }
                    } else {
                        what.info[k] = trieData.info[k];
                    }
                }
                what.pruned = {};
                
                
                for(var item in trieData.nodes) {
                    var itemNode = trieData.nodes[item];
                    var thisFilter = filterFuns[descendentLevel];            
                    if ( ! thisFilter || (thisFilter && thisFilter(itemNode.info)) ) {
                        what.children.push( toTreeHelper(filterFuns, descendentLevel +1, itemNode) );
                        if (itemNode.pruned != {}) {
                            addTo(what.pruned, itemNode.pruned);
                        }
                    } else {
                        addTo(what.pruned, itemNode.info.ids);
                    }
                }
        
                what.info.continuations = what.children.length;
                //this is to record info we need for sizing the tree, since D3 automatically scales to fit, which is not what we want
                //we also need to keep track of the minimum count (the root always has the max, of course), for scaling
                if (what.children.length == 0) {
                   what.children = null; //the trees expect null if there are no children, not the empty array. Odd, but true.
                   what.maxChildren = 0;
                   
                   if (what.name) {
                    what.maxLen = what.name.length;
                   } else {
                    what.maxLen = 0;
                   }
                   
                   what.minCount = what.info.count;
                   //what.maxChildren = 0; //new
                   
                } else {
                    var cMax = d3.max( what.children.map(function(c) {return c.maxChildren;}) );
                    what.maxChildren = Math.max(what.children.length, cMax);
                    
                    var maxLen = d3.max( what.children.map(function(c) {return c.maxLen;}));
                    what.maxLen = Math.max(maxLen, what.name.length);
                    
                    what.minCount = d3.min( what.children.map(function(c) {return c.minCount;})); //the children are always <= the parent
                }
                return what;
            }
            
            if (! filterFuns ) {
                filterFuns = [];
            }
            
            var trieData = JSON.parse(JSON.stringify(this)); //CuC make a copy of the data, to keep the real trie immutable
        
            return toTreeHelper(filterFuns, 0, trieData);
        };
    }
    
    
    
    
    /**
     * Add an ngram to the Trie
     * @param itemArray an array of delimited items (the ngrams)
     * @param id an id for this ngram 
     * @param count a count for this ngram. Default is 1
     */
    this.addNgram = function(itemArray, id, count) {trie.addNgram(itemArray, id, count);};
    
    /**
     * get the unique root of this Trie. Used only by {@link DoubleTree}
     * @returns a new Trie with a unique item as the root
     */
    this.getUniqRoot = function() {
        var what = new doubletree.Trie((!noCase), fieldNames, fieldDelim, distinguishingFieldsArray);
        what.trie( trie.getUniqRoot() );
        return what;
    };
    
    /**
     * convert the Trie to a tree structure for display. Used only by {@link DoubleTree}
     * @param filterFuns the filtering functions to apply to the tree see {@link DoubleTree.filters}
     * @param descendentLevel the current level we are filtering
     * @returns the tree
     */
    this.toTree = function(filterFuns, descendentLevel) {return trie.toTree(filterFuns, descendentLevel);};
    
    /**
     * serialize the Trie as a JSON string
     * @returns the JSON string representation of the Trie
     */
    this.serialize = function() {
        return JSON.stringify(this);
    };
    
    /**
     * make this Trie have the values of a previously serialized Trie see {@link #serialize}
     */
    this.deserialize = function(serialized) {
        var obj = JSON.parse(serialized);
        
        endNG = obj.endNG();
        rootName = obj.rootName();
        noCase = obj.caseSensitive();
        fieldNames = obj.fieldNames();
        fieldDelim = obj.fieldDelim();
        distinguishingFieldsArray = obj.distinguishingFieldsArray();
        trie = obj.trie();
        
    };
    
    //getters -- the properties are readonly, set in constructor
    
    //private, only used in deserialization
    /** @private */
    this.endNG = function() {
        return endNG;
    };
    //private, only used in deserialization
    /** @private */
    this.rootName = function() {
        return rootName;
    };
    
    //private, also a setter, only used in deserialization and getUniqRoot;
    /** @private */
    this.trie = function(value) {
      if (arguments.length > 0) {
        trie = value;
      }
      return trie;
    };
    
    /**
     * @returns whether this Trie uses case sensitive comparison
     */
    this.caseSensitive = function() {
        return ! noCase;
    };
    
    /**
     * get the field names in the data
     * @returns the field names in the data
     */
    this.fieldNames = function() {
        return fieldNames;
    };
    
    /**
     * get the field delimiter for the data
     * @returns the field delimiter for the data
     */
    this.fieldDelim = function() {
        return fieldDelim;
    };
    
    /**
     * get the distinguishing fields for the data
     * @returns the distinguishing fields for the data
     */
    this.distinguishingFieldsArray = function() {
        return distinguishingFieldsArray;
    };
    
    //add key/vals of o2 to o1 and return o1; (top level key-value only, o2 values maintained over o1)
    /** @private */
    function addTo(o1, o2) {
        for(var k in o2) {
            o1[k] = o2[k];
        }
    }

    
};  

})();

/**
 * @param {object} config
 * @param {Voyant.panel.TermsRadio} config.parent
 * @param {Ext.dom.Element} config.container
 * @param {boolean} config.showSlider
 */
function TermsRadio(config) {
	this.parent = config.parent;
	this.container = config.container;
	this.isSliderVisible = config.showSlider == undefined ? true : config.showSlider;
	
	this.chart = null;
	
	this.absMaxFreq = 0;
	this.absMinFreq = 0;
	this.allData = [];
	
	this.continueTransition = true;
	this.counterSeries = [];
	this.displayData = [];
	this.dragged = false;
//	this.intervalIdArray = [];
	this.isTransitioning = false;
	this.lastSlippery = null;
	this.lastSticky = null;
	this.maxFont = 30;
	this.minFreq = 0;
	this.numDataPoints = 0;
	this.numVisPoints = 5;
	this.overlayQueue = [];
	this.records = 0;
	this.recordsLength = 0;
	this.reselectTop = false;
	this.shiftCount = 0;
	this.sliderDragSum = 0;
	this.titlesArray = [];
	this.transitionCall = 'draw'; //possible calls 'draw', 'redraw', 'left', and 'right'
	this.valFraction = 1;
	this.win = 0;
	
	//window padding dimensions, b - bottom, l - left, r - right, t - top
	this.bPadding = 25;
	this.lPadding = 40;
	this.rPadding = 20;
	this.tPadding = 10;
	
	this.sliderHeightRatio = 0.1; // slider/container height ratio
	this.sliderHeight = 0; // set in init and resize
	this.sliderBPadding = 10;
	
	//tracks largest dimensions, used in resizing
	this.largestW = 0;
	this.largestH = 0;
	
	this.xAxisEl = undefined;
	this.xAxis = d3.axisBottom();
	this.xScale = d3.scaleLinear();
	this.xSliderScale = d3.scaleLinear();
	
	this.yAxisEl = undefined;
	this.yAxis = d3.axisLeft();
	this.yScale = d3.scaleLinear();
	this.ySliderScale = d3.scaleLinear();
	
	this.fontScale = d3.scaleLinear();
	this.opacityScale = d3.scaleLinear();
	
	this.container.on('resize', this.doResize, this);
}

TermsRadio.prototype = {
	constructor: TermsRadio
	
	,loadRecords: function(records) {
		if (records.length > 0) {
			this.initData(records);
			this.prepareData();
			//for shiftcount > 0 exclusively
			var len = this.shiftCount;
			while(len-- > 0){
			//for(var j = 0; j < this.shiftCount; j++){
				this.displayData.shift();
			}
		}
		if (this.chart != null) {
			this.redraw();
		} else {
			this.initializeChart();
		}
	}

	,highlightQuery: function(query, sticky) {
		var docId = null;
		if (this.parent.getApiParam("mode") === 'document') {
			docId = this.parent.getCorpus().getDocument(0).getId();
		}
		var info = {wordString : query, docId : docId};
		var paramsBundle = this.buildParamsBundle(info);
		if (sticky) {
			this.manageOverlaySticky(paramsBundle);
		} else {
			this.manageOverlaySlippery(paramsBundle);
		}
	}
	
	,highlightRecord: function(record, sticky) {
		var info = {wordString : record.get('term'), docId : record.get('docId')};
		var paramsBundle = this.buildParamsBundle(info);
		if (sticky) {
			this.manageOverlaySticky(paramsBundle);
		} else {
			this.manageOverlaySlippery(paramsBundle);
		}
	}
	
	//
	//DATA FUNCTIONS
	//	

	,initData: function (records) { 	
		//console.log("fn: initData")
		//console.profile('profilethis')
		this.records = records;
		
		this.recordsLength = this.records.length;
	
		this.numVisPoints = parseInt(this.parent.getApiParam('visibleBins'));
		this.shiftCount = parseInt(this.parent.getApiParam('position'));
		
		if(this.parent.getApiParam('mode') === 'document') {
			this.numDataPoints = this.records[0].get('distributions').length;
			var parentBins = parseInt(this.parent.getApiParam('bins'));
			if(this.numDataPoints !== parentBins){
				this.numDataPoints = parentBins;
				this.loadStore();
			}
		} else {
			this.numDataPoints = this.records[0].get('distributions').length;
		}
		
    	this.counterSeries = [];
    	var transferArray = [];
			
    	//find max frequency value
    	this.absMaxFreq = 0;
		for( var k = 0; k < this.numDataPoints; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	if(this.records[p].get('distributions')[k] > this.absMaxFreq) {
	        		this.absMaxFreq = this.records[p].get('distributions')[k];
	        	}
	        }
		}
			    
		//find the absolute minimum frequency value
		//first start by setting the minimum frequency to the maximum frequency
		this.absMinFreq = this.absMaxFreq;
		for( var k = 0; k < this.numDataPoints; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	if(this.records[p].get('distributions')[k] <= this.absMinFreq && this.records[p].get('distributions')[k] !== 0) { 
	        		this.absMinFreq = this.records[p].get('distributions')[k];
	        	}
	        }
		}
		
		//Calculate the lower value of the y axis, must be > 0 
		if( this.absMinFreq < 0) {
			this.absMinFreq = 0;
		}
		
		this.minFreq = this.absMinFreq * 1.01;
		
	    //transfer all of the relevant data from 'records' to an array 'allData'
		for( var k = 0; k < this.numDataPoints; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	var rec = this.records[p];
	        	var dists = rec.get('distributions')[k];
//	        	if (dists > this.minFreq && dists <= this.absMaxFreq) {
	        	if (dists > 0) {
	        		transferArray.push({
	        			freq: dists,
		                wordString: rec.get('term'),
		                counter: k,
		                posInSeries: 0, 
		                numInSeries: 0,
		                docId: rec.get('docId')
		            });
	        	}
//	        	} else { //do nothing
//	        	}
	        }
	        this.counterSeries.push(transferArray);
	        transferArray = [];
	    }
	}

	,prepareData: function() {
		//console.log("fn: prepareData")
	    var frequencySeries = [],
	    	copy1 = [],
	    	copy2 = [],
	    	copy3 = [],
	    	copy4 = [],
	    	check = 0;
		
		this.allData = [];
		this.displayData = [];
		
		//set the number of points to be displayed at once
		if(this.numDataPoints < this.numVisPoints) {
			this.numVisPoints = this.numDataPoints;
		}
		
		//adjust shiftCount if it for some reason is out of the normal range
		if(this.shiftCount + this.numVisPoints > this.numDataPoints){ 
			this.shiftCount = this.numDataPoints - this.numVisPoints; 
		}
		
	    for( var k = 0; k < this.numDataPoints; k++ ) {
			var check1 = 0; //add a single first data point
	    	for(var p = 0; p < this.counterSeries[k].length; p++ ) {
	    			
    			var check2 = 0; //check will make sure a data point is not added to a series more than once
    			
	    		//add very first point, this is done like this so the for loop can use the .length operator
	    		if(check1 === 0){
			    	copy1.push(this.counterSeries[k][p]);
			    	copy2.push({freq: this.counterSeries[k][p].freq,
		    			frequencyArray: copy1,
		    			numInSeries: 0
		    		});
		    		frequencySeries.push(copy2);
		    		
		    		copy1 = [];
		    		copy2 = [];
		    		check1 = 1;
		    		check2 = 1;
	    		}
	    		
	    		//checks if a given frequency has an existing 'series' that the data point can be grouped into
	    		for( var l = 0; l < frequencySeries[k].length && check2 === 0; l++) {
					if(this.counterSeries[k][p].freq === frequencySeries[k][l].freq) {
						var inSeries = 0; 
						inSeries = frequencySeries[k][l].numInSeries;
						this.counterSeries[k][p].posInSeries = ++inSeries;
						frequencySeries[k][l].numInSeries = inSeries;
						frequencySeries[k][l].frequencyArray.push(this.counterSeries[k][p]);
						check2 = 1;
					}	
	    		}
	    		
	    		//if there is no existing series then create a new one
	    		if(check2 === 0) {
					copy4.push(this.counterSeries[k][p]);
		    		frequencySeries[k].push({freq: this.counterSeries[k][p].freq,
		    			frequencyArray: copy4,
		    			numInSeries: 0
		    		});
		    		copy4 = [];
		    		check2 = 1;
				}
	    	}	
	    	//if counterSeries[k] is empty add or there is no eligible value add an empty array to frequencySeries such that frequencySeries[k] is not undefined
	    	if(this.counterSeries[k].length < 1 || check1 === 0) {  
	    		frequencySeries.push([]);
    		}
	    }
	    
	    for( var k = 0; k < this.numDataPoints; k++ ) {
	    	for( var p = 0; p < frequencySeries[k].length; p++) {
	    		++frequencySeries[k][p].numInSeries;
	    		for( var l = 0; l < frequencySeries[k][p].frequencyArray.length; l++) {
	    			frequencySeries[k][p].frequencyArray[l].numInSeries = frequencySeries[k][p].numInSeries;
	    		}
	    	}
	    }
	    
	    var allDataSetup = [];
	    
	    //add the selected points into the array that will be used to display the data
	    for( var k = 0; k < this.numDataPoints; k++ ) {
	        this.allData.push({allDataInternal: frequencySeries[k],
	            outerCounter: k});
	    }
	    
    	var displaySetup = [],
    		transferArray = [];
		
	    //transfer the first x points (= numVisPoints, the number of points to be visualized)
	    //into an array that will be used to display the data
	    for( var k = 0; k < this.numVisPoints + this.shiftCount; k++ ) { 
	        for( var p = 0; p < this.recordsLength; p++ ) {
	        	if(this.allData[k].allDataInternal[p]) {
		            transferArray.push({freq: this.allData[k].allDataInternal[p].freq,
		                inSeries: this.allData[k].allDataInternal[p].numInSeries,
		                frequencyArray: this.allData[k].allDataInternal[p].frequencyArray,
		                dotObject: [{counter: k, freq: this.allData[k].allDataInternal[p].freq}]
		            });
	        	}
	        }
	        displaySetup.push(transferArray);
	        transferArray = [];
	    }
	    
	    //add the selected points into the array that will be used to display the data
	    for( var k = 0; k < this.numVisPoints + this.shiftCount; k++ ) {
	        this.displayData.push({displayInternal: displaySetup[k],
	            outerCounter: k});
	    }
	    displaySetup = [];
	}
	
	//TRANSITION FUNCTIONS
	
	//disable forward back if moving, disable pause if stopped, disable back if at beginning
	,manageMvtButtons: function () {
		//console.log('fn: manageMvtButtons')
		this.parent.queryById("play").setPlaying(this.isTransitioning);
		/*
		if(this.isTransitioning === true) {
			this.toggleRight.setDisabled(true);
			this.toggleLeft.setDisabled(true);
			this.stop.setDisabled(false);
		}
		if(this.isTransitioning === false) {
			this.toggleRight.setDisabled(false);
			this.toggleLeft.setDisabled(false);
			this.stop.setDisabled(true);
			
			if(this.shiftCount === 0){
				this.toggleLeft.setDisabled(true);
			} else {
				this.toggleLeft.setDisabled(false);
			}
			
			if(this.shiftCount + this.numVisPoints === this.numDataPoints){
				this.toggleRight.setDisabled(true);
			} else {
				this.toggleRight.setDisabled(false);
			}
		}	
		*/
	}

	//provides the next value to the left     
    ,nextR: function () {
    	//console.log('fn: nextR')
    	
    	var displaySetup = [];
    	//this.displayData.shift();
		
    	for( var p = 0; p < this.recordsLength; p++ ) {
    		if(this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p]) {
	            displaySetup.push({freq: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].freq,
	            	inSeries: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].numInSeries,
	            	frequencyArray: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].frequencyArray,
	                dotObject: [{counter: this.numVisPoints + this.shiftCount, freq: this.allData[this.numVisPoints + this.shiftCount].allDataInternal[p].freq}]
	            });
    		}
        }
        
	    this.displayData.push({displayInternal: displaySetup, outerCounter: this.numVisPoints + this.shiftCount});
	    displaySetup = [];
    }
    
    //verifies that data CAN be moved to the right
    ,toggleRightCheck: function () {
    	//console.log("fn: toggleRightCheck")
    	if(this.numVisPoints + this.shiftCount < this.numDataPoints) {
    		//manage transition movements and controls
    		this.isTransitioning = true;
    		this.continueTransition = true;
    		this.manageMvtButtons();
    		
    		//draw
	        this.nextR();
			this.shiftCount = ++this.shiftCount;
			this.manageXScale();
			this.parent.setApiParams({position: this.shiftCount});
			this.transitionCall = 'right';
			this.animateVis();
			this.displayData.shift();
		} else {
    		//manage transition movements and controls
			this.isTransitioning = false;
			this.continueTransition = false;
			this.manageMvtButtons();
		}
    }
    
    //provide the next value
    ,nextL: function () {
    	//console.log('fn: nextLeft')
    	var displaySetup = [];
        
        for( var p = 0; p < this.recordsLength; p++ ) {
        	if(this.allData[this.shiftCount].allDataInternal[p]) {
        		displaySetup.push({freq: this.allData[this.shiftCount].allDataInternal[p].freq,
	            	inSeries: this.allData[this.shiftCount].allDataInternal[p].numInSeries,
	            	frequencyArray: this.allData[this.shiftCount].allDataInternal[p].frequencyArray,
	                dotObject: [{counter: this.shiftCount, freq: this.allData[this.shiftCount].allDataInternal[p].freq}]
	            });
        	}
        }
	    this.displayData.unshift({displayInternal: displaySetup, outerCounter: this.shiftCount});
        displaySetup = [];
    }
    
    /*
    ,toggleLeftCheck: function () {    	
    	//console.log("fn: toggleLeftCheck")
    	if(this.shiftCount > 0) {
    		//manage transition movement and controls
    		this.isTransitioning = true;
			this.continueTransition = true;
			this.manageMvtButtons();
			
			//draw
			this.shiftCount = --this.shiftCount;
			this.manageXScale();
			this.parent.setApiParams({position: this.shiftCount});
	        this.nextL();
			this.transitionCall = 'left';
	        this.animateVis();
	        this.displayData.pop();
		} else {
			//manage transition movements and controls
			this.isTransitioning = false;
			this.manageMvtButtons();
		}
    }
    */
    
    ,startScroll: function() {
    	//console.log("fn: startScroll")
    	var me = this;
    	
    	if(me.numDataPoints > me.numVisPoints && me.shiftCount === 0){
			//manage transition movements and controls
			me.isTransitioning = true;
			this.manageMvtButtons();
    		
    		//repeat transition
			setTimeout(function(){
				me.toggleRightCheck();
			},3000);
		}
    }
    
    //
    //DISPLAY FUNCTIONS
    //
	
	
	// init and draw everything
	,initializeChart: function() {
		this.initChart();
		
		this.drawXAxis();
		this.drawYAxis();
		this.drawChart();
		if (this.isSliderVisible) {
			this.drawSlider();
			this.drawVerticalSlider();
			this.redrawSliderOverlay();
		}
		this.transitionCall = 'draw';
	}
	
    ,redraw: function() {

//    	console.log("fn: redraw")
    	this.transitionCall = 'redraw';
    	this.updateFullPath();
		this.redrawXAxis();
		this.redrawYAxis();
		this.redrawChart();
		if (this.isSliderVisible) {
			this.redrawSlider();
			this.redrawVerticalSlider();
			this.redrawSliderOverlay();
		}
		this.redrawChartOverlay();
    }
    
	,initChart: function () {
		var h = this.container.getHeight(),
			w = this.container.getWidth();
    
		//create main SVG Element
		var chartSVG = Ext.DomHelper.append(this.container.down('div[class$=innerCt]'), '<svg class="chart" width="'+w+'" height="'+h+'"></svg>');
	    this.chart = d3.select(chartSVG);
	    
	    this.setSliderHeight();
	    
		this.largestW = w;
		this.largestH = h - this.getSliderHeight();
		
		var y = this.tPadding + this.getSliderHeight();
	    	    
	    this.chart.append('clipPath')
	        .attr('id', 'clip1')
	      .append('rect')
	      	.attr('class', 'clipping-rectangle')
	        .attr("x", 0)
	        .attr("y", y)
	        .attr("width", w)
	        .attr("height", this.largestH);
	    
	    this.chart.append('g')
	    	.attr('class','overlay')
	    	.attr("clip-path", "url(#clip1)");
	    
		//depending on the size of display set the length that labels can be
		this.setTitleLength();
	}
    
	,doResize: function() {
		if(this.chart) {
			var h = this.container.getHeight(),
				w = this.container.getWidth();

			this.setSliderHeight();
			
			this.largestH = h - this.getSliderHeight();
			this.largestW = w;
			
			this.chart.attr('height', h)
				.attr('width', w);
				
			this.setTitleLength();
			
			this.chart.select('rect[class=clipping-rectangle]')
		        .attr("x", 0)
		        .attr("y", this.tPadding + this.getSliderHeight())
		        .attr("width", w)
		        .attr("height", this.largestH);
		
			this.redraw();
		}
	}
	
    ,drawXAxis: function() {
    	var me = this;
    	//svg element constants
		var h = this.container.getHeight(),
			w = this.container.getWidth();
    	
		//initialize x scales
		this.manageAllXScales();
			
    	//define X axis
		this.xAxis = d3.axisBottom(me.xScale)
		    .ticks(Math.round(me.numVisPoints))
		    .tickFormat(function(d){
		    	var val;
		    	if(me.parent.getApiParam('mode') === 'document') { 
					val = 'Segment ' + (parseInt(d) + 1);
				}
				if(me.parent.getApiParam('mode') === 'corpus') {
					val = d + 1 + '. ' + me.titlesArray[d];
				}
				return val;
		    });
		
		//draw the x-axis
		this.xAxisEl = this.chart.append('g')
    		.attr('class', 'axisX')
    		.attr('transform', 'translate(0,' + (h - this.bPadding) + ')')
    		.call(this.xAxis);
    	
//    	this.xAxisEl.selectAll('text')
//			.on('mouseover', function () {
//				d3.select(this)
//					.attr('fill', 'red')
//					.style("font-size", '18px');
//			})
//			.on('mouseout', function () {
//				d3.select(this)
//					.attr('fill', 'black')
//					.style("font-size", '11px');
//			});
		this.styleXAxis();
    }
    
    ,styleXAxis: function() {
    	this.xAxisEl.selectAll('text')
	        .style('font-family', 'sans-serif')
	        .style('font-size', '11px');

	    this.xAxisEl.selectAll('line')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges');
	        
	    this.xAxisEl.selectAll('path')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges');
    }
    
    ,redrawXAxis: function() {
    	this.chart.selectAll('g[class=axisX]')
			.remove();
		
		this.drawXAxis();
    }
    
    ,drawYAxis: function() {
    	var me = this;
    	
    	//svg element constants
		var h = this.container.getHeight(),
			w = this.container.getWidth();
		
		//initialize Y scales
		this.manageAllYScales();
    	
    	var yTicksScale = d3.scaleLinear()
			.domain([200,700])
			.range([5,15]);
			
		var numberFormat = d3.format(".2r");
		function logFormat(d) {
			var x = Math.log(d) / Math.log(10) + 1e-6;
			return Math.abs(x - Math.floor(x)) < 0.7 ? numberFormat(d) : "";
		} 
		
		this.yAxis = d3.axisLeft(me.yScale)
	    	.ticks(yTicksScale(h))
	    	.tickFormat(logFormat)
			.tickSize(-w + this.rPadding + this.lPadding);
		
		//draw the y-axis
		this.yAxisEl = this.chart.append('g')
	    	.attr('class', 'axisY')
	    	.attr('transform', 'translate(' + this.lPadding + ',0)')
	    	.call(this.yAxis);
		
	    this.yAxisEl.selectAll('text')
	        .style('font-family', 'sans-serif')
	        .style('font-size', '11px');
	    
	    //controls horizontal grid line-opacity
	    this.yAxisEl.selectAll('line')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges')
	        .style('stroke-opacity', 0.05);
	        
	    this.yAxisEl.selectAll('path')
	        .style('fill','none')
	        .style('stroke','black')
	        .style('shape-rendering', 'crispEdges');
    }
    
    ,redrawYAxis: function() {
    	this.chart.selectAll('g[class=axisY]')
			.remove();
		
		this.drawYAxis();
    }
    
    ,drawChart: function() {
    	var me = this;
    	
    	//create graph text
	    //attach the nested data to svg:g elements
		var counterSeriesDiv = this.chart.selectAll('g[class=section]')
	        .data(me.displayData, function(d) { return d.outerCounter; })
	      .enter().append('g')
	        .attr('class', 'section')
	        .attr("clip-path", "url(#clip1)");
		
		var frequencySeriesDiv = counterSeriesDiv.selectAll('g')
			.data(function(d) { return d.displayInternal; })
	      .enter().append('g')
	        .attr('class', 'frequencies')
	        .on('mouseover', function() {
				d3.select(this).style('fill', 'red');
			})
			.on('mouseout', function() {
	            d3.select(this).style('fill', 'black');
			});
	             
        //attach the frequency data to data points 
		var dataPoint = frequencySeriesDiv.selectAll('text')
    		.data(function(d) { return d.frequencyArray; })
		  .enter().append('text')
	        .attr('class', function(d) {
	        	return me.getSelectorFromTerm(d.wordString);
	        })
	    	.attr('x', function (d) {
	    		var startPoint = (0.5 / d.numInSeries) - 0.5
					,valueRange = (d.posInSeries / d.numInSeries * 0.8)
					,x = d.counter + me.callOffset() + startPoint + valueRange; 
				return me.xScale(x);
			})
	    	.attr('y', function (d) { 
				var y = d.freq;
				return me.yScale(y);
	    	})
	    	.attr('text-anchor', 'middle')
	    	.attr('transform', function (d) {
	    		var startPoint = (0.5 / d.numInSeries) - 0.5
					,valueRange = (d.posInSeries / d.numInSeries * 0.8)
					,x = d.counter + me.callOffset() + startPoint + valueRange
					,y = d.freq;
	    		return 'translate(0, 0) rotate(-20 ' + me.xScale(x) + ' '+ me.yScale(y) + ')';
	    	})
	    	.style('font-size', function(d) { return me.fontScale(d.freq) + 'px'; })
	    	.style('fill-opacity', function(d) { return me.opacityScale(d.freq); })
	        .text(function(d) { return d.wordString; })
	        .on('mouseover', function(d) { 
	 	        d3.select(this).style('cursor', 'pointer').style('font-size', function(d) { return (me.fontScale(d.freq) * me.maxFont / me.fontScale(d.freq)) + 'px'; });
	 	        var paramsBundle = me.buildParamsBundle(d);
	 	        me.manageOverlaySlippery(paramsBundle);
	        })
	        .on('mouseout', function(d) { 
	        	d3.select(this).style('cursor', 'auto').style('font-size', function(d) { return me.fontScale(d.freq) + 'px'; });
	        	var paramsBundle = me.buildParamsBundle(d);
	        	me.manageOverlaySlippery(paramsBundle);
	        })
	        .on('click', function(d) {
	        	var paramsBundle = me.buildParamsBundle(d);
	        	me.manageOverlaySticky(paramsBundle);
			})
	  	  .append('title')
	    	.text(function(d) { return d.wordString; });
    }
    
    ,redrawChart: function() {
    	this.chart.selectAll('g[class=section]')
			.remove();
			
		this.drawChart();
    }
    
    ,drawVerticalSlider: function() {
//    	var h = this.container.getHeight(),
//			w = this.container.getWidth();
//    	
//    	var totalTopOffset = (this.tPadding * 2) + this.sliderHeight
//        	,lengthVer = h - (totalTopOffset + this.bPadding);
//        
//	    //create vertical minimap rectangle and slider
//	    var sliderPosScale = d3.scaleLinear()
//			.domain([this.absMaxFreq, this.minFreq])
//			.range([totalTopOffset, lengthVer]);
//	    
//	    var rectVer = this.chart.append('rect')
//	  	    .attr('class', 'minimap')
//	  	    .attr('x', w - (this.rPadding * 0.66))
//	  	    .attr('y', totalTopOffset)
//	  	    .attr('rx', 3.33)
//	  	    .attr('width', 6.66)
//	  	    .attr('height', lengthVer)
//	  	    .style('fill','aliceblue')
//	  	    .style('stroke','black')
//	  	    .style('stroke-width','1')
//	  	    .style('fill-opacity','0.75');
//	    	
//	    var sliderVer = this.chart.append('rect')
//			.attr('class', 'minimap')
//	  	    .attr('x', w - (this.rPadding * 0.66))
//	  	    .attr('y', totalTopOffset)
//	  	    .attr('rx', 3.33)
//	  	    .attr('width', 6.66)
//	  	    .attr('height', lengthVer * ((this.absMaxFreq * this.valFraction) - this.minFreq) / this.absMaxFreq)
//	  	    .style('fill','CornflowerBlue')
//	  	    .style('stroke','black')
//	  	    .style('stroke-width','1');
    }
    
    ,redrawVerticalSlider: function() {
    	this.chart.selectAll('rect[class=minimap]')
			.remove();
			
		this.drawVerticalSlider();
    }
    
    ,drawSlider: function() {
    	var h = this.container.getHeight(),
			w = this.container.getWidth();
	    
		//Create navigation bar
		var lengthHor = w - (this.rPadding + this.lPadding)
			,offsetVis = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / 2) * ( 1 / (this.numDataPoints - 1)))
			,offsetVisStart = this.lPadding
			,offsetVisEnd = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / (this.numDataPoints - 1)));
		
		var lineX = this.chart.append('line')
			.attr('class', 'slider axis')
			.attr('x1', this.lPadding)
			.attr('x2', this.container.getWidth() - this.rPadding)
			.attr('y1', this.tPadding + this.sliderHeight)
			.attr('y2', this.tPadding + this.sliderHeight)
			.style('shape-rendering', 'crispEdges')
			.style('stroke','black')
	  	    .style('stroke-width','1');
					
		var lineY = this.chart.append('line')
			.attr('class', 'slider axis')
			.attr('x1', this.lPadding)
			.attr('x2', this.lPadding)
			.attr('y1', this.tPadding + this.sliderHeight)
			.attr('y2', this.tPadding)
			.style('shape-rendering', 'crispEdges')
			.style('stroke','black')
	  	    .style('stroke-width','1');
		
	    var sliderHorStart = this.chart.append('line')
	  	    .attr('class', 'slider')
	  	    .attr('id', 'before')
	  	    .attr('x1', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisStart)
	  	    .attr('x2', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisStart)
	  	    .attr('y1', this.tPadding + this.sliderHeight)
	  	    .attr('y2', this.tPadding)
	  	    .style('stroke', 'black')
	  	    .style('stroke-width', '1');
	    
	    var sliderHorEnd = this.chart.append('line')
	  	    .attr('class', 'slider')
	  	    .attr('id', 'after')
	  	    .attr('x1', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisEnd)
	  	    .attr('x2', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisEnd)
	  	    .attr('y1', this.tPadding + this.sliderHeight)
	  	    .attr('y2', this.tPadding)
	  	    .style('stroke', 'black')
	  	    .style('stroke-width', '1');
	  	    	  	    
	   var greyBoxBefore = this.chart.append('rect')
  	    	.attr('class', 'slider')
  	    	.attr('id', 'boxBefore')
  	    	.attr('x', this.lPadding)
  	    	.attr('y', this.tPadding)
  	    	.attr('height', this.sliderHeight)
  	    	.attr('width', lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1))
  	    	.style('fill', 'silver')
  	    	.style('fill-opacity', 0.25)
	    	.style('cursor', 'move');
	    		    
	    var greyBoxAfter = this.chart.append('rect')
	    	.attr('class', 'slider')
	    	.attr('id', 'boxAfter')
	    	.attr('x', (lengthHor * (this.shiftCount - this.callOffset()) / (this.numDataPoints - 1)) + offsetVisEnd)
	    	.attr('y', this.tPadding)
	    	.attr('height', this.sliderHeight)
	    	.attr('width', lengthHor * (this.numDataPoints - this.numVisPoints - this.shiftCount + this.callOffset()) / (this.numDataPoints - 1))
	    	.style('fill', 'silver')
	    	.style('fill-opacity', 0.25)
	    	.style('cursor', 'move');
	    
	    var me = this;
    	var drag = d3.drag()
        .on('drag', function(d) {
        	if(!me.isTransitioning) {
        		this.drag = true;
        		
	        	var w = me.parent.getWidth()
	        		,displaceX = parseInt(d3.event.dx)
	        		,checkBefore
	        		,checkAfter
	        		,pos = 0;
	        		
	        	//add up the slider movements as they occur	
        		me.sliderDragSum += d3.event.dx;
	        	
	        	me.chart.selectAll('#before')
	        		.attr('x1', function () { 
	        			checkBefore = parseInt(this.getAttribute('x1'));
	        			pos = parseInt(this.getAttribute('x1')) + displaceX;
	        			return parseInt(this.getAttribute('x1'));
	        		});
	        	
	        	me.chart.selectAll('#after')
	        		.attr('x1', function () { 
	        			checkAfter = parseInt(this.getAttribute('x1'));
	        			return parseInt(this.getAttribute('x1'));
	        		});
	        	
	        	if(checkBefore + displaceX < me.lPadding || checkAfter + displaceX > w - me.rPadding) {
	        		displaceX = 0;
	        	}
	        	
	        	me.chart.select('#boxBefore')
	        		.attr('width', function () { return parseInt(this.getAttribute('width')) + displaceX; });
	        	
	        	me.chart.select('#boxAfter')
	        		.attr('x', function () { return parseInt(this.getAttribute('x')) + displaceX; })
        			.attr('width', function () { return Math.max(0, parseInt(this.getAttribute('width')) - displaceX); });
	        		
	        	me.chart.selectAll('#before')
	        		.attr('x1', function () { return parseInt(this.getAttribute('x1')) + displaceX; })
	        		.attr('x2', function () { return parseInt(this.getAttribute('x2')) + displaceX; });
	        	
	        	me.chart.selectAll('#after')
        			.attr('x1', function () { return parseInt(this.getAttribute('x1')) + displaceX; })
        			.attr('x2', function () { return parseInt(this.getAttribute('x2')) + displaceX; });
        	}
        })
        .on('end', function(d) {
        	if(this.drag){
        		this.drag = false;
        		
        		var inverseSliderScale = d3.scaleLinear()
			    	.domain([0, me.container.getWidth() - (me.lPadding + me.rPadding)])
			    	.range([0, me.numDataPoints]);
			    	
				//calculate the position that everything should transition to
	        	var moveByThis = inverseSliderScale(me.sliderDragSum),
	        		moveShiftCount,
	        		oldShiftCount = me.shiftCount;
	        		
	    		if(moveByThis > 0) moveShiftCount = Math.floor(moveByThis);
	    		if(moveByThis < 0) moveShiftCount = Math.ceil(moveByThis);
	    		
	    		//update shiftCount re-animate 
	    		me.shiftCount += moveShiftCount;
	    		if(me.shiftCount < 0) me.shiftCount = 0;
	    		if(me.shiftCount > me.numDataPoints - 1) me.shiftCount = me.numDataPoints - 1;
	    		
	    		if(me.shiftCount !== oldShiftCount) {
	    			me.sliderDragSum = 0;
	    			
	        		me.parent.setApiParams({position: me.shiftCount});
					me.prepareData();
					
					me.redraw();
	        	}
        	}
        });
	    
	    greyBoxBefore.call(drag);
	    greyBoxAfter.call(drag);
    }
    
    ,removeSlider: function(removeTermLines) {
    	this.chart.selectAll('rect[class=slider]')
    		.remove();
	
    	this.chart.selectAll('line[class~=slider]')
	    	.remove();
    	
    	if (removeTermLines) {
    		this.chart.selectAll('g[class=slider]')
	    		.remove();
    	}
    }
    
    ,redrawSlider: function() {
    	this.removeSlider();
    	this.drawSlider();
    }
	
	,animateVis: function() {
		var me = this;
		
		//prepare the data for the visualization
		//shiftCount = 0, means the displayData begins with the same value as nestedData
		var mode = this.parent.getApiParam('mode');
		
	    //svg element constants
		var h = this.container.getHeight(),
			w = this.container.getWidth();

		var duration = this.getDuration();
		
		//if transitionCall === 'draw': draw the function for the first time		
		//if not: shift displayData to a different subset of allData
		//then display the newly shifted data	
		if(this.transitionCall === 'left' || this.transitionCall ==='right'){
			this.xAxisEl.transition()
	            .duration(duration)
	            .ease(d3.easeLinear)
	            .call(this.xAxis);
	            
	        this.styleXAxis();
	        
	        this.drawChart();
	    
        	//if call is shift move the dataPoints	
        	this.chart.selectAll('.frequencies').transition()
        		.duration(duration)
	            .ease(d3.easeLinear)
	            .selectAll('text')
	            .attr('x', function (d) {
	            	var startPoint = (0.5 / d.numInSeries) - 0.5,
						valueRange = (d.posInSeries / d.numInSeries * 0.8),
						x = d.counter + startPoint + valueRange; 
					return me.xScale(x);
				})
				.attr('transform', function (d) {
		    		var startPoint = (0.5 / d.numInSeries) - 0.5
						,valueRange = (d.posInSeries / d.numInSeries * 0.8)
						,x = d.counter + startPoint + valueRange
						,y = d.freq;
		    		return 'translate(0, 0) rotate(-20 ' + me.xScale(x) + ' '+ me.yScale(y) + ')';
				});
	    	   
        	//Create navigation bar
			var lengthHor = w - (this.rPadding + this.lPadding)
				,offsetVis = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / 2) * ( 1 / (this.numDataPoints - 1)))
				,offsetVisStart = this.lPadding
				,offsetVisEnd = this.lPadding + (lengthHor * ((this.numVisPoints - 1) / (this.numDataPoints - 1)));
				
        	this.chart.select('#before').transition()
				.duration(duration)
				.ease(d3.easeLinear)
			 	.attr('x1', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisStart)
			 	.attr('x2', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisStart)
		  	    .attr('y1', this.tPadding + this.getSliderHeight())
		  	    .attr('y2', this.tPadding)
		  	    .on('end', function () {
		  	    	if (me.parent.isMasked()) {
		  	    		me.parent.unmask();
		  	    	}
		  	    	if(me.continueTransition) { 
		  	    		setTimeout(function () {
		  	    			me.callTransition();
		  	    		},50); 
		  	    	} else { 
		  	    		//manage transition movements and controls
		  	    		me.isTransitioning = false;
		  				me.manageMvtButtons();
		  	    	}
		  	    });
        	
	  	   this.chart.select('#after').transition()
				.duration(duration)
				.ease(d3.easeLinear)
			 	.attr('x1', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisEnd)
			 	.attr('x2', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisEnd)
		  	    .attr('y1', this.tPadding + this.getSliderHeight())
		  	    .attr('y2', this.tPadding);
		    
	  	   this.chart.select('#boxBefore').transition()
				.duration(duration)
				.ease(d3.easeLinear)
	  	    	.attr('x', this.lPadding)
	  	    	.attr('y', this.tPadding)
	  	    	.attr('height', this.getSliderHeight())
	  	    	.attr('width', lengthHor * (this.shiftCount) / (this.numDataPoints - 1));
	    
	  	    this.chart.select('#boxAfter').transition()
				.duration(duration)
				.ease(d3.easeLinear)
	  	    	.attr('x', (lengthHor * this.shiftCount / (this.numDataPoints - 1)) + offsetVisEnd)
	  	    	.attr('y', this.tPadding)
	  	    	.attr('height', this.getSliderHeight())
	  	    	.attr('width', lengthHor * (this.numDataPoints - this.numVisPoints - this.shiftCount) / (this.numDataPoints - 1));
        }
        
        //animates the chart overlay
		this.redrawChartOverlay();
	}
	
	,callTransition: function () {
		if(this.transitionCall === 'left') this.toggleLeftCheck();
        if(this.transitionCall === 'right') this.toggleRightCheck();
	}
		
	//build the params bundle to pass to manageOverlaySticky
	,buildParamsBundle: function (info) { 
		//console.log('fn: builParamsBundle')
		var type = info.wordString,
			params = {},
			paramsBundle = {},
			docId;

		if ( this.parent.getApiParam('mode') === 'document') { // set position
			docId = info.docId;
			var totalTokens = this.parent.getCorpus().getDocument(docId).getLexicalTokensCount() - 1;
			params.tokenIdStart = parseInt(totalTokens / this.numDataPoints);
			params.docIdType = docId + ':' + type;
		} else {
		}
				
		paramsBundle = { params: params, type: type };
		
		return paramsBundle;
	}
	
	,manageOverlaySlippery: function (paramsBundle) {

		//console.log('fn: manageOverlaySlippery')
		var string = paramsBundle.type
			,selector = this.getSelectorFromTerm(paramsBundle.type) 
			,checkOn = 'on'
			,index;
		
//		this.continueTransition = true;
//
//		this.transitionCall = 'draw';
		
		//check if the word that was selected was already sticky
		//if so checkOn = off and nothing happens
		var len = this.overlayQueue.length;
		while(--len >= 0){
			if(selector === this.overlayQueue[len].selector){ 
		    	checkOn = 'off';
		    	index = len;
			}
		}
		
		//make sure the selected word wasn't just a sticky word that is being deselected
		//thus happens to be scrolled over
		if(selector === this.lastSticky){
			checkOn = 'off';
			this.lastSticky = null;
		}
		
		if(checkOn === 'on') {
			//select a slippery word
			if(selector !== this.lastSlippery) {
				var pathHolder = this.prepareFullPath(string);
				var lineObject = {
					word: string, 
					selector: selector, 
					params: paramsBundle, 
					fullPath: pathHolder.path,
					pathMin: pathHolder.min,
					pathMax: pathHolder.max,
					colour: 'red'
				};	
				if(this.lastSlippery !== null) {
					//exceptional case where lastSlippery was not properly removed
					this.chartOverlayOff(this.lastSlippery);
					if (this.isSliderVisible) {
						this.sliderOverlayOff(this.lastSlippery);
					}
					this.lastSlippery = null;
					
					//select new slippery word
					//change its colour
					this.chartOverlayOn(lineObject);
					if (this.isSliderVisible) {
						this.sliderOverlayOn(lineObject);
					}
					this.lastSlippery = selector;
				}
				else {
					//normal case select slippery word
					//change its colour
					this.chartOverlayOn(lineObject);
					if (this.isSliderVisible) {
						this.sliderOverlayOn(lineObject);
					}
					this.lastSlippery = selector;
				}
			}
			else{
				//normal case deselect a slippery word
				this.chartOverlayOff(selector);
				if (this.isSliderVisible) {
					this.sliderOverlayOff(this.lastSlippery);
				}
				this.lastSlippery = null;
			}
		}
		else {
			//else do nothing 
			//this means, don't select a word that is already sticky
		}
	}

	,manageOverlaySticky: function (paramsBundle) {
//		console.log('fn: manageOverlaySticky')
		var me = this;
		
		var term = paramsBundle.type;
		
		this.transitionCall = 'draw';
		
		if (!this.isTermSelected(term)) {
			this.doTermSelect(term, true);
		} else {
			this.doTermDeselect(term, true);
		}
	},
	
	getTermIndex: function(term) {
		var index = -1;
		var selector = this.getSelectorFromTerm(term);
		var len = this.overlayQueue.length;
		while(--len >= 0){
			if(selector === this.overlayQueue[len].selector){ 
				index = len;
			}
		}
		return index;
	},
	
	isTermSelected: function(term) {
		return this.getTermIndex(term) !== -1;
	},
	
	doTermSelect: function(term, legendAdd) {
		var selector = this.getSelectorFromTerm(term);
		//finish updating API array of selected words
		var apiArray = this.parent.getApiParam('selectedWords');
		apiArray.push(term);
		this.parent.setApiParams({selectedWords: apiArray});
		
		//draw the sticky path
		var color = this.parent.getApplication().getColorForTerm(term, true);
		
		if (legendAdd === true) {
			var legend = this.parent.query('[xtype=legend]')[0];
			legend.getStore().add({name: term, mark: color, selector: selector});
			legend.refresh();
		} else {
			var legend = this.parent.query('[xtype=legend]')[0];
			var record = legend.getStore().findRecord('name', term);
			if (record !== null) {
				record.set('mark', color);
				legend.refresh();
			}
		}
		
		var pathHolder = this.prepareFullPath(term);
		var lineObject = {
			word: term, 
			selector: selector,
			params: {params: {}, type: term},
			fullPath: pathHolder.path,
			pathMin: pathHolder.min,
			pathMax: pathHolder.max,
			colour: color
		};
		
		//if this was selected a slippery before click event remove line from navigation bar
		if(selector === this.lastSlippery){
			if (this.isSliderVisible) {
				this.sliderOverlayOff(selector);
			}
			this.lastSlippery = null;
		}
		
		//make sure there is no path already present
		this.chart.select('g[class=frequency-line-' + selector + ']').remove();

		this.overlayQueue.push(lineObject);
		this.chartOverlayOn(lineObject);
		if (this.isSliderVisible) {
			this.sliderOverlayOn(lineObject);
		}
	},
	
	doTermDeselect: function(term, legendRemove) {
		var selector = this.getSelectorFromTerm(term);
		var index = this.getTermIndex(term);
		
		if (legendRemove === true) {
			var legend = this.parent.query('[xtype=legend]')[0];
			var index = legend.getStore().findExact('name', term);
			legend.getStore().removeAt(index);
			legend.refresh();
		}
		
		var updateApi = this.parent.getApiParam('selectedWords');
		for(var i = 0, len = updateApi.length; i < len; i++) {
			if(updateApi[i] === selector) {
				updateApi.splice(i, 1);
				this.parent.setApiParams({selectedWords: updateApi});
			}
		}
		this.chartOverlayOff(selector);
    	this.overlayQueue.splice(index, 1);
    	if (this.isSliderVisible) {
    		this.sliderOverlayOff(selector);
    	}
		this.lastSticky = selector;
	}
	
	,prepareFullPath: function (string) {
		var linePosArray = [],
			pathMin = this.absMaxFreq,
			pathMax = this.absMinFreq;
		
		for(var k = 0, len = this.allData.length; k < len; k++){
			foundB = 0;
			for(var i = 0, lenA = this.allData[k].allDataInternal.length; i < lenA; i++) {
				for(var j = 0, lenB = this.allData[k].allDataInternal[i].frequencyArray.length; j < lenB; j++){
					if(this.allData[k].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal1 = this.allData[k].allDataInternal[i].frequencyArray[j].freq;
						linePosArray.push({x: k, y: yVal1});
						if(yVal1 < pathMin) pathMin = yVal1;
						if(yVal1 > pathMax) pathMax = yVal1;
						foundB = 1;
					}
				}
			}
			if(foundB === 0){
				var yVal2 = this.minFreq;
				linePosArray.push({x: k, y: yVal2});
				if(yVal2 < pathMin) pathMin = yVal2;
				if(yVal2 > pathMax) pathMax = yVal2;
			}
		}
		return {path: linePosArray, min: pathMin, max: pathMax};
	}
	
	,updateFullPath: function () {
//		console.log("fn: updateFullPath")
		var lenA = this.overlayQueue.length;
		while(lenA-- > 0){
			var pathHolder = this.prepareFullPath(this.overlayQueue[lenA].word);
			this.overlayQueue[lenA].fullPath = pathHolder.path;
			this.overlayQueue[lenA].pathMin = pathHolder.min;
			this.overlayQueue[lenA].pathMax = pathHolder.max;
		}
//		console.log(this.overlayQueue)
	}
	
	,buildSliderPath: function (pathArray) {
		var me = this;
		var line = d3.line()
		    .x(function(d) { return me.xSliderScale(d.x); })
		    .y(function(d) { return me.ySliderScale(d.y); })
		    .curve(d3.curveNatural);
		return line(pathArray);
	}
	
	,sliderOverlayOn: function (objectToSelect) {
		//console.log('fn: sliderOverlayOn')		
		this.transitionSliderOverlay(objectToSelect);
		
		//draw path
		this.chart.append('g')
			.attr('class', 'slider')
			.attr('id', 'slider-line-' + objectToSelect.selector)
			.append('path')
			.attr("d", this.buildSliderPath(objectToSelect.fullPath))
			.style('stroke', objectToSelect.colour)
			.style('stroke-width', 2)
			.style('fill', 'none');
			
		//redraw slider
		this.redrawSlider();
	}
	
	,sliderOverlayOff: function (selector) {
	    this.chart.selectAll('g[id=slider-line-' + selector + ']')
	    	.remove();
	    
	    //update slider overlay axis
		this.transitionSliderOverlay();
	}
	
	,redrawSliderOverlay: function() {	
		//console.log('redrawSliderOverlay')
		for(var l = 0; l < this.overlayQueue.length; l++){
			this.sliderOverlayOff(this.overlayQueue[l].selector);
			this.sliderOverlayOn(this.overlayQueue[l]);
		}
	}
	
	,transitionSliderOverlay: function(objectToSelect) {
		//console.log('transitionSliderOverlay')
		objectToSelect = objectToSelect || 0;
		
		//update slider overlay axis
		this.updateYSliderScale(objectToSelect);
		
		//transition all other paths
		var lenA = this.overlayQueue.length;
		while(lenA-- > 0){
			this.chart.selectAll('g#slider-line-' + this.overlayQueue[lenA].selector)
				.select('path')
				.transition().duration(300)
				.ease(d3.easeLinear)
				.attr("d", this.buildSliderPath(this.overlayQueue[lenA].fullPath));
		}
	}
	
	,preparePath: function (string) {
		//console.log('fn: prepareData')
		
		var linePosArray = [];
		
		//peek at the next frequency point and the preceding one to end the line on the edge of the graph
		var foundA
			,foundB
			,foundC;
		
		//add two positions offscreen to the left for smooth transitions 
		for(var k = 0; k < 3 && this.shiftCount - k > 0; k++) {
			foundA = 0;
			for(var i = 0; i < this.allData[this.shiftCount - (1 + k)].allDataInternal.length; i++) {
				for(var j = 0; j < this.allData[this.shiftCount - (1 + k)].allDataInternal[i].frequencyArray.length; j++){
					if(this.allData[this.shiftCount - (1 + k)].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal3 = this.yScale(this.allData[this.shiftCount - (1 + k)].allDataInternal[i].frequencyArray[j].freq);
						linePosArray.unshift({x: this.shiftCount - (1 + k), y: yVal3});
						foundA = 1;
					}
				}
			}
			if(foundA === 0){
				var yVal4 = this.yScale(this.minFreq);
				linePosArray.unshift({x: this.shiftCount - (1 + k), y: yVal4});
			}
		}
		
		//fill in the middle values
		for(var k = this.shiftCount, len = this.numVisPoints + this.shiftCount; k < len; k++){
			foundB = 0;
			for(var i = 0, lenA = this.allData[k].allDataInternal.length; i < lenA; i++) {
				for(var j = 0, lenB = this.allData[k].allDataInternal[i].frequencyArray.length; j < lenB; j++){
					if(this.allData[k].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal1 = this.yScale(this.allData[k].allDataInternal[i].frequencyArray[j].freq);
						linePosArray.push({x: k, y: yVal1});
						foundB = 1;
					}
				}
			}
			if(foundB === 0){
				var yVal2 = this.yScale(this.minFreq);
				linePosArray.push({x: k, y: yVal2});
			}
		}
		
		//add two positions offscreen to the right for smooth transitions 
		for(var k = 0; k < 3 && this.numVisPoints + this.shiftCount + k < this.numDataPoints; k++){
			foundC = 0;
			for(var i = 0; i < this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal.length; i++) {
				for(var j = 0; j < this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal[i].frequencyArray.length; j++){
					if(this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal[i].frequencyArray[j].wordString === string){
						var yVal1 = this.yScale(this.allData[this.numVisPoints + this.shiftCount + k].allDataInternal[i].frequencyArray[j].freq);
						linePosArray.push({x: this.numVisPoints + this.shiftCount + k, y: yVal1});
						foundC = 1;
					}
				}
			}
			if(foundC === 0){
				var yVal2 = this.yScale(this.minFreq);
				linePosArray.push({x: this.numVisPoints + this.shiftCount + k, y: yVal2});
			}
		}
		return linePosArray;
	}
	
	//draws the line graph overlay of the frequency info
	,chartOverlayOn: function(objectToSelect) {
//		console.log('fn: chartOverlayOn')
		
		var me = this;
					
		//change selected word colour
		this.chart.selectAll('g[class=section]')
			.selectAll('g[class=frequencies]')
			.selectAll('text[class=' + objectToSelect.selector.replace(/'/g,"\\'") + ']')
			.style('fill', objectToSelect.colour)
			.style('fill-opacity', 1);
	    	
	    //if transitionCall === 'draw': draw the function for the first time		
		//if not: shift displayData to a different subset of allData
		//then display the newly shifted data
		
		var linePosArray = this.preparePath(objectToSelect.word);
		
		var pos;
		
		//draw path
		var line = d3.line()
		    .x(function(d) { 
		    	pos = d.x;
		    	return me.xScale(d.x + me.callOffset()); })
		    .y(function(d) { return d.y; })
		    .curve(d3.curveNatural);
		
		var path = this.chart.select('.overlay')
			.append('g')
			.attr('class', 'frequency-line-' + objectToSelect.selector)
			.append('path')
			.attr("d", line(linePosArray))
			.style('stroke', objectToSelect.colour)
			.style('stroke-width', 2)
			.style('fill', 'none');
					
		var posDif = (this.xScale(pos) - this.xScale(pos + this.callOffset()));
		
		if(this.transitionCall === 'left' || this.transitionCall ==='right') {
			path.transition()
				.duration(me.getDuration())
				.ease(d3.easeLinear)
			    .attr("transform", "translate(" + posDif + ")");
		}
	}
	
	,chartOverlayOff: function(selector){
		var me = this;
		
		this.chart.selectAll('text.' + selector)
	    	.style('fill', 'black')
	    	.style('fill-opacity', function(d) { return me.opacityScale(d.freq); });
	    
	    this.chart.select('g.frequency-line-' + selector)
	    	.remove();
	}
	
	//reselect all the sticky words
	//a screen movement has changed the words positions
	,redrawChartOverlay: function () {
		//console.log('fn: redrawChartOverlay')
		for(var i = 0; i < this.overlayQueue.length; i++){
			this.chartOverlayOff(this.overlayQueue[i].selector);
			this.chartOverlayOn(this.overlayQueue[i]);
		}
	}
	
	//
	//SCALE FUNCTIONS
	//
	
	//all these scales need to be updated if this.absMaxFreq or this.valFraction changes
	,manageAllYScales: function() {
		this.manageFontScale();
		this.manageOpacityScale();
		this.manageYScale();
		this.manageYSliderScale();
	}
	
	,manageFontScale: function() {
		//console.log('fn: fontScale')
		 this.fontScale.domain([this.minFreq, this.absMaxFreq * this.valFraction])
	    	.range([10, this.maxFont]);
	}
	
	/*,maxFontScale : function (value) {
		var scale = d3.scaleLinear()
			.domain([600,2000])
			.range([15,60]);
		return scale(value);
	}*/
	
	,manageOpacityScale: function() {
		this.opacityScale.domain([0, this.absMaxFreq * this.valFraction])
    		.range([0.4, 0.8]);
	}
	
	,manageYScale: function () {
		if(this.parent.getApiParam('yAxisScale') == 'linear') this.yScale = d3.scaleLinear();
		if(this.parent.getApiParam('yAxisScale') == 'log') this.yScale = d3.scaleLog();
		
		this.yScale.domain([this.minFreq, this.absMaxFreq * this.valFraction * 1.25])
				.rangeRound([this.container.getHeight() - this.bPadding, (this.tPadding) + this.getSliderHeight()]);
	}
	
	,manageYSliderScale: function() {
		var top = this.tPadding
			,bottom = this.tPadding + this.getSliderHeight();
		
		if(this.parent.getApiParam('yAxisScale') == 'linear') this.ySliderScale = d3.scaleLinear();
		if(this.parent.getApiParam('yAxisScale') == 'log') this.ySliderScale = d3.scaleLog();
		
		this.ySliderScale.domain([this.minFreq, this.absMaxFreq])
				.rangeRound([bottom, top]);
	}
	
	,updateYSliderScale: function(updateWithObject) {
		updateWithObject = updateWithObject || 0;
		var selectedMin = this.minFreq, //setting this to this.absMinFreq effectively deactivates it, to make it work use this.absMaxFreq
			selectedMax = 0;
	    	
	    //go through overlayQueue check for min / max
		var len = this.overlayQueue.length;
		while(len-- > 0){
			if(this.overlayQueue[len].pathMin < selectedMin) selectedMin = this.overlayQueue[len].pathMin;
			if(this.overlayQueue[len].pathMax > selectedMax) selectedMax = this.overlayQueue[len].pathMax;
		}
		if(updateWithObject != 0 && updateWithObject.pathMin < selectedMin) selectedMin = updateWithObject.pathMin;
		if(updateWithObject != 0 && updateWithObject.pathMax > selectedMax) selectedMax = updateWithObject.pathMax;
		
		this.ySliderScale.domain([selectedMin, selectedMax]);
	}
	
	,manageAllXScales: function() {
		this.manageXScale();
		this.manageXSliderScale();
	}
	
	,manageXScale: function() {
		this.xScale.domain([this.shiftCount - 0.5, this.numVisPoints + this.shiftCount - 0.5])
	    	.range([this.lPadding, this.container.getWidth() - this.rPadding]);
	}
	
	,manageXSliderScale: function() {
		this.xSliderScale.domain([0, this.numDataPoints - 1])
	    	.range([this.lPadding, this.container.getWidth() - this.rPadding]);
	}

	,getSliderHeight: function() {
		return this.isSliderVisible ? this.sliderHeight+this.sliderBPadding : 0;
	}
	
	,setSliderHeight: function() {
		this.sliderHeight = Math.max(10, this.container.getHeight()*this.sliderHeightRatio);
	}
	
	,hideSlider: function() {
		this.isSliderVisible = false;
		this.removeSlider(true);
		this.doResize();
	}
	
	,showSlider: function() {
		this.isSliderVisible = true;
		this.doResize();
	}
	
	
	//
	//MISC. FUNCTIONS
	//

	
	,setTitleLength: function () {
		//console.log('fn:setTitleLength')
		var me = this, 
			item;
		this.titlesArray = [];
		
		var scale = d3.scaleLinear()
			.domain([350,1250])
			.range([10,40]);
		
		var corpus = this.parent.getCorpus();
		for (var i = 0, len = corpus.getDocumentsCount(); i < len; i++) {
			var item = corpus.getDocument(i);
			var shortTitle = item.getShortTitle();			
			if(shortTitle.length <= scale(me.container.getWidth())) {
				me.titlesArray.push(shortTitle); 
			} else {
				var shorterTitle = shortTitle.substring(0,scale(me.container.getWidth()) - 3);
				me.titlesArray.push(shorterTitle + '...'); 
			}
		}
	}
	
	,callOffset: function () {
//		console.log('fn: callOffset')
		var callOffset;
		if(this.transitionCall === 'draw' || this.transitionCall === 'redraw') { 
			callOffset = 0; 
		}
		if(this.transitionCall === 'left') { 
			callOffset = -1;
		}
		if(this.transitionCall === 'right') { 
			callOffset = 1;
		}
		return callOffset;
	}
	
	,getSelectorFromTerm: function (string) {
		//console.log('fn: getSelectorFromTerm')
		// return string || ''; // https://github.com/voyanttools/Voyant/commit/9b675b325fd1b4968d7b8285a65650fd26577f40

		if (string !== undefined) {
			// construct valid css selector
			var charCodeStr = 'tr';
			for (var i = 0; i < string.length; i++) {
				charCodeStr += '-'+string.charCodeAt(i);
			}
			return charCodeStr;
		} else {
			return '';
		}
	},
	
	getDuration: function() {
		return this.numDataPoints*(100-this.parent.getSpeed())
	}
	
};
Ext.define('Voyant.util.Api', {
	constructor: function(config) {
		var apis = [];
		if (!this.isApplication) {
			var app = this.getApplication ? this.getApplication() : Voyant.application;
			
			// try to load from first-level mixins
			if (this.mixins) {
				for (key in this.mixins) {
					var clz = Ext.ClassManager.get(key);
					if (clz && clz.api) {
						apis.splice(0, 0, clz.api)
					}
				}
			}
			this.addParentApi(apis, Ext.ClassManager.getClass(app)); // gather class params
			if (app.getApiParams) {
				apis.push(app.getApiParams()); // now add instance params, last
			}
		}

		this.addParentApi(apis, Ext.ClassManager.getClass(this)); // add params from this class and parents

		this.api = {};
		apis.forEach(function(a) {
			for (key in a) {
				this.api[key] = {initial: a[key], value: a[key]} // overwrite previous entries
			}
		}, this)
		
    	var queryParams = Ext.Object.fromQueryString(document.location.search);
		var xtype = this.getXType ? this.getXType() : undefined;
    	for (var key in queryParams) {
    		if (this.api[key]) {
    			this.setApiParam(key, queryParams[key]);
    		} else if (xtype && key.indexOf(".")>0) {
    			var k = key.substring(key.indexOf(".")+1);
    			if (k && k in this.api) {
    				this.setApiParam(k, queryParams[key])
    			}
    		}
    	}
    	
		if (config && Ext.isObject(config.api)) {
	    	for (var key in config.api) {
	    		if (this.api[key]) {
	    			this.setApiParam(key, config.api[key]);
	    		}
	    	}
	    	delete config.api; // remove so it doesn't overwrite default api
		}
		
    	// handle "type"  parameter specially for backwards compatibility
    	if (queryParams["type"] && ("query" in this.api) && !this.getApiParam('query')) {
    		this.setApiParam("query", queryParams['type']);
    	}
    	
	},
	addParentApi: function(apis, clz) {
		if (clz.api) {apis.splice(0,0, clz.api)} // add to front
		if (clz.superclass) {this.addParentApi(apis, clz.superclass.self)}
	},
	getApiParam: function(key, defaultValue) {
		return this.api[key]!==undefined ? this.api[key].value : defaultValue
	},
	getApiParams: function(keys, keepEmpty) {
		keys = keys || Object.keys(this.api);
		var api = {};
		if (Ext.isString(keys)) {keys=[keys]}
		keys.forEach(function(key) {
			var val = this.getApiParam(key);
			if (keepEmpty || !Ext.isEmpty(val)) {api[key]=val;}

		}, this);
		return api;
	},
	
	getModifiedApiParams: function() {
		var api = {};
		for (var key in this.api) {
			if (this.api[key].initial!=this.api[key].value) {
				api[key]=this.api[key].value
			}
		}
		return api
	},
	
	setApiParams: function(config) {
		for (var key in config) {this.setApiParam(key, config[key])}
	},
	
	setApiParam: function(key, value) {
		if (this.api && this.api[key]) {this.api[key].value=value;}
	}
});
Ext.define('Voyant.util.Localization', {
	statics: {
		DEFAULT_LANGUAGE: 'en',
		LANGUAGE: 'en',
		AVAILABLE_LANGUAGES: ["ar","bs","cz","de","en","es","fr","he","hr","it","ja","pt","ru","sr"],
		i18n: {
		}
	},
	
	getLanguage: function(code) {
		if (code.length === 2) {
			if (Voyant.util.Localization.AVAILABLE_LANGUAGES.indexOf(code) !== -1) {
				return this.localize(code);
			} else {
				return code;
			}
		} else {
			var langs = Voyant.util.Localization.AVAILABLE_LANGUAGES.map(function(lang) {
				return {text: this.localize(lang).toLowerCase(), value: lang}
			}, this);
			var lowerCaseCode = code.toLowerCase();
			var match = langs.find(function(lang) {
				return lang.text === lowerCaseCode;
			});
			if (match) return match.value;
			else return code;
		}
	},
	
	localize: function(key, config) {
		return this._localizeObject(this, key, config);
	},
	
	_localizeObject: function(object, key, config) {

		var val = this._localizeClass(Ext.ClassManager.getClass(object), key, config);
		if (val) {return val;}
		if (object.mixins) { // look at mixins first
			for (mixin in object.mixins) {
				var val = this._localizeClass(Ext.ClassManager.getClass(object.mixins[mixin]), key, config);
				if (val) {return val;}
			}
		}
		if (object.superclass) { // then superclasses
			val =  this._localizeObject(object.superclass, key, config);
			if (val) {return val;}
		}
		return config && config['default']!=undefined ? config['default'] : '['+key+']';
	},
	
	_localizeClass: function(clazz, key, config) {
		if (clazz && clazz.i18n && clazz.i18n[key]) {
			var use = false;
			if (clazz.i18n[key]) {
				use = clazz.i18n[key];
			}
			/*
			if (config && config.lang && clazz.i18n[key][config.lang]) {
				use = clazz.i18n[key][config.lang];
			}
			else if (clazz.i18n[key][Voyant.util.Localization.LANGUAGE]) {
				use = clazz.i18n[key][Voyant.util.Localization.LANGUAGE];
			}
			else if (clazz.i18n[key][Voyant.util.Localization.DEFAULT_LANGUAGE]) {
				use = clazz.i18n[key][Voyant.util.Localization.DEFAULT_LANGUAGE];
			}
			*/
			if (use) {
				if (use.isTemplate) { // template
					return use.apply(config);
				}
				return use; // string
			}
			return config && config['default']!=undefined ? config['default'] : '['+key+']'; // no language key found, so just return the key
		}
		return false
	},
	
	getLanguageToolMenu: function() {
		var me = this;
		return {
			type: 'language',
			tooltip: this.localize("languageTitle"),
			xtype: 'toolmenu',
	        glyph: 'xf1ab@FontAwesome',
			handler: me.showLanguageOptions,
			scope: me
		} 
	},

	
	showLanguageOptions: function() {
		var me = this;
		var langs = Voyant.util.Localization.AVAILABLE_LANGUAGES.map(function(lang) {
			return {text: this.localize(lang), value: lang}
		}, this);
		langs.sort(function(a,b) {
			return a.text.localeCompare(b.text);
		});
		langs.splice(0,0,{text: this.localize('autoRecommended'), value: ''})
		
		new Ext.window.Window({
			title: this.localize("languageTitle"),
			modal: true,
			items: {
				xtype: 'form',
				items: [{
					xtype: 'combo',
					name: 'lang',
					value: this.getApiParam("lang") || "",
	    	        queryMode: 'local',
	    	        editable: false,
	    	        fieldLabel: this.localize('chooseLanguage'),
	    	        width: 450,
	    	        labelAlign: 'right',
	    	        labelWidth: 150,
	    	        displayField: 'text',
	    	        valueField: 'value',
					store: {
						fields: ['text', 'value'],
						data: langs
					}
				}/*,{
					xtype: 'combo',
					name: 'rtl',
					value: '',
	    	        queryMode: 'local',
	    	        editable: false,
	    	        fieldLabel: this.localize('rtlLabel'),
	    	        labelAlign: 'right',
	    	        displayField: 'text',
	    	        valueField: 'value',
					store: {
						fields: ['text', 'value'],
						data: [{
							text: this.localize('auto'),
							value: ''
						},{
							text: this.localize('yes'),
							value: 'true'
						},{
							text: this.localize('no'),
							value: 'false'
						}]
					}
				}*/],
				buttons: [{
	            	text: this.localize("cancelTitle"),
		            ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize("confirmTitle"),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var form = btn.up('form');
	        			if (form.isDirty()) {
	        				var app = me.getApplication();
	        				var params = app.getModifiedApiParams();
	        				if (app.getCorpus()) {
	        					params.corpus = app.getCorpus().getAliasOrId();
	        				} else {
	        					delete params.panels; // we probably don't need this
	        				}
	        				delete params.lang;
//	        				delete params.rtl;
	        				var values = form.getValues();
	        				if (values.lang) {params.lang = values.lang;}
//	        				if (values.rtl) {params.rtl = values.lang;}
	        				location.assign("./?"+Ext.Object.toQueryString(params))
	        			}
	        			btn.up('window').close();
	        		},
	        		scope: me
	            }]
			},
			bodyPadding: 5
		}).show()
	}
	
});

/**
 * A utility for storing palettes and associations between terms and colors.
 */
Ext.define('Voyant.util.Colors', {

	config: {
		/**
		 * Palettes for use with terms and documents.
		 * @private
		 */
		palettes: undefined,
		/**
		 * For tracking associations between a term and a color (in rgb format), to ensure consistent coloring across tools.
		 * @private
		 */
		colorTermAssociations: {},
		/**
		 * For tracking the text color to use with the corresponding background color.
		 * @private
		 */
		textColorsForBackgroundColors: {}
	},

	lastUsedPaletteIndex: -1, // for tracking the last palette index that was used when getting a new color for a term

	constructor: function(config) {
		this.setPalettes({
			'default': [[0, 0, 255], [51, 197, 51], [255, 0, 255], [121, 51, 255], [28, 255, 255], [255, 174, 0], [30, 177, 255], [182, 242, 58], [255, 0, 164], [51, 102, 153], [34, 111, 52], [155, 20, 104], [109, 43, 157], [128, 130, 33], [111, 76, 10], [119, 115, 165], [61, 177, 169], [202, 135, 115], [194, 169, 204], [181, 212, 228], [182, 197, 174], [255, 197, 197], [228, 200, 124], [197, 179, 159]]
		});
		this.resetColorTermAssociations();

		// palettes
		if (d3 !== undefined) {
			var cat10 = d3.scaleOrdinal(d3.schemeCategory10).range().map(function(val) { return this.hexToRgb(val); }, this);
			var cat20a = d3.scaleOrdinal(d3.schemeCategory20).range().map(function(val) { return this.hexToRgb(val); }, this);
			var cat20b = d3.scaleOrdinal(d3.schemeCategory20b).range().map(function(val) { return this.hexToRgb(val); }, this);
			var cat20c = d3.scaleOrdinal(d3.schemeCategory20c).range().map(function(val) { return this.hexToRgb(val); }, this);
			var set3 = ['#8dd3c7','#ffffb3','#bebada','#fb8072','#80b1d3','#fdb462','#b3de69','#fccde5','#d9d9d9','#bc80bd','#ccebc5','#ffed6f'].map(function(val) { return this.hexToRgb(val); }, this);
			this.addColorPalette('d3_cat10', cat10);
			this.addColorPalette('d3_cat20a', cat20a);
			this.addColorPalette('d3_cat20b', cat20b);
			this.addColorPalette('d3_cat20c', cat20c);
			this.addColorPalette('d3_set3', set3);
		}
		
		var extjs = Ext.create('Ext.chart.theme.Base').getColors().map(function(val) { return this.hexToRgb(val); }, this);
		this.addColorPalette('extjs', extjs);
	},

	resetColorTermAssociations: function() {
		this.lastUsedPaletteIndex = -1;
		this.setColorTermAssociations({});
		this.setTextColorsForBackgroundColors({});
	},

	rgbToHex: function(a) {
		return "#" + ((1 << 24) + (a[0] << 16) + (a[1] << 8) + a[2]).toString(16).slice(1);
	},
	
	hexToRgb: function(hex) {
		// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
		var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
		hex = hex.replace(shorthandRegex, function(m, r, g, b) {
			return r + r + g + g + b + b;
		});

		var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? [
			parseInt(result[1], 16),
			parseInt(result[2], 16),
			parseInt(result[3], 16)
		] : null;
	},

	/**
	 * Adds a new palette to the list.
	 * @param key {String} The palette name.
	 * @param values {Array} The array of colors. Format: [[r,g,b],[r,g,b],....]
	 */
	addColorPalette: function(key, values) {
		this.getPalettes()[key] = values;
	},

	/**
	 * Gets the whole color palette.
	 * @param {String} [key] The key of the palette to return.
	 * @param {Boolean} [returnHex] True to return a hexadecimal representation of each color (optional, defaults to rgb values).
	 * @return {Array} The color palette.
	 * @private
	 */
	getColorPalette: function(key, returnHex) {
		var paletteKey = key || 'default';
		var palette = this.getPalettes()[paletteKey];
		if (palette === undefined) {
			palette = [];
		}
		if (returnHex) {
			var colors = [];
			for (var i = 0; i < palette.length; i++) {
				colors.push(this.rgbToHex(palette[i]));
			}
			return colors;
		} else {
			return palette;
		}
	},

	saveCustomColorPalette: function(paletteArray) {
		var dfd = new Ext.Deferred();

		Ext.Ajax.request({
			url: this.getTromboneUrl(),
			params: {
				tool: 'resource.StoredResource',
				storeResource: Ext.encode(paletteArray)
			},
			success: function(response, req) {
				var json = Ext.util.JSON.decode(response.responseText);
				var id = json.storedResource.id;
				this.addColorPalette(id, paletteArray);
				
				dfd.resolve(id, paletteArray);
			},
			failure: function(response) {
				dfd.reject();
			},
			scope: this
		});

		return dfd.promise;
	},
	
	loadCustomColorPalette: function(paletteId) {
		var dfd = new Ext.Deferred();

		Ext.Ajax.request({
			url: this.getTromboneUrl(),
			params: {
				tool: 'resource.StoredResource',
				retrieveResourceId: paletteId
			},
			success: function(response, req) {
				var json = Ext.util.JSON.decode(response.responseText);
				var value = json.storedResource.resource;
				var palette = Ext.decode(value);
				// TODO should palette api param be set here?
				this.addColorPalette(paletteId, palette);

				dfd.resolve(paletteId, palette);
			},
			failure: function(response) {
				this.setApiParam('palette', undefined);

				dfd.reject();
			},
			scope: this
		});

		return dfd.promise;
	},


	/**
	 * Gets a particular color from the palette.
	 * @param {String} key The palette key.
	 * @param {Integer} index The index of the color to get.
	 * @param {Boolean} [returnHex] True to return a hexadecimal representation of the color (optional, defaults to rgb values).
	 * @return {Mixed} The requested color, either a hex string or array of rgb values.
	 * @private
	 */
	getColor: function(key, index, returnHex) {
		var paletteKey = key || 'default';
		var palette = this.getPalettes()[paletteKey];
		if (index >= palette.length) {
			index = index % palette.length;
		}
		if (returnHex) {
			return this.rgbToHex(palette[index]);
		} else {
			return palette[index];
		}
	},

	/**
	 * Gets the color associated with the term.  Creates a new association if none exists.
	 * @param {String} key The palette key.
	 * @param {String} term The term to get the color for.
	 * @param {Boolean} [returnHex] True to return a hexadecimal representation of the color (optional, defaults to rgb values).
	 * @return {Mixed} The requested color, either a hex string or array of rgb values.
	 * @private
	 */
	getColorForTerm: function(key, term, returnHex) {
		var paletteKey = key || 'default';
		var palette = this.getPalettes()[paletteKey];

		if (palette === undefined) {
			console.warn('no palette found for',key);
			palette = this.getPalettes()['default'];
		}

		if (term.indexOf(':') != -1) {
			term = term.split(':')[1];
		}
		term = term.toLowerCase();

		var color = this.getColorTermAssociations()[term];
		if (color === undefined) {
			var index = this.lastUsedPaletteIndex+1;
			index %= palette.length;
			color = palette[index];
			this.getColorTermAssociations()[term] = color;
			this.lastUsedPaletteIndex = index;
		}
		if (returnHex) {
			color = this.rgbToHex(color);
		}
		return color;
	},

	/**
	 * Set the color assocation for a term.
	 * @param {String} term The term
	 * @param {Array} color An array of RGB values
	 */
	setColorForTerm: function(term, color) {
		if (Array.isArray(color) === false) {
			color = this.hexToRgb(color);
		}
		term = term.toLowerCase();
		this.getColorTermAssociations()[term] = color;
	},

	getColorForEntityType: function(type, returnHex) {
		var index;
		switch(type) {
			case 'person':
				index = 5;
				break;
			case 'location':
				index = 6;
				break;
			case 'organization':
				index = 2;
				break;
			case 'misc':
				index = 0;
				break;
			case 'time':
			case 'date':
			case 'duration':
				index = 4;
				break;
			case 'money':
				index = 1;
				break;
			default:
				index = 8;
		}

		var color = this.getPalettes()['d3_set3'][index];
		if (returnHex) {
			color = this.rgbToHex(color);
		}
		return color;
	},

	/**
	 * Accessible Perceptual Contrast Algorithm adapted from https://github.com/Myndex/apca-w3
	 * @param {Array} background An array of RGB values
	 * @param {Array} foreground An array of RGB values
	 * @return {Number}
	 */
	getColorContrast: function(background, foreground) {

		// exponents
		const normBG = 0.56;
		const normTXT = 0.57;
		const revTXT = 0.62;
		const revBG = 0.65;

		// clamps
		const blkThrs = 0.022;
		const blkClmp = 1.414;
		const loClip = 0.1;
		const deltaYmin = 0.0005;

		// scalers
		// see https://github.com/w3c/silver/issues/645
		const scaleBoW = 1.14;
		const loBoWoffset = 0.027;
		const scaleWoB= 1.14;
		const loWoBoffset = 0.027;

		function fclamp (Y) {
			if (Y >= blkThrs) {
				return Y;
			}
			return Y + (blkThrs - Y) ** blkClmp;
		}

		function linearize (val) {
			let sign = val < 0? -1 : 1;
			let abs = Math.abs(val);
			return sign * Math.pow(abs, 2.4);
		}

		let S;
		let C;
		let Sapc;

		// Myndex as-published, assumes sRGB inputs
		let R, G, B;

		// Calculates "screen luminance" with non-standard simple gamma EOTF
		// weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom
		[R, G, B] = foreground;
		let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;

		[R, G, B] = background;
		let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;

		// toe clamping of very dark values to account for flare
		let Ytxt = fclamp(lumTxt);
		let Ybg = fclamp(lumBg);

		// are we "Black on White" (dark on light), or light on dark?
		let BoW = Ybg > Ytxt;

		// why is this a delta, when Y is not perceptually uniform?
		// Answer: it is a noise gate, see
		// https://github.com/LeaVerou/color.js/issues/208
		if (Math.abs(Ybg - Ytxt) < deltaYmin) {
			C = 0;
		}
		else {
			if (BoW) {
				// dark text on light background
				S = Ybg ** normBG - Ytxt ** normTXT;
				C = S * scaleBoW;
			}
			else {
				// light text on dark background
				S = Ybg ** revBG - Ytxt ** revTXT;
				C = S * scaleWoB;
			}
		}
		if (Math.abs(C) < loClip) {
			Sapc = 0;
		}
		else if (C > 0) {
			// not clear whether Woffset is loBoWoffset or loWoBoffset
			// but they have the same value
			Sapc = C - loBoWoffset;
		}
		else {
			Sapc = C + loBoWoffset;
		}

		return Sapc * 100;
	},

	/**
	 * Returns either black or white color, depending on the supplied background color.
	 * @param {Array} backgroundColor An array of RGB values
	 * @returns {Array}
	 */
	getTextColorForBackground: function(backgroundColor) {
		var textColor = this.getTextColorsForBackgroundColors()[backgroundColor.join('')];
		if (textColor === undefined) {
			var darkText = [0,0,0];
			var lightText = [255,255,255];
			var darkContrast = Math.abs(this.getColorContrast(backgroundColor, darkText));
			var lightContrast = Math.abs(this.getColorContrast(backgroundColor, lightText));
			textColor = lightContrast > darkContrast ? lightText : darkText;
			this.getTextColorsForBackgroundColors()[backgroundColor.join('')] = textColor;
		}
		return textColor;
	}
})

Ext.define("Voyant.util.DetailedError", {
	extend: "Ext.Error",
	mixins: ['Voyant.util.Localization'],
	config: {
		msg: undefined,
		error: undefined,
		details: undefined
	},
	statics: {
		i18n: {
			error: "Error"
		}
	},
	constructor: function(config) {
		this.setMsg(config.msg);
		this.setError(config.error);
		this.setDetails(config.details);
		this.callParent(arguments);
//		debugger
//		this.show();
	},
	
	show: function(config) {
		if (window.showError) {showError.call(this);}
		else {this.showMsg(config)}
	},
	
	showMsg: function(config) {
		config = config || {};
		Ext.applyIf(config, {
			message: this.getMsg()+"<p class='error'>\n"+this.getError()+"… "+
				"<a href='#' onclick=\"window.open('').document.write(unescape('<pre>"+escape(this.getDetails())+"</pre>')); return false;\">more</a></p>",
			title: this.localize("error"),
		    buttons: Ext.Msg.OK,
		    icon: Ext.MessageBox.ERROR,
		    autoScroll: true
		});
		Ext.Msg.show(config);
	}
})

Ext.define("Voyant.util.ResponseError", {
	extend: "Voyant.util.DetailedError",
	config: {
		response: undefined
	},
	constructor: function(config) {
		this.setResponse(config.response);
		Ext.applyIf(config, {
			msg: config.response.statusText, // hopefully already set by creator
			error: (typeof config.response === 'object' && 'responseText' in config.response) ? config.response.responseText.split(/(\r\n|\r|\n)/).shift() : config.response, // show first line of response
			details: (typeof config.response === 'object' && 'responseText' in config.response) ? config.response.responseText : config.response
		})
		this.callParent(arguments);
	}
	
})

Ext.define('Voyant.util.SparkLine', {
	/**
	 * Gets a Google spark line.
	 * 
	 * @param {Array} values An array of numerical values.
	 * @param {Integer} stretch The width to stretch the spark line towards (currently unused).
	 * @return {String} The image(s) of the spark line.
	 * @private
	 */
	getSparkLine : function(values, stretch) {
		if (values.length < 2) {
			return '';
		}
		var min = Number.MAX_VALUE;
		var max = Number.MIN_VALUE;
		var hasDecimal = false;
		for ( var i = 0; i < values.length; i++) {
			if (values[i] < min) {
				min = values[i];
			}
			if (values[i] > max) {
				max = values[i];
			}
			if (!hasDecimal
					&& values[i].toString().indexOf('.') > -1) {
				hasDecimal = true;
			}
		}
		var dif = (max - min).toString();
		var multiplier = 1;
		var divider = 1;

		var newvalues = [];
		if (hasDecimal) {
			var multiplier = 100;
			var ind = dif.indexOf(".") + 1;
			for ( var i = ind; i < dif.length; i++) {
				if (dif.charAt(i) == '0') {
					multiplier *= 10;
				} else {
					break;
				}
			}
			for ( var i = 0; i < values.length; i++) {
				newvalues[i] = parseInt(values[i] * multiplier);
			}
			max = parseInt(max * multiplier);
			min = parseInt(min * multiplier);

		} else {
			var divider = 1;
			for ( var i = dif.length - 1; i > -1; i--) {
				if (dif.charAt(i) == '0') {
					divider *= 10;
				} else {
					break;
				}
			}
			if (divider != 1) {
				for ( var i = 0; i < values.length; i++) {
					newvalues[i] = values[i] / divider;
				}
				max /= divider;
				min /= divider;
			} else {
				newvalues = values;
			}
		}

		var valLen = (max.toString().length > min.toString().length ? max
				.toString().length
				: min.toString().length) + 1;
		var valuesPerImage = Math.floor(1800 / valLen);
		var baseUrl = 'http://chart.apis.google.com/chart?cht=ls&amp;chco=0077CC&amp;chls=1,0,0&amp;chds='+ min + ',' + max;
		var images = Math.ceil(values.length / valuesPerImage);
		var counter = 0;
		var response = '';
		var wid;
		if (values.length < 5) {
			wid = 5;
		} else if (values.length < 10) {
			wid = 4;
		} else if (values.length < 20) {
			wid = 3;
		} else if (values.length < 50) {
			wid = 2;
		} else {
			wid = 1;
		}

		/*
		 * if (stretch) { wid =
		 * Math.ceil(stretch/values.length); if (wid>5) {wid=5;} }
		 */

		for ( var i = 0; i < images; i++) {
			var vals = newvalues.slice(counter,
					counter += valuesPerImage);
			response += "<img style='margin: 0; padding: 0;' border='0' src='"
					+ baseUrl
					+ '&amp;chs='
					+ (wid * vals.length)
					+ 'x15&amp;chd=t:'
					+ vals.join(',') + "' alt='' class='chart-";
			if (images == 1) {
				response += 'full';
			} else {
				if (i > 0 && i + 1 < images) {
					response + 'middle';
				} else if (i == 0) {
					response += 'left';
				} else {
					response += 'right';
				}
			}
			response += "' />";
		}
		return response;
	}
});
Ext.define('Voyant.util.Toolable', {
	requires: ['Voyant.util.Localization','Voyant.util.Api'],
	statics: {
		i18n: {
		},
		api: {
			suppressTools: false
		}
	},
	constructor: function(config) {
		config = config || {};
		if (this.getApiParam && this.getApiParam("suppressTools")=="true") {return;}
		if ("header" in config && config.header===false) {return;}
		var me = this;
		var moreTools = undefined;
		var parent = this.up('component');
		if (config.moreTools) {
			moreTools = [];
			config.moreTools.forEach(function(xtype) {
				 if (xtype && xtype!=this.xtype) {
					moreTools.push(this.getMenuItemFromXtype(xtype));
				 }

			}, this)
		}
		else if (parent && parent.getInitialConfig('moreTools')) {
			moreTools = [];
			 parent.getInitialConfig('moreTools').forEach(function(xtype) {
				 if (xtype && xtype!=this.xtype) {
					moreTools.push(this.getMenuItemFromXtype(xtype));
				 }

			}, this)
		}
		if (moreTools && this.getApplication().getMoreTools) {
			moreTools.push({xtype: 'menuseparator'});
		}
		if (this.getApplication().getMoreTools) {
			moreTools = moreTools || [];
			var app = this.getApplication();
			var tools = app.getMoreTools();
			tools.forEach(function(category) {
				var categories = [];
				category.items.forEach(function(xtype) {
					categories.push(this.getMenuItemFromXtype(xtype))
				}, this)
				moreTools.push({
					text: app.localize(category.i18n),
					glyph: category.glyph,
					menu: {items: categories}
				})
			}, this);
		}			

		var exportItems = undefined;
		var toolsMap = {
//				maximize: {
//					glyph: 'xf08e@FontAwesome',
//					fn: this.maximizeToolClick
//				},
				save: {
					glyph: 'xf08e@FontAwesome',
					fn: this.exportToolClick,
					items: exportItems
				},
				plus: moreTools ? {
					glyph: 'xf17a@FontAwesome',
					items: moreTools
				} : undefined,
				gear: this.showOptionsClick || this.getOptions ? {
					glyph: 'xf205@FontAwesome',
					fn: this.showOptionsClick ? this.showOptionsClick : function(panel) {
						if (panel.isXType("voyanttabpanel")) {panel = panel.getActiveTab()}
						// we're here because the panel hasn't overridden the click function
						Ext.create('Ext.window.Window', {
							title: panel.localize("optionsTitle"),
							modal: true,
			            	panel: panel,
							items: {
								xtype: 'form',
								items: panel.getOptions(),
								listeners: {
									afterrender: function(form) {
										var api = panel.getApiParams(form.getForm().getFields().collect('name'));
										form.getForm().setValues(api);
									}
								},
								buttons: [{
					            	text: panel.localize("reset"),
									glyph: 'xf0e2@FontAwesome',
					            	flex: 1,
					            	panel: panel,
						            ui: 'default-toolbar',
					        		handler: function(btn) {
					        			if (this.mixins && this.mixins["Voyant.util.Api"]) {
					        				this.mixins["Voyant.util.Api"].constructor.apply(this);
					        				if (this.getCorpus && this.getCorpus()) {
					        					this.fireEvent("loadedCorpus", this, this.getCorpus())
					        				}
					        			}
					        			btn.up('window').close();
					        		},
					        		scope: panel
								
								},{xtype: 'tbfill'}, {
					            	text: panel.localize("cancelTitle"),
						            ui: 'default-toolbar',
					                glyph: 'xf00d@FontAwesome',
					        		flex: 1,
					        		handler: function(btn) {
					        			btn.up('window').close();
					        		}
								},{
					            	text: panel.localize("confirmTitle"),
									glyph: 'xf00c@FontAwesome',
					            	flex: 1,
					            	panel: panel,
					        		handler: function(btn) {
										var values = btn.up('form').getValues();
										
										// set api values (all of them, not just global ones)
										this.setApiParams(values);

										var app = this.getApplication();
										
										var keyValuesForGlobalUpdate = [];
										if (values['stopList'] !== undefined && values['stopListGlobal'] !== undefined && values.stopListGlobal) {
											keyValuesForGlobalUpdate.push(['stopList', values['stopList']]);
										}
										if (values['termColors'] !== undefined && values['termColorsGlobal'] !== undefined && values.termColorsGlobal) {
											keyValuesForGlobalUpdate.push(['termColors', values['termColors']]);
										}

										var categoriesDfd = new Ext.Deferred();
										if (values['categories'] && values['categories'] !== '') {
											app.loadCategoryData(values['categories']).then(function() {
												// no errors
											}, function() {
												values['categories'] = undefined;
											}).finally(function() { // this returns a ES6 Promise instead of Ext so used finally
												keyValuesForGlobalUpdate.push(['categories', values['categories']]);
												categoriesDfd.resolve();
											})
										} else {
											categoriesDfd.resolve();
										}
										
										var paletteDfd = new Ext.Deferred(); // need a deferred since we might have to load a custom palette
										if (values['palette'] !== undefined) {
											app.resetColorTermAssociations();
											if (app.getColorPalette(values['palette']).length === 0) {
												// it's a custom palette that we need to load first
												app.loadCustomColorPalette(values['palette']).then(function() {
													// no errors
												}, function() {
													// error loading palette, so reset to default
													values['palette'] = 'default';
												}).always(function() { // this returns a Ext Promise instead of ES6 so used always
													keyValuesForGlobalUpdate.push(['palette', values['palette']]);
													paletteDfd.resolve();
												})
											} else {
												keyValuesForGlobalUpdate.push(['palette', values['palette']]);
												paletteDfd.resolve();
											}
										} else {
											paletteDfd.resolve();
										}

										Ext.Promise.all([categoriesDfd, paletteDfd]).then(function() {
											var corpus = app.getCorpus();
											if (keyValuesForGlobalUpdate.length > 0) {
												var panels = app.getViewport().query("panel,chart");
												keyValuesForGlobalUpdate.forEach(function(keyValue) {
													var key = keyValue[0];
													var value = keyValue[1];
													
													// set the api value for the app
													if (app.setApiParam) {
														app.setApiParam(key, value);
													}
													
													// tell the panels, including this one
													for (var i=0; i<panels.length; i++) {
														if (panels[i].setApiParam) {
															panels[i].setApiParam(key, value);
														}
													}
												});

												// trigger a reloading of the app
												if (corpus) {
													app.dispatchEvent("loadedCorpus", this, corpus);
												} else {
													app.dispatchEvent("apiParamsUpdated", this, values);
												}
											}
											// fire this even if we have global params since the app dispatch won't reach this tool
											if (corpus) {
												this.fireEvent("loadedCorpus", this, corpus);
											} else {
												this.fireEvent("apiParamsUpdated", this, values);
											}

											btn.up('window').close();
										}.bind(this));
									},
									scope: panel
								}]
							},
							bodyPadding: 5
						}).show()
					}
				} : undefined,
				help: {
					glyph: 'xf128@FontAwesome',
					fn: this.helpToolClick
				}
		}
		var tools = [];
		
		// check to see if there are tool objects configured
		if (config.includeTools) {
			for (var tool in config.includeTools) {
				if (typeof config.includeTools[tool] == "object") {
					tools.push(config.includeTools[tool])
				}
			}
		}
		
		
		for (var tool in toolsMap) {
			if (config.includeTools && !config.includeTools[tool] || !toolsMap[tool]) {continue;}
			tools.push({
				type: tool,
				tooltip: this.localize(tool+"Tip"),
				callback: toolsMap[tool].fn,
				xtype: 'toolmenu',
				glyph: toolsMap[tool].glyph,
				items: toolsMap[tool].items
			})
		}
		
		Ext.apply(this, {
			tools: tools
		})
		this.on("afterrender", function() {
			var header = this.getHeader();
			if (header && Ext.os.deviceType=="Desktop" && !this.isXType("corpuscreator") && !this.isXType('notebook')) {
				var el = header.getEl();
				el.on("mouseover", function() {
					this.getHeader().getTools().forEach(function(tool) {
						tool.show();
					})
				}, this);
				el.on("mouseout", function() {
					this.getHeader().getTools().forEach(function(tool) {
						var type = tool.config.type || tool.type; // auto-added tools don't have config.type
						if (type && type !== 'help') tool.hide();
					})
				}, this);
				header.getTools().forEach(function(tool,i) {
					if (tool.config.type !== 'help') tool.hide();
				});
			}
		}, this)
	},
	getMenuItemFromXtype: function(xtype) {
		var xt = xtype;
		var config = this.getApplication().getToolConfigFromToolXtype(xtype);
		if (config && config.tooltip) {
			delete config.tooltip // don't use this for now since it causes problems in the menu
		}
		return Ext.apply(Ext.clone(config), {
			xtype: 'menuitem',
			text: config.title,
			textAlign: 'left',
			handler: function() {this.replacePanel(config.xtype)},
			scope: this
		})
	},
	maximizeToolClick: function(panel) {
		var name = Ext.getClass(panel).getName();
		var parts = name.split(".");
		url = panel.getBaseUrl()+"tool/"+parts[parts.length-1]+"/";
		params = panel.getModifiedApiParams();
		if (!params.corpus && panel.getCorpus && panel.getCorpus()) {
			params.corpus = panel.getCorpus().getId();
		}
		if (params) {url += "?"+Ext.Object.toQueryString(params);}
		panel.openUrl(url);
	},
	exportToolClick: function(panel) {
		if (panel.isXType('voyanttabpanel')) {panel = panel.getActiveTab()}
		var items = window.location.hostname=='beta.voyant-tools.org' ? [{html: "<p class='keyword' style='text-align: center; font-weight: bold; padding: 4px;'>Please note that this is the beta server and you should not count on corpora persisting (for bookmarks, embedding, etc.)."}] : [];
		var exportViewItems = [{
       		xtype: 'radio',
       		name: 'export',
       		inputValue: 'embed',
       		boxLabel: panel.localize('exportViewHtmlEmbed')
       	},{
       		xtype: 'radio',
       		name: 'export',
       		inputValue: 'biblio',
       		boxLabel: panel.localize('exportViewBiblio')
       	},{
       		xtype: 'radio',
       		name: 'export',
       		inputValue: 'spyral',
       		boxLabel: panel.localize("exportViewSpyral")
       	}];
		if (panel.isXType('notebook')) {
			exportViewItems.splice(2, 1); // remove redundant spyral export for spyral notebooks
		}
		if (panel.getExtraViewExportItems) {
			panel.getExtraViewExportItems().forEach(function(item) {
				Ext.applyIf(item, {
					xtype: 'radio',
					name: 'export'
				})
				exportViewItems.push(item)
			})
		}
		items.push({
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'url',
	       		boxLabel: "<a href='"+panel.getExportUrl.call(panel)+"' target='_blank'>"+panel.localize('exportViewUrl')+"</a>",
	       		checked: true,
	       		listeners: {
	       			afterrender: function() {
	       				this.boxLabelEl.on("click", function() {
	       					this.up('window').close()
	       				}, this)
	       			}
	       		}
		},{
	       xtype: 'fieldset',
	       collapsible: true,
	       collapsed: true,
	       title: panel.localize('exportViewFieldset'),
	       items: exportViewItems
		})
		var exportDataItems = [];
		if (panel.isXType('grid')) {
			exportDataItems.push({
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'gridCurrentHtml',
	       		boxLabel: panel.localize('exportGridCurrentHtml')
	        },{
	       		xtype: 'radio',
	       		name: 'export',
	       		inputValue: 'gridCurrentTsv',
	       		boxLabel: panel.localize('exportGridCurrentTsv')
	        });
			if (!panel.getExportGridAll || panel.getExportGridAll()!=false) {
				exportDataItems.push({
		       		xtype: 'radio',
		       		name: 'export',
		       		inputValue: 'gridAllJson',
		       		boxLabel: panel.localize('exportGridAllJson')
	    	   },{
		       		xtype: 'radio',
		       		name: 'export',
		       		inputValue: 'gridAllTsv',
		       		boxLabel: panel.localize('exportGridAllTsv')
	    	   })
			}
		}
		if (panel.getExtraDataExportItems) {
			panel.getExtraDataExportItems().forEach(function(item) {
				Ext.applyIf(item, {
					xtype: 'radio',
					name: 'export'
				})
				exportDataItems.push(item)
			})
		}
		if (exportDataItems.length > 0) {
			items.push({
				xtype: 'fieldset',
				collapsible: true,
				collapsed: true,
				title: panel.localize('exportGridCurrent'),
				items: exportDataItems
			 });
		}
		if ((!panel.getExportVisualization || panel.getExportVisualization()) && panel.isXType("grid")==false && (panel.down("chart") || panel.getTargetEl().dom.querySelector("canvas") || panel.getTargetEl().dom.querySelector("svg"))) {
			var formats = [{
				xtype: 'radio',
				name: 'export',
				inputValue: 'png',
				boxLabel: panel.localize('exportPng')
			},{
				xtype: 'slider',
				width: 200,
				value: 1,
				minValue: .5,
				maxValue: 10,
				increment: .5,
				labelAlign: 'right',
				decimalPrecision: 1,
				itemId: 'scale',
				fieldLabel: new Ext.Template(panel.localize("scaleLabel")).apply([1]),
				listeners: {
					change: function(slider, newVal) {
						this.setFieldLabel(new Ext.Template(panel.localize("scaleLabel")).apply([newVal]))
					},
					changecomplete: function(slider) {
						slider.previousSibling().setValue(true); // make sure PNG is selected
					}
				}
			}];
			if (panel.getTargetEl().dom.querySelector("svg")) {
				formats.push({
					xtype: 'radio',
					name: 'export',
					inputValue: 'svg',
					boxLabel: panel.localize('exportSvg')
				})
			}
			items.push({
			       xtype: 'fieldset',
			       collapsible: true,
			       collapsed: true,
			       title: panel.localize('exportVizTitle'),
		    	   items: formats
	    	});
		}
		Ext.create('Ext.window.Window', {
			title: panel.localize("exportTitle"),
			modal: true,
			items: {
				xtype: 'form',
				items: items,
				buttons: [{
	            	text: panel.localize("exportTitle"),
					glyph: 'xf08e@FontAwesome',
	            	flex: 1,
	            	panel: panel,
	        		handler: function(btn) {
	        			var form = btn.up('form');
	        			var fn = 'export'+Ext.String.capitalize(form.getValues()['export']);
	        			if (Ext.isFunction(panel[fn])) {
	        				panel[fn].call(panel, panel, form)
	        			}
	        			else {
	        				Ext.Msg.show({
	        				    title: panel.localize('exportError'),
	        				    message: panel.localize('exportNoFunction'),
	        				    buttons: Ext.Msg.OK,
	        				    icon: Ext.Msg.ERROR
	        				});
	        			}
	        			btn.up('window').close();
	        		},
	        		scope: panel
	            }, {
	            	text: panel.localize("cancelTitle"),
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				}]
			},
			bodyPadding: 5
		}).show()
	},
	exportSvg: function(img) {
		var svg = this.getTargetEl().dom.querySelector("svg");
		if (svg) {
			var html = d3.select(svg)
				.attr("version", 1.1)
				.attr("xmlns", "http://www.w3.org/2000/svg")
				.node().parentNode.innerHTML
			Ext.Msg.show({
			    title: this.localize('exportSvgTitle'),
			    message: '<img src="'+'data:image/svg+xml;base64,'+ btoa(unescape(encodeURIComponent(html)))+'" style="float: right; max-width: 200px; max-height: 200px; border: thin dotted #ccc;"/>'+this.localize('exportSvgMessage'),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.INFO,
			    prompt: true,
		        multiline: true,
		        value: html
			});		
		}
	},
	exportPngData: function(img) {
		Ext.Msg.show({
		    title: this.localize('exportPngTitle'),
		    message: '<img class="thumb" src="'+img+'" style="float: right; max-width: 200px; max-height: 200px; border: thin dotted #ccc;"/>'+this.localize('exportPngMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: '<img src="'+img+'" />'
		});
	},
	exportPng: function(panel, form) {
		var scale = 1;
		if (form) {
			form.mask(panel.localize('loading'));

			var slider = form.queryById("scale");
			if (slider && slider.getValue) {
				scale = slider.getValue();
			}
		}
		
		var canvasSurface = this.down('draw') || this.down('chart');
		if (canvasSurface && (canvasSurface.isChart || canvasSurface.isCanvas)) {

			// first part taken from EXTJ Draw.getImage()
			// http://docs.sencha.com/extjs/6.2.0/classic/src/Container.js-2.html#Ext.draw.Container-method-getImage
			// reproduced here because we want to scale the image in the canvas, not the final image
			var size = canvasSurface.innerElement.getSize(),
            		surfaces = Array.prototype.slice.call(canvasSurface.items.items),
            		zIndexes = canvasSurface.surfaceZIndexes,
            		image, imageElement,
            		i, j, surface, zIndex;
 
	        // Sort the surfaces by zIndex using insertion sort. 
	        for (j = 1; j < surfaces.length; j++) {
	            surface = surfaces[j];
	            zIndex = zIndexes[surface.type];
	            i = j - 1;
	            while (i >= 0 && zIndexes[surfaces[i].type] > zIndex) {
	                surfaces[i + 1] = surfaces[i];
	                i--;
	            }
	            surfaces[i + 1] = surface;
	        }
	        
	        // next part taken from EXTJS Canvas Flatten
	        // http://docs.sencha.com/extjs/6.2.0/classic/src/Canvas.js-1.html#line897
	        // reproduced here because we want to scale the image when drawing to the new canvas
	        
	        var targetCanvas = document.createElement('canvas'),
            className = Ext.getClassName(surfaces[0]),
            ratio = surfaces[0].devicePixelRatio * scale,
            ctx = targetCanvas.getContext('2d'),
            surface, canvas, rect, i, j, xy;

	        targetCanvas.width = Math.ceil(size.width * ratio);
	        targetCanvas.height = Math.ceil(size.height * ratio);
	
	        
	        for (i = 0; i < surfaces.length; i++) {
	            surface = surfaces[i];
	            if (Ext.getClassName(surface) !== className) {
	                continue;
	            }
	            rect = surface.getRect();
	            surfaceSize = surface.el.getSize();
	            for (j = 0; j < surface.canvases.length; j++) {
	                canvas = surface.canvases[j];
	                xy = canvas.getOffsetsTo(canvas.getParent());
	                ctx.drawImage(canvas.dom, (rect[0] + xy[0]) * ratio, (rect[1] + xy[1]) * ratio, surfaceSize.width*ratio,surfaceSize.height*ratio);
	            }
	        }
	        if (form && form.isVisible()) {form.unmask();}
	        
	        // now we're ready
			return this.exportPngData(targetCanvas.toDataURL());
		}
		
//		var chart = this.down('chart'); // first try finding a chart
//		if (chart) {
//			return this.exportPngData(this.down('chart').getImage().data);
//		}
//
		var targetEl = this.getTargetEl().dom,
			canvas = targetEl.querySelector("canvas"); // next try finding a canvas
		if (canvas) {
			if (scale==1) {
				var data = canvas.toDataURL("image/png");
		        if (form && form.isVisible()) {form.unmask();}
				return this.exportPngData(data);
			}
	        var targetCanvas = document.createElement('canvas'),
            ctx = targetCanvas.getContext('2d');
	        targetCanvas.width = Math.ceil(canvas.width * scale);
	        targetCanvas.height = Math.ceil(canvas.height * scale);

			  var image = new Image;
			  image.src = canvas.toDataURL("image/png");
			  image.panel = this;
			  image.onload = function() {
				  ctx.drawImage(image, 0, 0, targetCanvas.width, targetCanvas.height);
				  img = targetCanvas.toDataURL("image/png");
			        if (form && form.isVisible()) {form.unmask();}
				  this.panel.exportPngData.call(this.panel, img);
			  };	
			  return;
		}
		
		var svg = targetEl.querySelector("svg"); // finally try finding an SVG
		if (svg) {
			var width = targetEl.offsetWidth*scale,
				height = targetEl.offsetHeight*scale;
			var clone = svg.cloneNode(true); // we don't want to scale, etc. the original
			clone.setAttribute("version", 1.1)
			clone.setAttribute("xmlns", "http://www.w3.org/2000/svg")
			clone.setAttribute("width", width)
			clone.setAttribute("height", height)

			var svgChildren = [];
			while (clone.children.length > 0) {
				svgChildren.push(clone.removeChild(clone.children[0]));
			};

			var g = document.createElement('g');
			g.setAttribute("style", "transform-box: fill-box;");
			g.setAttribute("transform", "scale("+scale+")")
			clone.appendChild(g);

			svgChildren.forEach(function(item) {
				g.appendChild(item);
			})

			var html = clone.outerHTML,
				img = 'data:image/svg+xml;base64,'+ btoa(unescape(encodeURIComponent(html)));

			var canvas = Ext.DomHelper.createDom({tag:'canvas',width: width,height:height}),
				context = canvas.getContext("2d");
			  
			var image = new Image;
			image.src = img;
			image.panel = this;
			image.onload = function() {
				context.drawImage(image, 0, 0);
				img = canvas.toDataURL("image/png");
		        if (form && form.isVisible()) {form.unmask();}
				return this.panel.exportPngData.call(this.panel, img);
			};
			// image.onerror = function(ev) {
			// 	console.log(ev)
			// }
		}
	},
	exportUrl: function() {
		this.openUrl(this.getExportUrl());
	},
	exportEmbed: function() {
		var asTool = this.isXType('voyantheader')==false;
		Ext.Msg.show({
		    title: this.localize('exportViewEmbedTitle'),
		    message: this.localize('exportViewEmbedMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: "<!--	Exported from Voyant Tools (voyant-tools.org).\n"+
	        	"The iframe src attribute below uses a relative protocol to better function with both\n"+
	        	"http and https sites, but if you're embedding this into a local web page (file protocol)\n"+
	        	"you should add an explicit protocol (https if you're using voyant-tools.org, otherwise\n"+
	        	"it depends on this server.\n"+
	        	"Feel free to change the height and width values or other styling below: -->\n"+
	        	"<iframe style='width: "+(asTool ? this.getWidth()+"px" : "100%")+"; height: "+(asTool ? this.getHeight()+"px" : "800px")+";' src='"+this.getExportUrl(asTool)+"'></iframe>"
		});
	},
	exportBiblio: function() {
		var date = new Date();
		var url = this.getExportUrl();
		var websiteTitle = this.isXType('voyantheader') ? 'Voyant Tools' : this.localize('title');
		var msg = Ext.Msg.show({
		    title: this.localize('exportBiblioTitle'),
			minHeight: 525,
		    message: '<fieldset><legend>MLA</legend>'+
	    	'<div class="x-selectable">Sinclair, Stéfan and Geoffrey Rockwell. "'+websiteTitle+'." '+
	    	'<i>Voyant Tools</i>. '+Ext.Date.format(date,'Y')+'. Web. '+Ext.Date.format(date,'j M Y')+'. &lt;'+url+'&gt;.</div></fieldset>'+
	    	'<br >'+
	    	'<fieldset><legend>Chicago</legend>'+
	    	'<div class="x-selectable">Stéfan Sinclair and Geoffrey Rockwell, "'+websiteTitle+'", '+
	    	'<i>Voyant Tools</i>, accessed '+Ext.Date.format(date,'F j, Y')+', '+url+'.</div></fieldset>'+
	    	'<br >'+
	    	'<fieldset><legend>APA</legend>'+
	    	'<div class="x-selectable">Sinclair, S. &amp; G. Rockwell. ('+Ext.Date.format(date,'Y')+"). "+websiteTitle+'. '+
	    	'<i>Voyant Tools</i>. Retrieved '+Ext.Date.format(date,'F j, Y')+', from '+url+'</div></fieldset>'+
			'<br >'+
			'<fieldset><legend>BibTeX</legend>'+
			'<div class="x-selectable">'+this.getExportBibTex()+'</div></fieldset>',
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO
		});
		msg.getEl().query('fieldset > div', false).forEach(function(el) {
			el.on('click', function(evt, el) {
				var doc = window.document, sel, range;
				if (window.getSelection && doc.createRange) {
					sel = window.getSelection();
					range = doc.createRange();
					range.selectNodeContents(el);
					sel.removeAllRanges();
					sel.addRange(range);
				} else if (doc.body.createTextRange) {
					range = doc.body.createTextRange();
					range.moveToElementText(el);
					range.select();
				}
			});
		});
	},
	exportSpyral: function() {
		let toolForUrl = Ext.getClassName(this).split(".").pop();
		let api = this.getApplication().getModifiedApiParams();
		if (this.isXType('voyantheader')==false) {
			delete api.panels; // not needed for individual tools
			// add (and overwrite if need be) this tool's api
			Ext.apply(api, this.getModifiedApiParams());
			delete api.corpus;
		}
		let isDebug = api && "debug" in api;
		delete api.view;
		delete api.debug;
		let enc = function(str) {
			return btoa(encodeURIComponent(str)).replace(/=/g, "%3D");
		}
		let input = "['<h1>Spyral Notebook Imported from Voyant Tools</h1>',"+
			"'<p>The proceeding code loads your corpus and tool. You can use this as a base to create your own notebook. Don\\'t forget to save your changes by clicking on the cloud icon!</p>','"+
			'loadCorpus("'+this.getApplication().getCorpus().getAliasOrId()+'").tool("'+
			(toolForUrl=="VoyantHeader" ? "" : toolForUrl)+'"'+(Object.keys(api).length>0 ? (","+Ext.encode(api)) : "")+ ");']"
		this.openUrl(this.getApplication().getBaseUrl()+"spyral/?run=true&"+(isDebug ? "debug=true&" : "")+"inputJsonArrayOfEncodedBase64="+enc(input));
	},
	exportGridCurrentJson: function(grid, form) {
		var store = grid.getStore();
		var fields = store.getFields();
		var value = "<table>\n\t<thead>\n\t\t<tr>\n";
		var visibleColumns = grid.getColumnManager().headerCt.getVisibleGridColumns().filter(function(col) { return col.dataIndex && col.dataIndex.trim().length > 0 });
		values = [];

		function jsonCollector(row) {
			var val = {};
			visibleColumns.forEach(function (column) {
				val[column.text] = row.get(column.dataIndex);
			});
			values.push(val);
		}

		if (store.buffered) {
			store.data.forEach(jsonCollector);
		} else {
			store.each(jsonCollector);
		}

		Ext.Msg.show({
		    title: this.localize('exportDataTitle'),
		    message: this.localize('exportDataJsonMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: Ext.encode(values)
		});
	},
	exportGridCurrentTsv: function(grid, form) {
		var store = grid.getStore();
		var visibleColumns = grid.getColumnManager().headerCt.getVisibleGridColumns().filter(function(col) { return col.dataIndex && col.dataIndex.trim().length > 0 });
		var fields = [];
		visibleColumns.forEach(function(column) {
			fields.push(column.text);
		})
		var value = fields.join("\t")+"\n";

		function tsvCollector(row) {
			var cells = [];
			visibleColumns.forEach(function (column) {
				var val = row.get(column.dataIndex);
				if (Ext.isString(val)) {
					val = val.replace(/\s+/g, ' '); // get rid of multiple whitespace (including newlines and tabs)
				}
				cells.push(val)
			});
			value += cells.join("\t") + "\n";
		}

		if (store.buffered) {
			store.data.forEach(tsvCollector);
		} else {
			store.each(tsvCollector);
		}

		Ext.Msg.show({
		    title: this.localize('exportDataTitle'),
		    message: this.localize('exportDataTsvMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: value
		});
	},
	exportGridCurrentHtml: function(grid, form) {
		var store = grid.getStore();
		var fields = store.getFields();
		var value = "<table>\n\t<thead>\n\t\t<tr>\n";
		var visibleColumns = grid.getColumnManager().headerCt.getVisibleGridColumns().filter(function(col) { return col.dataIndex && col.dataIndex.trim().length > 0 });
		visibleColumns.forEach(function(column) {
			value+="\t\t\t<td>"+column.text+"</td>\n";
		});

		value+="\t\t</tr>\n\t</thead>\n\t<tbody>\n";

		function htmlCollector(row) {
			value += "\t\t<tr>\n";
			visibleColumns.forEach(function (column) {
				var val = row.get(column.dataIndex);
				if (Ext.isString(val)) {
					val = val.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&lg;');
				}
				value += "\t\t\t<td>" + val + "</td>\n";
			});
			value += "\t\t</tr>\n";
		}

		if (store.buffered) {
			store.data.forEach(htmlCollector);
		} else {
			store.each(htmlCollector);
		}

		value+="\t</tbody>\n</table>";
		Ext.Msg.show({
		    title: this.localize('exportDataTitle'),
		    message: this.localize('exportDataHtmlMessage'),
		    buttons: Ext.Msg.OK,
		    icon: Ext.Msg.INFO,
		    prompt: true,
	        multiline: true,
	        value: value
		});
	},
	exportGridAllJson: function(grid, form) {
		Ext.Msg.confirm(this.localize('exportAllTitle'), this.localize('exportAllJsonWarning'), function(btn) {
			if (btn=='yes') {
				var params = {start: 0};
				Ext.applyIf(params, grid.getStore().getProxy().getExtraParams());
				this.openUrl(this.getTromboneUrl()+"?"+Ext.Object.toQueryString(params));
			}
		}, this)
	},
	exportGridAllTsv: function(grid, form) {
		Ext.Msg.confirm(this.localize('exportAllTitle'), this.localize('exportAllTsvWarning'), function(btn) {
			if (btn=='yes') {
				var params = {start: 0, template: this.getXType()+"2tsv", outputFormat: 'text'};
				Ext.applyIf(params, grid.getStore().getProxy().getExtraParams());
				this.openUrl(this.getTromboneUrl()+"?"+Ext.Object.toQueryString(params));
			}
		}, this)
	},
	getExportUrl: function(asTool) {
		// start with the application api
		var api = this.getApplication().getModifiedApiParams();
		var toolForUrl = Ext.getClassName(this).split(".").pop();
		if (this.isXType('voyantheader')==false) {
			delete api.panels; // not needed for individual tools
			// add (and overwrite if need be) this tool's api
			Ext.apply(api, this.getModifiedApiParams());
			if (!asTool) {api.view=toolForUrl;}
		}
		if (!api.corpus) {
			api.corpus = this.getApplication().getCorpus().getAliasOrId();
		}
		return this.getApplication().getBaseUrl()+(asTool ? "tool/"+toolForUrl+"/" : "")+'?'+Ext.Object.toQueryString(api);
	},
	getExportBibTex: function() {
		var url = this.getExportUrl();
		var corpus = this.getApplication().getCorpus();
		
		var websiteTitle = this.isXType('voyantheader') ? 'Voyant Tools' : this.localize('title');

		var abstract = 'Voyant Tools analysis of ';
		if (corpus.getTitle() === '') {
			abstract += 'a corpus';
		} else {
			abstract += 'the corpus "'+corpus.getTitle()+'"';
		}
		if (this.isXType('voyantheader') === false) {
			abstract += ' using the '+this.localize('title')+' tool';
		}

		var now = new Date();
		var accessed = Ext.Date.format(now,'Y-m-d');
		var createdTime = new Date(this.getApplication().getCorpus().getCreatedTime());

		var lang = this.getApiParam('lang') || 'en';		

		var citekey = 'voyanttools_'+now.getTime();
		
		var bib = ['@misc{'+citekey+','];
		bib.push('title = {'+websiteTitle+'},');
		bib.push('author = {Sinclair, Stéfan and Rockwell, Geoffrey},');
		bib.push('year = '+createdTime.getFullYear()+',');
		bib.push('url = {'+url+'},');
		bib.push('urldate = {'+accessed+'},');
		bib.push('publisher = {Voyant Tools},');
		bib.push('copyright = {CC BY 4.0},');
		bib.push('abstract = {'+abstract+'},');
		bib.push('language = {'+lang+'},');
		
		return bib.join('<br/>&nbsp;&nbsp;') + '<br/>}';
	},
	helpToolClick: function(panel) {
		if (panel.isXType('voyanttabpanel')) {panel = panel.getActiveTab()}
		var help = panel.localize('help', {"default": false}) || panel.localize('helpTip');
		if (help==panel._localizeClass(Ext.ClassManager.get("Voyant.util.Toolable"), "helpTip")) {
			panel.openUrl( panel.getBaseUrl()+"docs/#!/guide/" + panel.getXType());
		}
		else {
			Ext.Msg.alert(panel.localize('title'), help +"<p><a href='"+panel.getBaseUrl()+
					"docs/"+ (panel.isXType('voyantheader') ? '' : "#!/guide/"+panel.getXType()) +"' target='voyantdocs'>"+panel.localize("moreHelp")+"</a></p>")
		}
	},
	replacePanel: function(xtype) {
		var corpus = this.getApplication().getCorpus();
		var config = this.getInitialConfig();
		var parent;
		if (this.isXType('voyantheader') && this.getApplication().getViewComponent) {
			parent = this.getApplication().getViewComponent();
			parent.removeAll(true);
			var newTool = parent.add({xtype: xtype});
			if (corpus) {
				this.getApplication().dispatchEvent("loadedCorpus", parent, corpus);
			}
			
			var queryParams = Ext.Object.fromQueryString(document.location.search);
			var url = this.getApplication().getBaseUrl();
			url += '?corpus='+corpus.getAliasOrId();
			url += '&view='+xtype;
			for (var key in queryParams) {
				if (key !== 'corpus' && key !== 'view') {
					url += '&'+key+'='+queryParams[key];
				}
			}
			window.history.pushState({
				corpus: corpus.getAliasOrId(),
				view: xtype
			}, '', url);
		}
		else {
			parent = this.isXType('voyantheader') && this.getApplication().getViewComponent ? this.getApplication().getViewComponent() : this.up("component");
			parent.remove(this, true);
			var newTool = parent.add({xtype: xtype});
			if (parent.isXType("voyanttabpanel")) {
				parent.setActiveTab(newTool)
			}
			if (corpus) {
				newTool.fireEvent("loadedCorpus", newTool, corpus)
			}
		}
		this.getApplication().dispatchEvent('panelChange', this)
	}
});

// from http://www.sencha.com/forum/showthread.php?281658-add-dropdown-menu-to-panel-tool&p=1054579&viewfull=1#post1054579
// and http://www.sencha.com/forum/showthread.php?281953-Glyphs-in-panel-tool&p=1068934&viewfull=1#post1068934

Ext.define('Voyant.util.ToolMenu', {
    extend: 'Ext.panel.Tool',
    alias: 'widget.toolmenu',
    renderTpl: ['<div class="x-menu-tool-hover">' + '</div>'+
            '<tpl if="glyph">' + 
            '<span id="{id}-toolEl" class="{baseCls}-glyph {childElCls}" role="presentation" style="font-family: {glyphFontFamily}; '+
            	'<tpl if="Ext.os.name==\'iOS\'">'+ // FIXME: this is an awful hack..
            		'margin-right: 15px; '+
            	'</tpl>'+
            '">&#{glyph}</span>' + 
            '<tpl else>' + 
            '<img id="{id}-toolEl" src="{blank}" class="{baseCls}-img {baseCls}-{type}' + '{childElCls}" role="presentation"/>' + 
            '</tpl>'],
    privates: {
        onClick: function() {
            var me = this;
            var returnValue = me.callParent(arguments);

			if (returnValue) {
                me.showToolMenu.call(me);
            }

            return returnValue;
        },
        onDestroy: function() {
            Ext.destroyMembers(this, 'toolMenu'); //destructor
            this.callParent();
        }
    },
	showToolMenu: function() {
		if (this.items && this.items.length > 0) {
			if (!this.toolMenu || this.toolMenu.destroyed) {
				this.toolMenu = new Ext.menu.Menu({
					items: this.items
				});
			}
			this.toolMenu.showAt(0, 0);
			this.toolMenu.showAt(this.getX() + this.getWidth() - this.toolMenu.getWidth(), this.getY() + this.getHeight() + 10);
		}
	},
	initComponent: function() {
	    var me = this;
	    me.callParent(arguments);
	
	    var glyph, glyphParts, glyphFontFamily;
	    glyph = me.glyph || 'xf12e@FontAwesome';
	
	    if (glyph) {
	        if (typeof glyph === 'string') {
	            glyphParts = glyph.split('@');
	            glyph = glyphParts[0];
	            glyphFontFamily = glyphParts[1];
	        } else if (typeof glyph === 'object' && glyph.glyphConfig) {
	            glyphParts = glyph.glyphConfig.split('@');
	            glyph = glyphParts[0];
	            glyphFontFamily = glyphParts[1];
	        }
	
	
	        Ext.applyIf(me.renderData, {
	            baseCls: me.baseCls,
	            blank: Ext.BLANK_IMAGE_URL,
	            type: me.type,
	            glyph: glyph,
	            glyphFontFamily: glyphFontFamily
	        });
	    }
	}

});

Ext.define("Voyant.util.Transferable", {
	transferable: ['transfer'],
	transfer: function(source, destination) {
		if (source.transferable) {
			for (var i=0;i<source.transferable.length;i++) {
				var member = source.transferable[i];
				destination[member] = Ext.bind(source[member], destination);
			}
		}
		if (source.mixins) {
			for (mixin in source.mixins) {
				this.transfer(source.mixins[mixin], destination)
			}
		}
	}
})
Ext.define("Voyant.util.Variants", {
	extend: 'Ext.Base',
	constructor: function(variants) {
		this.variants = variants;
		this.map = {};
		this.variants.forEach(function(variant, index) {
			variant.forEach(function(v) {
				this.map[v]=index;
			}, this)
		}, this)
	},
	getVariants: function(terms) {
		var variants = [];
		if (Ext.isString(terms)) {terms = [terms]}
		if (Ext.isArray(terms)) {
			terms.forEach(function(term) {
				if (this.map[term]!=undefined) {
					variants.push.apply(variants, this.variants[this.map[term]]);
				}
			}, this)
		}
		return variants
	}
})
Ext.define("Voyant.util.Downloadable", {
	mixins: ['Voyant.util.Localization'],
	statics: {
		i18n: {
		},
		api: {
			documentFormat: undefined,
			documentFilename: undefined
		}
	},

	downloadFromCorpusId: function(corpusId) {
		var panel = this;
		Ext.create('Ext.window.Window', {
			title: this.localize('exportTitle'),
			modal: true,
			items: {
				xtype: 'form',
				items: {xtype: 'downloadoptions'},
				listeners: {
					afterrender: function(form) {
						// make sure defaults are set based on panel's API
						form.getForm().setValues(panel.getApiParams(['documentFilename','documentFormat']));
						
					}
				},
				buttons: [{
	            	text: this.localize("cancelButton"),
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
		            ui: 'default-toolbar',
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize('downloadButton'),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var values = btn.up('form').getValues();
	        			panel.setApiParams(values);
	        			panel.openDownloadCorpus(corpusId);
	        			btn.up('window').close();
	        		},
	        		scope: this
	            }]
			},
			bodyPadding: 5
		}).show()
	},
	
    openDownloadCorpus: function(corpusId) {
		var url = this.getTromboneUrl()+"?corpus="+corpusId+"&tool=corpus.CorpusExporter&outputFormat=zip"+
			"&zipFilename=DownloadedVoyantCorpus-"+corpusId+".zip"+
			(this.getApiParam("documentFormat") ? "&documentFormat="+this.getApiParam("documentFormat") : '')+
			(this.getApiParam("documentFilename") ? "&documentFilename="+this.getApiParam("documentFilename") : '')
		this.openUrl(url)
    }
})
Ext.define('Voyant.util.Storage', {
	MAX_LENGTH: 950000, // keep it under 1 megabyte
	
	storeResource: function(id, data) {
		var dataString = Ext.encode(data);
		
		if (dataString.length > this.MAX_LENGTH) {
			// split into chunks
			var dfd = new Ext.Deferred();
			
			var numChunks = Math.ceil(dataString.length / this.MAX_LENGTH);
			
			var chunkIds = [];
			for (var i = 0; i < numChunks; i++) {
				chunkIds.push(id+'-chunk'+i);
			}
			this._doStore(id+'-hasChunks', Ext.encode(chunkIds)).then(function() {
				var chunkCount = 0;
				var currIndex = 0;
				for (var i = 0; i < numChunks; i++) {
					var chunkString = dataString.substr(currIndex, this.MAX_LENGTH);
					
					this._doStore(chunkIds[i], chunkString).then(function() {
						chunkCount++;
						if (chunkCount == numChunks) {
							dfd.resolve();
						}
					}, function() {
						dfd.reject();
					}, null, this);
					
					currIndex += this.MAX_LENGTH;
				}
			}, function() {
				dfd.reject();
			}, null, this);
			
			return dfd.promise;
		} else {
			return this._doStore(id, dataString);
		}
	},
	
	_doStore: function(id, dataString) {
		var dfd = new Ext.Deferred();
		Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                resourceId: id,
                storeResource: dataString
            }
        }).then(function(response) {
            dfd.resolve();
        }, function(response) {
            dfd.reject();
        });
		
		return dfd.promise;
	},
	
	getStoredResource: function(id) {
		var dfd = new Ext.Deferred();
		
		Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                verifyResourceId: id+'-hasChunks'
            }
        }).then(function(response) {
        	var json = Ext.decode(response.responseText);
        	if (json && json.storedResource && json.storedResource.id && json.storedResource.id != '') {
            	// chunks
            	this._doGetStored(json.storedResource.id, false).then(function(chunkIds) {
            		var fullData = '';
                    var dataChunks = {};
	            	for (var i = 0; i < chunkIds.length; i++) {
	            		this._doGetStored(chunkIds[i], true).then(function(response) {
	            			var chunkId = response[0];
	            			var value = response[1];
	            			dataChunks[chunkId] = value;
	            			
	            			var done = true;
	            			for (var j = chunkIds.length-1; j >= 0; j--) {
	            				if (dataChunks[chunkIds[j]] === undefined) {
	            					done = false;
	            					break;
	            				}
	            			}
	            			
	            			if (done) {
	            				for (var j = 0; j < chunkIds.length; j++) {
	            					fullData += dataChunks[chunkIds[j]];
	            				}
	            				dfd.resolve(Ext.decode(fullData));
	            			}
	            		}, function() {
	                        dfd.reject();
	                    }, null, this);
	            	}
            	}, function() {
            		dfd.reject();
            	}, null, this);
        	} else {
            	// no chunks
				this._doGetStored(id, false).then(function(value) {
					dfd.resolve(value);
				}, function() {
					dfd.reject();
				}, null, this);
        	}
        }, function() {
        	dfd.reject();
        }, null, this);
		
		return dfd.promise;
	},
	
	_doGetStored: function(id, isChunk) {
		var dfd = new Ext.Deferred();
		
		Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                retrieveResourceId: id,
                failQuietly: true
            }
        }).then(function(response) {
        	var json = Ext.decode(response.responseText);
        	var id = json.storedResource.id;
        	var value = json.storedResource.resource;
        	if (value.length == 0) {
        		dfd.reject();
        	} else {
	        	if (isChunk != true) {
	        		value = Ext.decode(value);
	        		dfd.resolve(value);
	        	} else {
	        		dfd.resolve([id, value]);
	        	}
        	}
        }, function() {
        	dfd.reject();
        }, null, this);
		
		return dfd.promise;
	}
});

/*
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
Ext.define("Voyant.util.DiacriticsRemover", {
    diacriticsMap: {},
    
    constructor: function() {
        var defaultDiacriticsRemovalMap = [
            {'base':'A', 'letters':'\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F'},
            {'base':'AA','letters':'\uA732'},
            {'base':'AE','letters':'\u00C6\u01FC\u01E2'},
            {'base':'AO','letters':'\uA734'},
            {'base':'AU','letters':'\uA736'},
            {'base':'AV','letters':'\uA738\uA73A'},
            {'base':'AY','letters':'\uA73C'},
            {'base':'B', 'letters':'\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181'},
            {'base':'C', 'letters':'\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E'},
            {'base':'D', 'letters':'\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779\u00D0'},
            {'base':'DZ','letters':'\u01F1\u01C4'},
            {'base':'Dz','letters':'\u01F2\u01C5'},
            {'base':'E', 'letters':'\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E'},
            {'base':'F', 'letters':'\u0046\u24BB\uFF26\u1E1E\u0191\uA77B'},
            {'base':'G', 'letters':'\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E'},
            {'base':'H', 'letters':'\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D'},
            {'base':'I', 'letters':'\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197'},
            {'base':'J', 'letters':'\u004A\u24BF\uFF2A\u0134\u0248'},
            {'base':'K', 'letters':'\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2'},
            {'base':'L', 'letters':'\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780'},
            {'base':'LJ','letters':'\u01C7'},
            {'base':'Lj','letters':'\u01C8'},
            {'base':'M', 'letters':'\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C'},
            {'base':'N', 'letters':'\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4'},
            {'base':'NJ','letters':'\u01CA'},
            {'base':'Nj','letters':'\u01CB'},
            {'base':'O', 'letters':'\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C'},
            {'base':'OI','letters':'\u01A2'},
            {'base':'OO','letters':'\uA74E'},
            {'base':'OU','letters':'\u0222'},
            {'base':'OE','letters':'\u008C\u0152'},
            {'base':'oe','letters':'\u009C\u0153'},
            {'base':'P', 'letters':'\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754'},
            {'base':'Q', 'letters':'\u0051\u24C6\uFF31\uA756\uA758\u024A'},
            {'base':'R', 'letters':'\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782'},
            {'base':'S', 'letters':'\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784'},
            {'base':'T', 'letters':'\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786'},
            {'base':'TZ','letters':'\uA728'},
            {'base':'U', 'letters':'\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244'},
            {'base':'V', 'letters':'\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245'},
            {'base':'VY','letters':'\uA760'},
            {'base':'W', 'letters':'\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72'},
            {'base':'X', 'letters':'\u0058\u24CD\uFF38\u1E8A\u1E8C'},
            {'base':'Y', 'letters':'\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE'},
            {'base':'Z', 'letters':'\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762'},
            {'base':'a', 'letters':'\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250'},
            {'base':'aa','letters':'\uA733'},
            {'base':'ae','letters':'\u00E6\u01FD\u01E3'},
            {'base':'ao','letters':'\uA735'},
            {'base':'au','letters':'\uA737'},
            {'base':'av','letters':'\uA739\uA73B'},
            {'base':'ay','letters':'\uA73D'},
            {'base':'b', 'letters':'\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253'},
            {'base':'c', 'letters':'\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184'},
            {'base':'d', 'letters':'\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A'},
            {'base':'dz','letters':'\u01F3\u01C6'},
            {'base':'e', 'letters':'\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD'},
            {'base':'f', 'letters':'\u0066\u24D5\uFF46\u1E1F\u0192\uA77C'},
            {'base':'g', 'letters':'\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F'},
            {'base':'h', 'letters':'\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265'},
            {'base':'hv','letters':'\u0195'},
            {'base':'i', 'letters':'\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131'},
            {'base':'j', 'letters':'\u006A\u24D9\uFF4A\u0135\u01F0\u0249'},
            {'base':'k', 'letters':'\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3'},
            {'base':'l', 'letters':'\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747'},
            {'base':'lj','letters':'\u01C9'},
            {'base':'m', 'letters':'\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F'},
            {'base':'n', 'letters':'\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5'},
            {'base':'nj','letters':'\u01CC'},
            {'base':'o', 'letters':'\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275'},
            {'base':'oi','letters':'\u01A3'},
            {'base':'ou','letters':'\u0223'},
            {'base':'oo','letters':'\uA74F'},
            {'base':'p','letters':'\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755'},
            {'base':'q','letters':'\u0071\u24E0\uFF51\u024B\uA757\uA759'},
            {'base':'r','letters':'\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783'},
            {'base':'s','letters':'\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B'},
            {'base':'t','letters':'\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787'},
            {'base':'tz','letters':'\uA729'},
            {'base':'u','letters': '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289'},
            {'base':'v','letters':'\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C'},
            {'base':'vy','letters':'\uA761'},
            {'base':'w','letters':'\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73'},
            {'base':'x','letters':'\u0078\u24E7\uFF58\u1E8B\u1E8D'},
            {'base':'y','letters':'\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF'},
            {'base':'z','letters':'\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763'}
        ];
        
        this.diacriticsMap = {};
        for (var i=0; i < defaultDiacriticsRemovalMap .length; i++){
            var letters = defaultDiacriticsRemovalMap [i].letters;
            for (var j=0; j < letters.length ; j++){
                this.diacriticsMap[letters[j]] = defaultDiacriticsRemovalMap [i].base;
            }
        }
    },
    
    // "what?" version ... http://jsperf.com/diacritics/12
    removeDiacritics: function(str) {
        return str.replace(/[^\u0000-\u007E]/g, function(a){
            return this.diacriticsMap[a] || a; 
        }.bind(this));
    }

});
Ext.define('Voyant.data.model.AnalysisToken', {
    extend: 'Ext.data.Model',
    idProperty: 'term',
    fields: [
         {name: 'term'},
         {name: 'rawFreq', type: 'int'},
         {name: 'relativeFreq', type: 'number'},
         {name: 'cluster', type: 'int'},
         {name: 'clusterCenter', type: 'boolean'},
         {name: 'vector'}
    ]
});
Ext.define('Voyant.data.model.Context', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'docIndex', 'type': 'int'},
             {name: 'position', 'type': 'int'},
             {name: 'docId'},
             {name: 'left'},
             {name: 'keyword'},
             {name: 'term'},
             {name: 'right'}
        ],

        getDocIndex: function() {return this.get("docIndex")},
        getLeft: function() {return this.get("left")},
        getMiddle: function() {return this.get("middle")},
        getHighlightedMiddle: function() {return "<span class='keyword'>"+this.getMiddle()+"</span>"},
        getRight: function() {return this.get("right")},
        getPosition: function() {return this.get("position")},
        getHighlightedContext: function() {return this.getLeft()+this.getHighlightedMiddle()+this.getRight();}
	
});
Ext.define('Voyant.data.model.CorpusFacet', {
    extend: 'Ext.data.Model',
    idProperty: 'label',
    fields: [
             {name: 'facet'},
             {name: 'label'},
             {name: 'inDocumentsCount', type: 'int'}
    ],
    getLabel: function() {
    	return this.get('label')
    },
    getFacet: function() {
    	return this.get('facet')
    },
	getInDocumentsCount: function() {
		return this.get('inDocumentsCount')
	}
});
Ext.define('Voyant.data.model.CorpusCollocate', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'term'},
             {name: 'rawFreq', type: 'int'},
             {name: 'contextTerm'},
             {name: 'contextTermRawFreq', type: 'int'}
    ],
    
    getTerm: function() {return this.getKeyword()},
    getRawFreq: function() {return this.getKeywordRawFreq()},
    getKeyword: function() {return this.get('term');},
    getKeywordRawFreq: function() {return this.get('rawFreq');},
    getContextTerm: function() {return this.get('contextTerm');},
    getContextTermRawFreq: function() {return this.get('contextTermRawFreq');}
});
/*
 * Corpus Term
 */
Ext.define('Voyant.data.model.CorpusTerm', {
    extend: 'Ext.data.Model',
    idProperty: 'term', // should be unique
    fields: [
             {name: 'id'},
             {name: 'rawFreq', type: 'int'},
             {name: 'inDocumentsCount', type: 'int'},
             {name: 'relativeFreq', type: 'float'},
             {name: 'relativePeakedness', type: 'float'},
             {name: 'relativeSkewness', type: 'float'},
             {name: 'comparisonRelativeFreqDifference', type: 'float'},
             {name: 'distributions'},
             {name: 'typeTokenRatio-lexical', type: 'float', calculate:  function(data) {
        	 	return data['typesCount-lexical']/data['tokensCount-lexical'];
             }}
    ],
    
    /**
     * Get the term.
     * @returns {String} Returns the term.
     */
    getTerm: function() {
    	return this.get('term');
    },
    
    /**
     * Get the term's raw frequency.
     * @returns {Number} Returns the term's frequency.
     */
	getRawFreq: function() {
		return parseInt(this.get('rawFreq'));
	},
	
	getInDocumentsCount: function() {
		return parseInt(this.get('inDocumentsCount'));
	},
	
	getDistributions: function() {
		return this.get('distributions');
	},
	
	/**
	 * Show a one line summary of this term.
	 */
	show: function(config) {
		show(this.getString(config))
	},
	
	getString: function() {
		return this.getTerm()+": "+this.getRawFreq();
	}
});
Ext.define('Voyant.data.model.CorpusNgram', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'term'},
             {name: 'length', type: 'int'},
             {name: 'rawFreq', type: 'int'},
             {name: 'distributions'}
        ],
    getTerm: function() {return this.get('term');}
});
Ext.define('Voyant.data.model.Dimension', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'percentage', type: 'number'}
    ]
});
Ext.define('Voyant.data.model.Document', {
    extend: 'Ext.data.Model',
    //requires: ['Voyant.data.store.DocumentTerms'],
    fields: [
             {name: 'corpus'},
			 {name: 'id'},
			 {name: 'author'},
             {name: 'pubDate'},
             {name: 'publisher'},
             {name: 'pubPlace'},
             {name: 'keyword'},
             {name: 'collection'},
             {name: 'index', type: 'int'},
             {name: 'tokensCount-lexical', type: 'int'},
             {name: 'typesCount-lexical', type: 'int'},
             {name: 'typeTokenRatio-lexical', type: 'float', calculate:  function(data) {
        	 	return data['typesCount-lexical']/data['tokensCount-lexical'];
             }},
             {name: 'lastTokenStartOffset-lexical', type: 'int'},
             {name: 'title'},
             {name: 'language', convert: function(data) {return Ext.isEmpty(data) ? '' : data;}},
             {name: 'sentencesCount', type: 'int'},
             {name: 'averageWordsPerSentence', type: 'float', calculate:  function(data) {
        	 	return data['sentencesCount'] ? data['tokensCount-lexical'] / data['sentencesCount'] : 0;
			 }},
			 {name: 'css', type: 'string'}
    ],
    
    getLexicalTokensCount: function() {
    	return this.get('tokensCount-lexical')
    },
    
    getLexicalTypeTokenRatio: function() {
    	return this.get('typeTokenRatio-lexical')
    },
    
    loadDocumentTerms: function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config};
		}
		Ext.applyIf(config, {
			limit: 0
		})
		var documentTerms = this.getDocumentTerms();
		documentTerms.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(documentTerms)
				} else {
					dfd.reject(operation)
				}
			}
		})
		return dfd.promise
    },
    
    loadTokens: function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config};
		}
		Ext.applyIf(config, {
			limit: 0
		})
		var tokens = this.getTokens({});
		tokens.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(tokens)
				} else {
					dfd.reject(operation)
				}
			}
		})
		return dfd.promise
    },
    
    getTokens: function(config) {
		config = config || {};
		Ext.applyIf(config, {
			proxy: {}
		});
		Ext.applyIf(config.proxy, {
			extraParams: {}
		})
		Ext.applyIf(config.proxy.extraParams, {
			docIndex: this.get('index')
		})
		Ext.apply(config, {
			docId: this.get('id')
		});
		return this.get('corpus').getTokens(config);
    },

    getDocumentTerms: function(config) {
		config = config || {};
		Ext.applyIf(config, {
			proxy: {}
		});
		Ext.applyIf(config.proxy, {
			extraParams: {}
		})
		Ext.applyIf(config.proxy.extraParams, {
			docIndex: this.get('index')
		})
		if (config.corpus) {
			return config.corpus.getDocumentTerms(config);
		}
		return this.get('corpus').getDocumentTerms(config); // FIXME: when does this happen?
    },
    
    getIndex: function() {
    	return this.get('index');
    },
    
    getId: function() {
    	return this.get('id');
    },
    
    getFullLabel: function() {
    	var author = this.getAuthor();
    	return this.getTitle() + (author ? "("+author+")" : ''); // TODO: complete full label
    },
    
    getTitle: function() {
    	var title = this.get('title');
    	if (title === undefined) title = '';
    	title = Ext.isArray(title) ? title.join("; ") : title;
    	title = title.trim().replace(/\s+/g, ' '); // remove excess whitespace
    	return title;
    },
    
    getTruncated: function(string, max) {
  		if (string.length > max) {
			// maybe a file or URL?
			var slash = string.lastIndexOf("/");
			if (slash>-1) {
				string = string.substr(slash+1);
			}
			
			if (string.length>max) {
				var space = string.indexOf(" ", max-5);
				if (space < 0 || space > max) {
					space = max;
				}
				string = string.substring(0, space) + "…";
			}
		}
  		return string;
    	
    },
    
    getShortTitle: function() {
     	var title = this.getTitle();
     	title = title.replace(/\.(html?|txt|xml|docx?|pdf|rtf|\/)$/,'');
     	title = title.replace(/^(the|a|le|l'|un|une)\s/,'');
     	return this.getTruncated(title, 25);
    },
    
    getTinyTitle: function() {
    	return this.getTruncated(this.getShortTitle(), 10);
    },
    
    getShortLabel: function() {
    	var author = this.getAuthor(25);
    	return (parseInt(this.getIndex())+1) + ') <i>' + this.getShortTitle() + "</i>" +(author ? " ("+author+")" : '')
    },
    
    getTinyLabel: function() {
    	return (parseInt(this.getIndex())+1) + ') ' + this.getTinyTitle();
    },
    
    getPubDate: function() {
    	return this.get("pubDate");
    },
    
    getPublisher: function() {
    	return this.get("publisher");
    },
    
    getPubPlace: function() {
    	return this.get("pubPlace");
    },
    
    getKeyword: function() {
    	return this.getMultiple("keyword");
    },
    
    getCollection: function() {
    	return this.getMultiple("collection");
    },
    
    getAuthor: function(max) {
    	return this.getMultiple("author");
    },
    
    getMultiple: function(field, max) {
    	var val = this.get(field) || "";
    	val = Ext.isArray(val) ? val.join("; ") : val;
    	val = val.trim().replace(/\s+/g, ' ');
    	return max ? this.getTruncated(val, max) : val;
    },
    
    getCorpusId: function() {
    	return this.get('corpus').getAliasOrId();
    },
    
    isPlainText: function() {
    	if (this.get("extra.Content-Type") && new RegExp("plain","i").test(this.get("extra.Content-Type"))) {
    		return true
    	}
    	return false;
    },
    
    getAverageWordsPerSentence: function() {
    	return this.get("averageWordsPerSentence");
    },
    
    show: function() {
    	show(this.getFullLabel())
    },
    
    getCorpus: function() {
    	return this.get('corpus');
    },
    
    
    getText: function(config) {
		config = config || {};
		Ext.apply(config, {
			docIndex: this.get('index')
		});
		return this.getCorpus().getText(config);
    },
    
    getPlainText: function(config) {
		config = config || {};
		Ext.apply(config, {
			template: 'docTokens2plainText',
			docIndex: this.get('index')
		});
		return this.getCorpus().getText(config);
    },
    
    getLemmasArray: function(config) {
    	config = config || {};
    	config.docId = this.getId();
		return this.getCorpus().getLemmasArray(config);
    },
    
    getEntities: function(config) {
    	config = config || {};
    	Ext.applyIf(config, {
    		proxy: {}
    	});
    	Ext.applyIf(config.proxy, {
    		extraParams: {}
    	})
    	Ext.applyIf(config.proxy.extraParams, {
    		docIndex: this.get('index')
    	})
		return Ext.create("Voyant.data.store.DocumentEntities", Ext.apply(config, {corpus: this.getCorpus(), docId: this.getId()}));
    },
    
    loadEntities: function(config) {
		var dfd = new Ext.Deferred();
		this.getEntities().load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(records)
				} else {
					dfd.reject(operation.error.response);
				}
			}
		})
		return dfd.promise
	},
	
	getCSS: function() {
		return this.get('css') || this.get('parent_css');
	}
    
});
Ext.define('Voyant.data.model.DocumentEntity', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'term'},
             {name: 'docIndex', 'type': 'int'},
             {name: 'rawFreq', type: 'int'},
             {name: 'type'},
             {name: 'positions'},
			 {name: 'offsets'}
        ],
    getTerm: function() {return this.get('term');},
    getDocIndex: function() {return this.get('docIndex')},
    getRawFreq: function() {return this.get('rawFreq')},
    getPositions: function() {return this.get('positions')},
	getOffsets: function() {return this.get('offsets')}
});
Ext.define('Voyant.data.model.DocumentQueryMatch', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'count', 'type': 'int'},
             {name: 'query'},
             {name: 'distributions'}
        ],
    getCount: function() {return this.get('count')},
    getDistributions: function() {return this.get("distributions")},
    getDocIds: function() {return this.get("docIds")}
});
Ext.define('Voyant.data.model.DocumentTerm', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'term'},
             {name: 'docIndex', 'type': 'int'},
             {name: 'docId'},
             {name: 'rawFreq', type: 'int'},
             {name: 'relativeFreq', type: 'float'},
             {name: 'tfidf', type: 'float'},
             {name: 'zscore', type: 'float'},
             {name: 'zscoreRatio', type: 'float'},
             {name: 'distributions'}
        ],
    getTerm: function() {return this.get('term');},
    getDocIndex: function() {return this.get('docIndex')},
    getRawFreq: function() {return this.get('rawFreq')},
    getRelativeFreq: function() {return this.get('relativeFreq')},
    getDistributions: function() {return this.get('distributions')}
});
Ext.define('Voyant.data.model.PrincipalComponent', {
    extend: 'Ext.data.Model',
    fields: [
        {name: 'eigenValue', type: 'number'},
        {name: 'eigenVectors'}
    ]
});
/*
 * Related Term
 */
Ext.define('Voyant.data.model.RelatedTerm', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'source'},
             {name: 'target'},
             {name: 'rawFreq', type: 'int'}
    ],
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getSource: function() {
    	return this.get('source');
    },
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getTarget: function() {
    	return this.get('target');
    },
    
	/**
	 * Show a one line summary of this term.
	 */
	show: function(config) {
		show(this.getString(config))
	},
	
	getString: function() {
		return this.getSource()+"-"+this.getTarget();
	}
});
Ext.define('Voyant.data.model.StatisticalAnalysis', {
    extend: 'Ext.data.Model',
    requires: ['Voyant.data.model.PrincipalComponent', 'Voyant.data.model.Dimension', 'Voyant.data.model.AnalysisToken'],
    fields: [
         {name: 'id'}
//         ,{name: 'dimensions', reference: 'Voyant.data.model.Dimension'}
//         ,{name: 'tokens', reference: 'Voyant.data.model.AnalysisToken'}
    ]
    
	// alternative access methods to "reference" or "hasMany"
	,getPrincipalComponents: function() {
		var pcs = [];
		this.data.principalComponents.forEach(function(pc) {
			pcs.push(Ext.create('Voyant.data.model.PrincipalComponent', pc));
		});
		return pcs;
	}
	,getDimensions: function() {
		var dimensions = [];
		this.data.dimensions.forEach(function(dim) {
			dimensions.push(Ext.create('Voyant.data.model.Dimension', {percentage: dim}));
		});
		return dimensions;
	}
	,getTokens: function() {
		var tokens = [];
		this.data.tokens.forEach(function(tok) {
			tokens.push(Ext.create('Voyant.data.model.AnalysisToken', tok));
		});
		return tokens;
	}


//    ,hasMany: [{
//    	name: 'dimensions', model: 'Voyant.data.model.Dimension'
//    },{
//    	name: 'tokens', model: 'Voyant.data.model.AnalysisToken'
//    }]
});
Ext.define('Voyant.data.model.Token', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'id'},
             {name: 'docId'},
             {name: 'docIndex', type: 'int'},
             {name: 'token'},
             {name: 'rawFreq'},
             {name: 'tokenType'},
             {name: 'position', type: 'int'},
             {name: 'startOffset', type: 'int'},
             {name: 'endOffset', type: 'int'}
        ],
    statics: {
		/**
		 * Parse an element's ID and return doc index and position info.
		 * @param {*} el Either an ExtJS element or an HTML element
		 * @returns {Object}
		 */
    	getInfoFromElement: function(el) {
    		if (el && el.id) {
    			var parts = el.id.split("_");
    			return {
    				docIndex: parseInt(parts[1]),
    				position: parseInt(parts[2])
    			};
    		}
    	}
    },
	isWord: function() {
		return this.getTokenType()=='lexical'; // maybe something else later?
	},
	isStopword: function() {
		return this.get("stopword")=="true";
	},
	getTokenType: function() {
		return this.get("tokenType");
	},
	getId: function() {
		return ["",this.getDocIndex(),this.getPosition()].join("_");
	},
	getDocIndex: function() {
		return this.get("docIndex");
	},
	getDocId: function() {
		return this.get("docId");
	},
	getTerm: function() {
		return this.get("term");
	},
	getTermWithLineSpacing: function(isPlainText) {
		var term = this.getTerm();
		if (isPlainText) {
			term = term.replace(/(\r\n|\r|\n)\s*/g,"<br />");
		} else {
			// alternate very general regex: <[^>]*>
			term = term.replace(/<\/?(.|\n|\r)*?>/gm, "<br /><br />").replace(/>\s+</g,"><").replace(/<br \/><br \/>(<br \/>)+/g,"<br \/><br \/>");
		}
		return term;
	},
	getPosition: function() {
		return this.get("position");
	},
	getDocumentRawFreq: function() {
		return this.get("rawFreq");
	}
});
/*
 * Related Term
 */
Ext.define('Voyant.data.model.TermCorrelation', {
    extend: 'Ext.data.Model',
    fields: [
             {name: 'source'},
             {name: 'target'},
             {name: 'correlation', type: 'float'},
             {name: 'significance', type: 'float'},
             {name: 'sourceTerm', calculate: function(data) {return data.source.term}},
             {name: 'targetTerm', calculate: function(data) {return data.target.term}},
             {name: 'source-distributions', calculate: function(data) {return data.source.distributions}},
             {name: 'target-distributions', calculate: function(data) {return data.target.distributions}}
    ],
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getSource: function() {
    	return this.get('source');
    },
    
    /**
     * Get the source term.
     * @returns {String} Returns the term.
     */
    getTarget: function() {
    	return this.get('target');
    },
    
	/**
	 * Show a one line summary of this term.
	 */
	show: function(config) {
		show(this.getString(config))
	},
	
	getString: function() {
		return this.getSource()+"-"+this.getTarget();
	}
});
Ext.define('Voyant.data.store.VoyantStore', {
	mixins: ['Voyant.util.Localization'],
	config: {
		corpus: undefined,
		parentPanel: undefined
	},
	statics: {
		i18n: {
			maxTime: 'This tool has exceeded the maximum run time and has returned partial results.'
		}
	},
	constructor: function(config, extras) {
		var me = this;
		config = config || {};
		Ext.applyIf(config, {
			remoteSort: true,
			autoLoad: false,
//			listeners: {
//				beforeload: function(store, operation) {
//					var parent = this.getParentPanel();
//					if (parent !== undefined) {
//						var params = parent.getApiParams();
//						operation = operation ? (operation===1 ? {} : operation) : {};
//						operation.params = operation.params || {};
//						for (var key in params) {
//							operation.params[key] = params[key];
//						}
//					}
//				}
//			},
//			scope: this,
			// define buffered configuration even if ignored when this isn't a buffered store
			pagePurgeCount : 0, // don't purge any data
			pageSize : 100, // each request is more intenstive, so do fewer of them then default
			leadingBufferZone : 200 // stay two pages ahead
		});
		config.proxy = config.proxy || {};
		Ext.applyIf(config.proxy, {
			type: 'ajax',
			url: Voyant.application.getTromboneUrl(),
			actionMethods: {read: 'POST'},
			timeout: extras['proxy.timeout'] || 30000,
			reader: {
				type: 'json',
				rootProperty: extras['proxy.reader.rootProperty'],
				totalProperty: extras['proxy.reader.totalProperty'],
				metaProperty: extras['proxy.reader.metaProperty'] || 'metaData'
			},
			simpleSortMode: true,
			listeners: {
				exception: function(proxy, request, operation) {
					if (me.parentPanel && me.parentPanel.showError) {
						// FIXME: this should probably send the request, not the operation
						me.parentPanel.showError(operation)
					}
				},
				endprocessresponse: function(proxy, response, operation) {
					if (operation.wasSuccessful()) {
						// check for tool messages from the server
						var config = proxy.getReader().initialConfig;
						var rootPropertyParent = config.rootProperty.split('.')[0];
						var json = JSON.parse(response.responseText);
						var parent = json[rootPropertyParent];
						if (parent && parent.messages) {
							var message = '';
							var firstMessage = parent.messages[0];
							if (firstMessage.code === 'maxTime') {
								message = me.localize('maxTime');
							} else {
								message = firstMessage.message;
							}
							if (me.parentPanel && me.parentPanel.toastInfo) {
								me.parentPanel.toastInfo(message);
							} else {
								console.warn('VoyantStore server message: '+message);
							}
						}
					}
				}
			}
		})
		config.proxy.extraParams = config.proxy.extraParams || {};
		Ext.applyIf(config.proxy.extraParams, {
			tool: extras['proxy.extraParams.tool']
		});
		
		if (config.parentPanel !== undefined) {
			Ext.applyIf(config.proxy.extraParams, {
				forTool: config.parentPanel.xtype
			});
			this.setParentPanel(config.parentPanel);
			config.parentPanel.on("loadedCorpus", function(src, corpus) {
				this.setCorpus(corpus);
			}, this);
			config.listeners = config.listeners || {};
			config.listeners.beforeload = {
					fn: function(store, operation) {
						var parent = this.getParentPanel(), proxy = store.getProxy();
						if (parent !== undefined) {

							var params = parent.getApiParams();
							operation = operation ? (operation===1 ? {} : operation) : {};
							operation.params = operation.params || {};
							
							// unset any previously set extra params (only applies with proxy and buffered store)
							if (proxy && this.isBufferedStore) {
								Ext.Array.from(this.previouslySetExtraParams).forEach(function(key) {
									proxy.setExtraParam(key, undefined);
								});
								this.previouslySetExtraParams = [];
							}
							for (var key in params) {
								
								/* TODO NOT SURE ABOUT THIS
								// don't sent stopList when there's a query
								if (key=="stopList" && "query" in params && params.query) {continue;}
								*/
								
								if (proxy && this.isBufferedStore) { // also set proxy for automatic buffering calls
									this.previouslySetExtraParams.push(key);
									proxy.setExtraParam(key, params[key]);
								}
								operation.params[key] = params[key];
							}
						}
					},
					scope: this
			}
		}
		
		Ext.apply(this, config);
	},
	setCorpus: function(corpus) {
		if (corpus && this.getProxy && this.getProxy()) {
			this.getProxy().setExtraParam('corpus', Ext.isString(corpus) ? corpus : corpus.getId());
		}
		this.callParent(arguments);
	},
	getString: function(config) {
		var count = this.getCount();
		return "This store contains "+this.getCount()+" items"+(count>0 ? " with these fields: "+this.getAt(0).getFields().map(function(field) {return field.getName()}).join(", ") : "")+"."
	}
	
});
Ext.define('Voyant.data.store.CAAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CA',
			'proxy.reader.rootProperty': 'correspondenceAnalysis',
			'proxy.reader.totalProperty': 'correspondenceAnalysis.totalTerms'
		}])
		config.proxy.extraParams.withDistributions = true;
	}
});

Ext.define('Voyant.data.store.CAAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CAAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.ContextsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.Context',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentContexts',
			'proxy.reader.rootProperty': 'documentContexts.contexts',
			'proxy.reader.totalProperty': 'documentContexts.total'
		}])
	}
});

Ext.define('Voyant.data.store.Contexts', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.ContextsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.ContextsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.ContextsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.ContextsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.ContextsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.CorpusCollocatesMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.CorpusCollocate',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusCollocates',
			'proxy.reader.rootProperty': 'corpusCollocates.collocates',
			'proxy.reader.totalProperty': 'corpusCollocates.total'
		}])
	}
});

Ext.define('Voyant.data.store.CorpusCollocates', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusCollocatesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusCollocatesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusCollocatesBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusCollocatesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusCollocatesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.CorpusFacetsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: Voyant.data.model.CorpusFacet,
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusFacets',
			'proxy.reader.rootProperty': 'corpusFacets.facets',
			'proxy.reader.totalProperty': 'corpusFacets.total'
		}])
	}
});

Ext.define('Voyant.data.store.CorpusFacets', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusFacetsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusFacetsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusFacetsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusFacetsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusFacetsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusTermsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: Voyant.data.model.CorpusTerm,
//    statics: {
//    	i18n: {
//    		getString: "This store has {0} terms with a total of {1} occurrences."
//    	}
//    },
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusTerms',
			'proxy.reader.rootProperty': 'corpusTerms.terms',
			'proxy.reader.totalProperty': 'corpusTerms.total'
		}])
	},

	show: function(config) {
		show(this.getString(config))
	}

});

/*
 * Corpus Terms store.
 */
Ext.define('Voyant.data.store.CorpusTerms', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusTermsMixin'],
    model: Voyant.data.model.CorpusTerm,
	
	/**
	 * @method each
	 * Iterate over each {@link Voyant.data.model.CorpusTerm corpus term} in this store.
	 * 
	 * 	new Corpus("Hello Voyant!").loadCorpusTerms().then(function(corpusTerms) {
	 * 		corpusTerms.each(function(corpusTerm) {
	 * 			corpusTerm.show();
	 * 		});
	 * 	});
	 * 
	 * @param {function} function The function to call for each corpus term.
	 */
	
	/**
	 * @method show
	 * Shows a one line summary of the corpus terms.
	 * 
	 * 	new Corpus("Hello Voyant!").loadCorpusTerms().then(function(corpusTerms) {
	 * 		corpusTerms.show();
	 * 	});
	 */
	
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
	
});

Ext.define('Voyant.data.store.CorpusTermsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusTermsMixin'],
    model: Voyant.data.model.CorpusTerm,
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentQueryMatchesMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.DocumentQueryMatch',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentsFinder',
			'proxy.reader.rootProperty': 'documentsFinder.queries',
			'proxy.reader.totalProperty': undefined,
			'proxy.reader.metaProperty': 'documentsFinder.corpus'
		}])
	}
});

Ext.define('Voyant.data.store.DocumentQueryMatches', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentQueryMatchesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentQueryMatchesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentQueryMatchesBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentQueryMatchesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentQueryMatchesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentTermsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.DocumentTerm',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentTerms',
			'proxy.reader.rootProperty': 'documentTerms.terms',
			'proxy.reader.totalProperty': 'documentTerms.total'
		}])
	}
});

Ext.define('Voyant.data.store.DocumentTerms', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentTermsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentEntitiesMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.DocumentEntity',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentEntities',
			'proxy.reader.rootProperty': 'documentEntities.entities',
			'proxy.reader.totalProperty': 'documentEntities.total'
		}])
	}
});

Ext.define('Voyant.data.store.DocumentEntities', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentEntitiesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentEntitiesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentEntitiesBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentEntitiesMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentEntitiesMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.Document',
    statics: {
    	i18n: {
    	}
    },
	sorters: {
        property: 'index',
        direction: 'ASC'
	},
	remoteSort: true,
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentsMetadata',
			'proxy.reader.rootProperty': 'documentsMetadata.documents',
			'proxy.reader.totalProperty': 'documentsMetadata.total'
		}])
	},
	listeners: {
		 load: function(store, records, successful, opts) {
			 if (successful) {
				 var corpus = store.getCorpus();
				 records.forEach(function(record) {
					 record.set('corpus', corpus);
				 });
			 }
		 }
	},
	getDocument: function(config) {
		return Ext.isNumber(config) ? this.getAt(config) : this.getById(config);
	}
	
});

Ext.define('Voyant.data.store.Documents', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocumentsMixin'],
    model: 'Voyant.data.model.Document',
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocumentsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocumentsMixin'],
    model: 'Voyant.data.model.Document',
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocumentsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.PCAAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.PCA',
			'proxy.reader.rootProperty': 'pcaAnalysis',
			'proxy.reader.totalProperty': 'pcaAnalysis.totalTerms'
		}])
		config.proxy.extraParams.withDistributions = true;
	}
});

Ext.define('Voyant.data.store.PCAAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.PCAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.PCAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.PCAAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.PCAAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.PCAAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.DocSimAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentSimilarity',
			'proxy.reader.rootProperty': 'documentSimilarity',
			'proxy.reader.totalProperty': 'documentSimilarity.total'
		}])
		config.proxy.extraParams.withDistributions = true;
	}
});

Ext.define('Voyant.data.store.DocSimAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.DocSimAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocSimAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.DocSimAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.DocSimAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.DocSimAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.CorpusNgramsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.CorpusNgram',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusNgrams',
			'proxy.reader.rootProperty': 'corpusNgrams.ngrams',
			'proxy.reader.totalProperty': 'corpusNgrams.total',
			'proxy.timeout': 90000
		}])
	}
});

Ext.define('Voyant.data.store.CorpusNgrams', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.CorpusNgramsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusNgramsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.CorpusNgramsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.CorpusNgramsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.CorpusNgramsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.RelatedTermsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.RelatedTerm',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.SemanticGraph',
			'proxy.reader.rootProperty': 'semanticGraph.edges',
			'proxy.reader.totalProperty': 'semanticGraph.total'
		}])
	}
});

Ext.define('Voyant.data.store.RelatedTerms', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.RelatedTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.RelatedTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.RelatedTermsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.RelatedTermsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.RelatedTermsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.TermCorrelationsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.TermCorrelation',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.CorpusTermCorrelations',
			'proxy.extraParams.withDistributions': 'true',
			'proxy.reader.rootProperty': 'termCorrelations.correlations',
			'proxy.reader.totalProperty': 'termCorrelations.total',
			'proxy.timeout': 90000
		}])
	}
});

Ext.define('Voyant.data.store.TermCorrelations', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.TermCorrelationsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TermCorrelationsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.TermCorrelationsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.TermCorrelationsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TermCorrelationsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.TokensMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.Token',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.DocumentTokens',
			'proxy.reader.rootProperty': 'documentTokens.tokens',
			'proxy.reader.totalProperty': 'documentTokens.total'
		}])
	}
});

Ext.define('Voyant.data.store.Tokens', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.TokensMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TokensMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.TokensBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.TokensMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TokensMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.store.TSNEAnalysisMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: 'Voyant.data.model.StatisticalAnalysis',
	constructor : function(config) {
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'corpus.TSNE',
			'proxy.reader.rootProperty': 'tsneAnalysis',
			'proxy.reader.totalProperty': 'tsneAnalysis.totalTerms'
		}])
		config.proxy.extraParams.withDistributions = true;
		config.proxy.extraParams.noCache = 1;
	}
});

Ext.define('Voyant.data.store.TSNEAnalysis', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.TSNEAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TSNEAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.TSNEAnalysisBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.TSNEAnalysisMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.TSNEAnalysisMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});
Ext.define('Voyant.data.model.NotebookFacet', {
    extend: 'Ext.data.Model',
    idProperty: 'label',
    fields: [
             {name: 'facet'},
             {name: 'label'},
             {name: 'inDocumentsCount', type: 'int'}
    ],
    getLabel: function() {
    	return this.get('label')
    },
    getFacet: function() {
    	return this.get('facet')
    },
	getInDocumentsCount: function() {
		return this.get('inDocumentsCount')
	}
});

Ext.define('Voyant.data.store.NotebookFacetsMixin', {
	mixins: ['Voyant.data.store.VoyantStore'],
    model: Voyant.data.model.NotebookFacet,
	constructor : function(config) {
		if (config.facet) {
			if (config.proxy === undefined) {
				config.proxy = {};
			}
			if (config.proxy.extraParams === undefined) {
				config.proxy.extraParams = {};
			}
			config.proxy.extraParams.facet = config.facet;
			config.proxy.extraParams.noCache = 1;
			delete config.facet;
		}
		this.mixins['Voyant.data.store.VoyantStore'].constructor.apply(this, [config, {
			'proxy.extraParams.tool': 'notebook.CatalogueFacets',
			'proxy.reader.rootProperty': 'catalogue.facets',
			'proxy.reader.totalProperty': 'catalogue.total'
		}])
	}
});

Ext.define('Voyant.data.store.NotebookFacets', {
	extend: 'Ext.data.Store',
	mixins: ['Voyant.data.store.NotebookFacetsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.NotebookFacetsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

Ext.define('Voyant.data.store.NotebookFacetsBuffered', {
	extend: 'Ext.data.BufferedStore',
	mixins: ['Voyant.data.store.NotebookFacetsMixin'],
	constructor : function(config) {
		config = config || {};
		this.mixins['Voyant.data.store.NotebookFacetsMixin'].constructor.apply(this, [config])
		this.callParent([config]);
	}
});

/*
 * @class VoyantTable
 * A VoyantTable can facilitate working with tabular data structures, as well as
 * displaying results (especially with {@link #embed} and {@link show}). 
 * Here's a simple example showing the Zipf-Law distribution of the top 20 frequency terms.
 * 
 * 	new Corpus("austen").loadCorpusTerms(20).then(function(corpusTerms) {
 * 		var table = new VoyantTable({rowKey: 0}); // use first column as row key
 * 		corpusTerms.each(function(corpusTerm) {
 *			table.addRow([corpusTerm.getTerm(), corpusTerm.getRawFreq()]);
 * 		});
 * 		table.embed("voyantchart"); // graph table as line chart
 * 	});
 */
Ext.define('Voyant.data.table.Table', {
	alternateClassName: ["VoyantTable"],
	config: {
		
		/**
		 * @private
		 */
		rows: [],

		/**
		 * @private
		 */
		headers: [],

		/**
		 * @private
		 */
		rowsMap: {},
		
		/**
		 * @private
		 */
		headersMap: {},
		
		/**
		 * Specifies that a specific header should serve as row key.
		 * 
		 */
		rowKey: undefined,
		
		/**
		 * @private
		 */
		model: undefined
	},
	
	clone: function() {
		var table = new VoyantTable();
		table.setRows(Ext.clone(this.getRows()));
		table.setHeaders(Ext.clone(this.getHeaders()))
		table.setRowsMap(Ext.clone(this.getRowsMap()))
		table.setHeadersMap(Ext.clone(this.getHeadersMap()))
		table.setRowKey(Ext.clone(this.getRowKey()))
		return table;
	},

	constructor: function(config, opts) {

		config = config || {};
		if (config.fromBlock) {
			var data = Voyant.notebook.Notebook.getDataFromBlock(config.fromBlock);
			if (data) {
				data = data.trim();
				config.rows = [];
				data.split(/\n+/).forEach(function(line,i) {
					var cells = line.split("\t");
					if (i==0 && !config.noHeaders) {
						config.headers = cells
					} else {
						config.rows.push(cells)
					}
				})
				
			}
		} else if (config.count && Ext.isArray(config.count)) {
			// create counts
			var freqs = {};
			config.count.forEach(function(item) {freqs[item] = freqs[item] ? freqs[item]+1 : 1;});
			// sort counts
			var counts = [];
			for (var key in freqs) {counts.push([key, freqs[key]])}
			counts.sort(function(a,b) {return b[1] - a[1]});
			if (config.limit && counts.length>config.limit) {
				counts.splice(config.limit);
			}
			if (config.orientation && config.orientation=="horizontal") {
				config.headers = counts.map(function(item) {return item[0]});
				config.rows = [counts.map(function(item) {return item[1]})];
			} else {
				config.headers = config.headers ? config.headers : ["Item","Count"];
				config.rows = counts;
			}
		} else if (config.isStore || config.store) {
			var store = config.store ? config.store : config;
			if (opts && opts.headers) {
				config.headers = opts.headers;
			} else {
				// store.getModel() doesn't seem to work (for CorpusTerms at least)
				// so instead we'll try looking at the first record to get headers
				var record = store.getAt(0);
				if (record) { // don't know what to do if this fails?
					config.headers = record.getFields().map(function(field) {return field.getName()});
				}
			}
			
			// now we get rows
			config.rows = [];
			store.each(function(record) {
				var data = record.getData();
				var cells = config.headers.map(function(header) {return data[header]}); // only from headers
				config.rows.push(cells);
			}, this);
		}

		// not sure why config isn't working
		if (!config.rows && Ext.isArray(config)) {
			config.rows = config;
		}
		if (!this.getHeaders()) {
			if (!config.headers && !config.noHeaders && config.rows) {
				this.setHeaders(config.rows.shift())
			} else {
				this.setHeaders(Ext.Array.from(config.headers));
			}
		}
		this.setRows(Ext.Array.from(config.rows));
		this.setRowKey(config.rowKey ? config.rowKey : this.getHeaders()[0]);

		// if we have no headers, use the index as header
		if (this.getHeaders().length==0) {
			var firstRow = this.getRow(0, false);
			if (firstRow) {
				this.setHeaders(firstRow.map(function(cell, i) {return i}));
			}
		}
		
		var headersMap = {};
		this.getHeaders().forEach(function(header, i) {
			headersMap[header] = i;
		});
		this.setHeadersMap(headersMap);
		
		this.reMapRows();
		
		this.callParent();
	},
	addRow: function(row) {
		if (Ext.isArray(row))
		if (Ext.isObject(row)) {
			var len = this.getRows().length;
			for (var key in row) {
				this.updateCell(len, key, row[key])
			}
			
		} else if (Ext.isArray(row)) {
			this.getRows().push(row);
			var header = this.getColumnIndex(this.getRowKey());
			if (header!==undefined && row[header]!==undefined) {
				this.getRowsMap()[row[header]] = this.getRows().length-1;
			}
		}
	},
	eachRecord: function(fn, scope) {
		var item, i=0, len=this.getRows().length;
		for (; i<len; i++) {
            item = this.getRecord(i);
			if (fn.call(scope || item, item, i, len) === false) {
                break;
            }			
		}
	},
	eachRow: function(fn, asMap, scope) {
		var item, i=0, len=this.getRows().length;
		for (; i<len; i++) {
            item = this.getRow(i, asMap);
			if (fn.call(scope || item, item, i, len) === false) {
                break;
            }			
		}
	},
	getRow: function(index, asMap) {
		var r = this.getRowIndex(index);
		if (asMap) {
			var row = {};
			var headers = this.getHeaders();
			Ext.Array.from(this.getRows()[r]).forEach(function(item, i) {
				row[headers[i] || i] = item;
			}, this);
			return row;
		} else {
			return this.getRows()[r];
		}
	},
	getRecord: function(index) {
		if (this.model) {return new this.model(this.getRow(index, true))}
	},
	mapRows: function(fn, asMap, scope) {
		var rows = [];
		this.eachRow(function(row, i) {
//			if (Object.keys(row).length>0) {
				rows.push(fn.call(scope || this, row, i))
//			}
		}, asMap, this)
		return rows;
	},
	
	/**
	 * Update the cell value at the specified row and column.
	 * 
	 * This will create the row and column as needed. If there's an existing value in the cell,
	 * it will be added to the new value, unless the `replace` argument is set to true.
	 * 
	 * @param {Number/String} row The cell's row.
	 * @param {Number/String} column The cell's column.
	 * @param {Mixed} value The cell's value.
	 * @param {boolean} [replace] Replace the current value (if it exists), otherwise
	 * the value is added to any current value (which is the default behaviour).
	 */
	updateCell: function(row, column, value, replace) {
		var rows = this.getRows();
		var r = Ext.isNumber(row) ? row : this.getRowIndex(row);
		var c = this.getColumnIndex(column);
		if (rows[r]===undefined) {rows[r]=[]}
		if (rows[r][c]===undefined || replace) {rows[r][c]=value}
		else {rows[r][c]+=value}
		// add to rowsMap if this is the header
		if (this.getHeaders()[c]===this.getRowKey()) {
			this.getRowsMap()[column] = r;
		}
	},
	
	getRowIndex: function(key) {
		if (Ext.isNumber(key)) {return key;}
		if (Ext.isString(key)) {
			var rowsMap = this.getRowsMap();
			if (!(key in rowsMap)) {
				rowsMap[key] = this.getRows().length;
				this.getRows().push(new Array(this.getHeaders().length))
			}
			return rowsMap[key];
		}
	},
	
	getColumnIndex: function(column) {
		var headers = this.getHeaders();
		if (Ext.isNumber(column)) {
			if (headers[column]===undefined) {
				headers[column]=column;
				this.getRows().forEach(function(row) {
					row.splice(column, 0, undefined);
				});
			}
			return column;
		} else if (Ext.isString(column)) {
			if (!(column in this.getHeadersMap())) {
				// we don't have this column yet, so create it and expand rows
				this.getHeaders().push(column);
				this.getHeadersMap()[column] = this.getHeaders().length-1
				this.getRows().forEach(function(row) {
					row.push(undefined)
				});
			}
			return this.getHeadersMap()[column]
		}
	},
	
	getColumnHeader: function(column) {
		var c = this.getColumnIndex(column);
		return this.getHeaders()[c];
	},
	
	/**
	 * Compute the sum of the values in the column.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnSum: function(column) {
		return Ext.Array.sum(this.getColumnValues(column, true));
	},
	
	/**
	 * Compute the sum of the values in the column.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnMean: function(column) {
		return Ext.Array.mean(this.getColumnValues(column, true));
	},
	
	/**
	 * Get the largest value in the array.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnMax: function(column) {
		return Ext.Array.max(this.getColumnValues(column, true));
	},
	
	/**
	 * Get the smallest value in the array.
	 * 
	 * @param {Number/String} column The column index (as a number) or key (as a string).
	 */
	getColumnMin: function(column) {
		return Ext.Array.min(this.getColumnValues(column, true));
	},
	
	getColumnValues: function(column, clean) {
		var c = this.getColumnIndex(column), vals = [];
		this.eachRow(function(row) {
			vals.push(row[c]);
		});
		if (clean) {return Ext.Array.clean(vals)}
		else {return vals;}
	},
	
	/**
	 * @private
	 */
	reMapRows: function() {
		var rowKey = this.getRowKey();
		var rowsMap = {}
		this.eachRow(function(row, i) {
			if (rowKey in row) {
				rowsMap[row[rowKey]] = i;
			}
		}, true);
		this.setRowsMap(rowsMap)
	},
	
	sortByColumn: function(columns) {
		var rows = this.getRows(),
			sortColumnsIndices = Ext.Array.from(columns).map(function(column) {
				if (Ext.isObject(column)) {
					for (key in column) {
						return {
							index: this.getColumnIndex(key),
							direction: column[key].indexOf("asc")>-1 ? 'asc' : 'desc'
						}
					}
				} else {
					return {
						index: this.getColumnIndex(column),
						direction: "desc"
					}
				}
			}, this);
		rows.sort(function(a, b) {
			for (var i=0, len=sortColumnsIndices.length; i<len; i++) {
				var header = sortColumnsIndices[i].index
				if (a[header]!=b[header]) {
					if (sortColumnsIndices[i].direction=='asc') {return a[header] > b[header] ? 1 : -1}
					else {return a[header] > b[header] ? -1 : 1}
				}
			}
		});
		this.reMapRows();
		return this;
	},
	
	loadCorrespondenceAnalysis: function(config) {
		return this._doAnalysisLoad('table.CA', 'Voyant.data.store.CAAnalysis', config);
	},
	
	loadPrincipalComponentAnalysis: function(config) {
		return this._doAnalysisLoad('table.PCA', 'Voyant.data.store.PCAAnalysis', config);
	},
	
	loadTSNEAnalysis: function(config) {
		return this._doAnalysisLoad('table.TSNE', 'Voyant.data.store.TSNEAnalysis', config);		
	},
	
	_doAnalysisLoad: function(tool, storeType, config) {
		config = config || {};
		var dfd = new Ext.Deferred();
		Ext.apply(config, {
			columnHeaders: true,
			rowHeaders: true,
			tool: tool,
			analysisInput: this.toTsv(),
			inputFormat: 'tsv'
		});
		var store = Ext.create(storeType, {noCorpus: true});
		store.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(store, records)
				} else {
					dfd.reject(operation.error.response);
				}
			}
		})
		return dfd.promise
	},
	
	embed: function(cmp, config) {
		if (!config && Ext.isObject(cmp)) {
			config = cmp;
			cmp = this.embeddable[0];
		}
		config = config || {};
		
		var columnHeaders = Ext.Array.from(config.headers || this.getHeaders()).map(function(header) {return this.getColumnHeader(header);}, this);
		
		var json = {
				rowkey: this.getRowKey(),
				config: config,
				headers: columnHeaders
		};
		if ("headers" in config) {
			var columnIndices = Ext.Array.from(config.headers).map(function(header) {return this.getColumnIndex(header);}, this);
			var rows = [];
			this.getRows().forEach(function(row) {
				rows.push(columnIndices.map(function(i) {
					return row[i]
				}))
			})
			Ext.apply(json, {
				rows: rows
			})
		} else {
			Ext.apply(json, {
				rows: this.getRows()
			})
		}
		Ext.apply(config, {
			tableJson: JSON.stringify(json)
		});
		delete config.axes;
		delete config.series;
		
		embed.call(this, cmp, config);
		
	},
	
	toTsv: function(config) {
		var tsv = this.getHeaders().join("\t");
		this.getRows().forEach(function(row, i) {
			if (config && Ext.isNumber(config) && i>config) {return;}
			tsv += "\n"+row.map(function(cell) {
				return Ext.isString(cell) ? cell.replace(/(\n|\t)/g, "") : cell;
			}).join("\t");
		})
		return tsv;
	},
	
	getString: function(config) {
		config = config || {};
		var table = "<table class='voyant-table' style='"+(config.width ? ' width: '+config.width : '')+"' id='"+(config.id ? config.id : Ext.id())+"'>";
		var headers = this.getHeaders();
		if (headers.length) {
			table+="<thead><tr>";
			for (var i=0, len = headers.length; i<len; i++) {
				table+="<th>"+headers[i]+"</th>";
			}
			table+="</tr></thead>";
		}
		table+="<tbody>";
		for (var i=0, len = Ext.isNumber(config) ? config : this.getRows().length; i<len; i++) {
			var row = this.getRow(i);
			if (row && Ext.isArray(row)) {
				table+="<tr>";
				row.forEach(function(cell) {
					table+="<td>"+cell+"</td>";
				})
				table+="</tr>";
			}
		}
		table+="</tbody></table>";
		return table;
	}
});
/*
 * @class NetworkGraph
 * 
 * A NetworkGraph can facilitate working with network graph data structures, as well as
 * displaying results (especially with {@link #embed} and {@link show}). 
 * Here's a simple example showing the Zipf-Law distribution of the top 20 frequency terms.
 * 
 * 	new Corpus("austen").loadCorpusTerms(20).then(function(corpusTerms) {
 * 		var table = new VoyantTable({rowKey: 0}); // use first column as row key
 * 		corpusTerms.each(function(corpusTerm) {
 *			table.addRow([corpusTerm.getTerm(), corpusTerm.getRawFreq()]);
 * 		});
 * 		table.embed("voyantchart"); // graph table as line chart
 * 	});
 */
Ext.define('Voyant.data.util.NetworkGraph', {
	alternateClassName: ["NetworkGraph"],
	config: {
		
		/**
		 * @private
		 */
		edges: [],

		/**
		 * @private
		 */
		nodes: []

	},

	constructor: function(config, opts) {
		config = config || {};
		this.setEdges(Ext.Array.from(config.edges));
		this.setNodes(Ext.Array.from(config.nodes));
		this.callParent([config]);
	},
	addEdge: function(src, target, value) {
		this.getEdges().push(Ext.isObject(src) ? src : {source: src, target: target, value: value});
	},
	getNode: function(term) {
		return Ext.Array.binarySearch(this.getNodes(), term, undefined, undefined, function(lhs, rhs) {
			return (lhs.term < rhs.term) ? -1 : ((lhs.term > rhs.term) ? 1 : 0);
		})
	},
	embed: function(cmp, config) {
		if (!config && Ext.isObject(cmp)) {
			config = cmp;
			cmp = this.embeddable[0];
		}
		config = config || {};
		var json = {
				edges: this.getEdges(),
				nodes: this.getNodes(),
				config: config
		};
		if (config.limit && json.edges.length>config.limit) {
			json.edges = json.edges.slice(0, config.limit);
			var terms = {};
			json.edges.forEach(function(edge) {
				terms["_"+edge.source] = true;
				terms["_"+edge.target] = true;
			})
			var nodes = [];
			json.nodes.forEach(function(node) {
				if ("_"+node.term in terms) {
					nodes.push(node);
				}
			});
			json.nodes = nodes;
		}
		Ext.apply(config, {
			jsonData: JSON.stringify(json)
		})
		embed.call(this, cmp, config);
	},
	
	getString: function(config) {
		config = config || {};
		return this.getEdges().map(function(edge) {edge.source+"-"+edge.target}).join("; ");
	}
});
Ext.define('Voyant.data.util.Geonames', {
    mixins: ['Voyant.util.Localization'],
    statics: {
    		i18n: {
    		}
    },

	config: {
		data: {},
		queries: undefined,
		corpus: undefined,
		isIncrementalLoadingOccurrences: false,
		previousParams: {}
	},
	constructor: function(config, opts) {
		config = config || {};
		this.callParent([config]);
		this.setCorpus(config.corpus);
	},
	load: function(params, dfd) {
		this.setPreviousParams(params);
		dfd = dfd || new Ext.Deferred();
		var me = this, localParams = {
			corpus: this.getCorpus().getAliasOrId(),
			queries: this.getQueries(),
			tool: 'corpus.Dreamscape',
			limit: 200
		};
		Ext.apply(localParams, params || {});
		
		if (!params.noOverwrite) {
			me.setData({});
		}

		Ext.Ajax.request({
			url: Voyant.application.getTromboneUrl(),
			params: localParams,
			scope: this
		}).then(function(response) {
			var data = Ext.JSON.decode(response.responseText);
			if (data && data.dreamscape && data.dreamscape.progress) {
				new Voyant.widget.ProgressMonitor({
					progress: data.dreamscape.progress,
					maxMillisSinceStart: 1000*60*60, // an hour (!)
					tool: 'corpus.Dreamscape',
					success: function() {
						me.load.call(me, params, dfd);
					},
					failure: function(responseOrProgress) {
						Voyant.application.showResponseError(me.localize("failedToFetchGeonames"), responseOrProgress);
						dfd.reject();
					},
					scope: me
				});
			}
			if (data && data.dreamscape && !data.dreamscape.progress) {
				if (!params.noOverwrite) {
					me.setData(data.dreamscape);
				}
				dfd.resolve(data);
			}
		}, function(response) {
			Voyant.application.showResponseError(me.localize('failedToFetchGeonames'), response);
			dfd.reject();
		});
		return dfd.promise;
	},
	getCitiesCount: function() {
		return Object.keys(this.getData().locations.locations).length;
	},
	getTotalCitiesCount: function() {
		return this.getData().locations.total;
	},
	hasMoreCities: function() {
		return this.getCitiesCount()<this.getTotalCitiesCount();
	},
	eachCity: function(fn, scope, max) {
		var locations = this.getData().locations.locations, orderedLocations = [];
		for (var id in locations) { // create a sortable list with id
			orderedLocations.push(Ext.apply(locations[id], {id: id}))
		}
		orderedLocations.sort(function(c1, c2) { // order by rawFreq (count)
			return c1.rawFreq == c2.rawFreq ? c1.label - c2.label : c2.rawFreq - c1.rawFreq;
		});
		if (max && orderedLocations.length>max) {orderedLocations = orderedLocations.slice(0,max)}
		orderedLocations.forEach(function(location) {fn.call(scope, location);});
	},
	getConnectionsCount: function() {
		return this.getData().connections.connections.length;
	},
	getTotalConnectionsCount: function() {
		return this.getData().connections.total;
	},
	eachConnection: function(fn, scope, max) {
		var connections = this.getData().connections.connections,
			locations = this.getData().locations.locations;
			orderedConnections = [];
		for (var i=0, len=connections.length; i<len; i++) {
			fn.call(scope, {
				source: Ext.apply({id: connections[i].source}, locations[connections[i].source]),
				target: Ext.apply({id: connections[i].target}, locations[connections[i].target]),
				rawFreq: connections[i].rawFreq
			});
			if (i>max) {break;}
		}
	},
	getConnectionOccurrence: function(index) {
		if (!this.getData().locations) {return undefined;}
		var connectionOccurrencesData = this.getData().connectionOccurrences,
			connectionOccurrences = connectionOccurrencesData.connectionOccurrences;
			locations = this.getData().locations.locations;
		if (!this.getIsIncrementalLoadingOccurrences() && connectionOccurrences.length<connectionOccurrencesData.total && index+100>connectionOccurrences.length) {
			this.setIsIncrementalLoadingOccurrences(true);
			var me = this;
			var params = {};
			Ext.apply(params, this.getPreviousParams);
			Ext.apply(params, {
				start: connectionOccurrences.length,
				noOverwrite: true,
				suppressLocations: true,
				suppressConnections: true
			});
			this.load(params).then(function(data) {
				me.setIsIncrementalLoadingOccurrences(false);
				me.getData().connectionOccurrences.connectionOccurrences = connectionOccurrences.concat(data.dreamscape.connectionOccurrences.connectionOccurrences);
			})
		}
		if (connectionOccurrences && connectionOccurrences[index]) {
			var occurrence = connectionOccurrences[index];
			occurrence.index = index;
			Ext.apply(occurrence.source, locations[occurrence.source.location]);
			Ext.apply(occurrence.target, locations[occurrence.target.location]);
			return occurrence;
		}
		return null;
	},
    getAllConnectionOccurrences: function(sourceId, targetId) {
    	debugger
        // TODO return all occurences of connection with given source and target, including those not loaded yet
        var occurences = [];
        for (var i = 0; i < this.getTotalConnectionsCount(); i++) {
            var occurence = this.getConnectionOccurrence(i);
            if (occurence && occurence.target.id == targetId && occurence.source.id == sourceId) {
                occurences.push(occurence);
            }
        }
        return occurences
    }
});
/**
 * A class for calling corpus.DocumentEntities and displaying the progress of that call.
 * This is usually a preliminary call before making use of the entities, e.g. corpus.EntityCollocationsGraph
 */
Ext.define('Voyant.data.util.DocumentEntities', {
	extend: 'Ext.Base',
	mixins: ['Voyant.util.Localization'],
	statics: {
		i18n: {
			identifyingDocEnts: 'Identifying Document Entities',
			error: 'Error Identifying Document Entities',
			retry: 'Retry Failed Documents',
			done: 'Done',
			statusDone: 'Done',
			statusFailed: 'Failed',
			statusQueued: 'Queued',
			statusStarted: 'Started',
			status413: 'Your document is too large for this service'
		}
	},

	config: {
		progressWindow: undefined,
		updateDelay: 5000,
		timeoutId: undefined
	},
	
	constructor: function(params, callback) {
		this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
		this.initConfig();
		this.callParent();

		return this.load(params, callback);
	},

	/**
	 * Load the entities
	 * @param {Object} params Additional params
	 * @param {String} params.annotator Annotator can be: 'stanford' (default) or 'nssi'
	 * @param {Function} callback A function to call when the entities are loaded
	 */
	load: function(params, callback) {
		params = Ext.apply({
			tool: 'corpus.DocumentEntities',
			corpus: Voyant.application.getCorpus().getId(),
			noCache: true
		}, params || {});

		this.doLoad(params, callback, true);
	},

	doLoad: function(params, callback, firstCall) {
		var me = this;
		Ext.Ajax.request({
			url: Voyant.application.getTromboneUrl(),
			params: params
		}).then(function(response) {
			var data = Ext.decode(response.responseText).documentEntities;
			
			var progressArray = me._getProgressFromStatus(data.status);
			var isDone = progressArray[0] === progressArray[1];
			var hasFailures = progressArray[2];
			var has413Status = progressArray[3].indexOf('413') !== -1; // 413 = corpus too large

			if (firstCall && isDone && !hasFailures) {
				var win = me.getProgressWindow();
				if (win) {
					win.close();
				}
				callback.call(me, data.entities);
			} else {
				me.updateProgress(data.status, progressArray);
				if (isDone) {
					var win = me.getProgressWindow();
					win.down('#identifyingMessage').getEl().down('div.x-mask-msg-text').setStyle('backgroundImage', 'none');
					win.down('#doneButton').setHidden(false);
	
					if (hasFailures && !has413Status) {
						win.down('#retryButton').setHidden(false).setDisabled(false).setHandler(function(btn) {
							me.load(Ext.apply({retryFailures: true}, params), callback);
							btn.setDisabled(true);
						}, me);
					} else {
						win.down('#retryButton').setHidden(true);
						if (firstCall) {
							win.close();
						}
					}
	
					callback.call(me, data.entities);
				} else {
					delete params.retryFailures;
					me.setTimeoutId(Ext.defer(me.doLoad, me.getUpdateDelay(), me, [params, callback, false]));
				}
			}
		}, function(err) {
			Voyant.application.showError(me.localize('error'));
			console.warn(err);
			callback.call(me, null);
		});
	},

	_getProgressFromStatus: function(statusArray) {
		var total = statusArray.length;
		var numDone = 0;
		var hasFailures = false;
		var statusCodes = [];
		statusArray.forEach(function(item) {
			if (item[1] === 'done') numDone++;
			else if (item[1].indexOf('failed') === 0) {
				numDone++;
				hasFailures = true;
				var statusCode = item[1].match(/\d\d\d$/);
				if (statusCode !== null) {
					statusCodes.push(statusCode[0]);
				}
			}
		});
		return [numDone, total, hasFailures, statusCodes];
	},

	updateProgress: function(statusArray, progressArray) {
		if (this.getProgressWindow() === undefined) {
			this.setProgressWindow(Ext.create('Ext.window.Window', {
				title: this.localize('identifyingDocEnts'),
				width: 400,
				height: 300,
				minimizable: true,
				closeAction: 'destroy',
				layout: {
					type: 'vbox',
					align: 'stretch',
					pack: 'center',
				},
				items: [{
					itemId: 'identifyingMessage',
					xtype: 'container',
					html: '<div style="text-align: center" class="x-mask-msg-text">'+this.localize('identifyingDocEnts')+'</div>',
					flex: .5,
					margin: '20 10 10 10'
				},{
					itemId: 'progressBar',
					xtype: 'progressbar',
					height: 20,
					margin: '0 10 10 10'
				},{
					xtype: 'dataview',
					flex: 1,
					margin: '0 10 10 10',
					scrollable: 'y',
					itemId: 'documentStatus',
					store: Ext.create('Ext.data.ArrayStore', {
						fields: ['docTitle', 'statusIcon', 'statusText']
					}),
					itemSelector: '.doc',
					tpl: [
					'<tpl for=".">',
						'<div class="doc">',
							'<i class="fa {statusIcon}" style="margin-right: 5px;"></i>',
							'<span class="" style="">{docTitle}</span>',
							'<span style="float: right">{statusText}</span>',
						'</div>',
					'</tpl>']
				}],
				tools: [{
					type: 'restore',
					itemId: 'restoreButton',
					hidden: true,
					handler: function(evt, el, owner, tool) {
						var win = owner.up('window');
						win.expand();
						win.anchorTo(Ext.getBody(), 'c-c', [0, -win.getBox().height], {duration: 250});
						tool.hide();
					}
				}],
				buttons: [{
					itemId: 'retryButton',
					xtype: 'button',
					text: this.localize('retry'),
					hidden: true
				},{
					itemId: 'doneButton',
					xtype: 'button',
					text: this.localize('done'),
					hidden: true,
					handler: function(btn) {
						btn.up('window').close();
					}
				}],
				listeners: {
					minimize: function(win) {
						win.collapse(Ext.Component.DIRECTION_BOTTOM, false);
						win.anchorTo(Ext.getBody(), 'br-br', [0,0], {duration: 250});
						win.down('#restoreButton').show();
					},
					destroy: function(win) {
						clearTimeout(this.getTimeoutId());
						this.setProgressWindow(undefined);
					},
					scope: this
				}
			}));
		}

		var numDone = progressArray[0];
		var total = progressArray[1];

		var win = this.getProgressWindow();
		
		win.down('#progressBar').updateProgress(numDone/total, numDone+' / '+total);
		
		var docsStore = Voyant.application.getCorpus().getDocuments();
		var statusWithDocTitles = statusArray.map(function(status, index) {
			var docTitle = docsStore.getById(status[0]).getShortTitle();
			var statusMsg = status[1];
			var statusIcon = 'fa-spinner';
			var statusText = '';//this.localize('statusStarted');
			if (statusMsg.indexOf('failed') === 0) {
				statusIcon = 'fa-exclamation-triangle';
				if (statusMsg.indexOf('413') !== -1) {
					statusText = this.localize('status413');
				} else {
					statusText = this.localize('statusFailed');
				}
				console.log('ner: '+docTitle+', '+statusMsg);
			} else if (statusMsg === 'done') {
				statusIcon = 'fa-check';
				statusText = '';//this.localize('statusDone');
			} else if (statusMsg === 'queued') {
				statusIcon = 'fa-clock-o';
				statusText = '';//this.localize('statusQueued');
			}
			return [docTitle, statusIcon, statusText];
		}, this);
		win.down('#documentStatus').getStore().loadData(statusWithDocTitles);

		win.setTitle(this.localize('identifyingDocEnts')+' '+numDone+' / '+total);

		win.show();
	}


});
/*
 * @class Corpus
 * Corpus is possibly the most important class since in most cases you'll first create/load a corpus and then
 * interact with data derived from the corpus. In the simplest scenario you can create/load a corpus with a
 * corpus ID, a text string, a URL, or an array of text strings or URLs (see the {@link #constructor} and 
 * {@link #input} config for a bit more information).
 * 
 * 	new Corpus("austen"); // load an existing corpus
 * 
 * 	new Corpus("Hello Voyant!"); // load a corpus with the specified text string
 * 
 * 	new Corpus("http://hermeneuti.ca/"); // load a corpus with a URL
 * 
 * It's important to understand that the constructor actually returns a promise for a corpus, since the corpus
 * data is loaded asynchronously. All documented methods below handle the promise properly.
 * 
 * 	new Corpus("Hello Voyant!").show(); // the show method is called when the promise is filled
 * 
 * You can also handle the promise yourself using {@link Ext.promise.Promise#then then}.
 * 
 * 	new Corpus("Hello Voyant!").then(function(corpus) {
 * 		corpus.show(); // essentially the same as above (but more work:)
 * 	});
 * 
 * There are many parameters that can be specified when creating a corpus:
 * 
 * - **sources**: {@link #corpus}, {@link #input}
 * - **formats**:
 * 	- **Text**: {@link #inputRemoveFrom}, {@link #inputRemoveFromAfter}, {@link #inputRemoveUntil}, {@link #inputRemoveUntilAfter}
 * 	- **XML**: {@link #xmlAuthorXpath}, {@link #xmlCollectionXpath}, {@link #xmlContentXpath}, {@link #xmlExtraMetadataXpath}, {@link #xmlKeywordXpath}, {@link #xmlPubPlaceXpath}, {@link #xmlPublisherXpath}, {@link #xmlTitleXpath}
 * 	- **Tables**: {@link #tableAuthor}, {@link #tableContent}, {@link #tableDocuments}, {@link #tableNoHeadersRow}, {@link #tableTitle}
 * - **other**: {@link #inputFormat}, {@link #subTitle}, {@link #title}, {@link #tokenization}
 */
Ext.define('Voyant.data.model.Corpus', {
	alternateClassName: ["Corpus"],
    mixins: ['Voyant.util.Transferable','Voyant.util.Localization'],
    transferable: ['loadCorpusTerms','loadTokens','getPlainText','getText','getWords','getString','getLemmasArray'],
//    transferable: ['getSize','getId','getDocument','getDocuments','getCorpusTerms','getDocumentsCount','getWordTokensCount','getWordTypesCount','getDocumentTerms'],
	requires: ['Voyant.util.ResponseError','Voyant.data.store.CorpusTerms','Voyant.data.store.Documents'/*,'Voyant.panel.Documents'*/],
    extend: 'Ext.data.Model',
    config: {
    	
    	/**
    	 * @cfg {String} corpus The ID of a previously created corpus.
    	 * 
    	 * A corpus ID can be used to try to retrieve a corpus that has been previously created.
    	 * Typically the corpus ID is used as a first string argument, with an optional second
    	 * argument for other parameters (especially those to recreate the corpus if needed).
    	 * 
    	 * 		new Corpus("goldbug");
    	 * 
    	 * 		new Corpus("goldbug", {
    	 *			// if corpus ID "goldbug" isn't found, use the input
    	 * 			input: "https://gist.githubusercontent.com/sgsinclair/84c9da05e9e142af30779cc91440e8c1/raw/goldbug.txt",
    	 * 			inputRemoveUntil: 'THE GOLD-BUG',
    	 * 			inputRemoveFrom: 'FOUR BEASTS IN ONE'
    	 * 		});
    	 */
    	
    	/**
    	 * @cfg {String/String[]} input Input sources for the corpus.
    	 * 
    	 * The input sources can be either normal text or URLs (starting with `http`).
    	 * 
    	 * Typically input sources are specified as a string or an array in the first argument, with an optional second argument for other parameters.
    	 * 
    	 * 		new Corpus("Hello Voyant!"); // one document with this string
    	 * 
    	 * 		new Corpus(["Hello Voyant!", "How are you?"]); // two documents with these strings
    	 * 
    	 * 		new Corpus("http://hermeneuti.ca/"); // one document from URL
    	 * 
    	 * 		new Corpus(["http://hermeneuti.ca/", "https://en.wikipedia.org/wiki/Voyant_Tools"]); // two documents from URLs
    	 * 
    	 * 		new Corpus("Hello Voyant!", "http://hermeneuti.ca/"]); // two documents, one from string and one from URL
    	 * 
    	 * 		new Corpus("https://gist.githubusercontent.com/sgsinclair/84c9da05e9e142af30779cc91440e8c1/raw/goldbug.txt", {
    	 * 			inputRemoveUntil: 'THE GOLD-BUG',
    	 * 			inputRemoveFrom: 'FOUR BEASTS IN ONE'
    	 * 		});
    	 * 
    	 * 		// use a corpus ID but also specify an input source if the corpus can't be found
    	 * 		new Corpus("goldbug", {
    	 * 			input: "https://gist.githubusercontent.com/sgsinclair/84c9da05e9e142af30779cc91440e8c1/raw/goldbug.txt",
    	 * 			inputRemoveUntil: 'THE GOLD-BUG',
    	 * 			inputRemoveFrom: 'FOUR BEASTS IN ONE'
    	 * 		});
    	 */
    	
    	/**
    	 * @cfg {String} inputFormat The input format of the corpus (the default is to auto-detect).
    	 * 
    	 * The auto-detect format is usually reliable and inputFormat should only be used if the default
    	 * behaviour isn't desired. Most of the relevant values are used for XML documents:
    	 * 
    	 * - **DTOC**: Dynamic Table of Contexts XML format
    	 * - **HTML**: Hypertext Markup Language
    	 * - **RSS**: Really Simple Syndication XML format
    	 * - **TEI**: Text Encoding Initiative XML format
    	 * - **TEICORPUS**: Text Encoding Initiative Corpus XML format
    	 * - **TEXT**: plain text
    	 * - **XML**: treat the document as XML (sometimes overridding auto-detect of XML vocabularies like RSS and TEI)
    	 * 
    	 * Other formats include **PDF**, **MSWORD**, **XLSX**, **RTF**, **ODT**, and **ZIP** (but again, these rarely need to be specified).
    	 */
    	
    	/**
    	 * @cfg {String} tableDocuments Determine what is a document in a table (the entire table, by row, by column); only used for table-based documents.
    	 * 
    	 * Possible values are:
    	 * 
    	 * - **undefined or blank** (default): the entire table is one document
    	 * - **rows**: each row of the table is a separate document
    	 * - **columns**: each column of the table is a separate document
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableContent Determine how to extract body content from the table; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableAuthor Determine how to extract the author from each document; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableTitle Determine how to extract the title from each document; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableContent Determine how to extract body content from the table; only used for table-based documents.
    	 * 
    	 * Columns are referred to by numbers, the first is column 1 (not 0).
    	 * You can specify separate columns by using a comma or you can combined the contents of columns/cells by using a plus sign.
    	 * 
    	 * Some examples:
    	 * 
    	 * - **1**: use column 1
    	 * - **1,2**: use columns 1 and 2 separately
    	 * - **1+2,3**: combine columns 1 and two and use column 3 separately
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tableNoHeadersRow Determine if the table has a first row of headers; only used for table-based documents.
    	 * 
    	 * Provide a value of "true" if there is no header row, otherwise leave it blank or undefined (default).
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tables).
    	 */
    	
    	/**
    	 * @cfg {String} tokenization The tokenization strategy to use
    	 * 
    	 * This should usually be undefined, unless specific behaviour is required. These are the valid values:
    	 * 
    	 * - **undefined or blank**: use the default tokenization (which uses Unicode rules for word segmentation)
    	 * - **wordBoundaries**: use any Unicode character word boundaries for tokenization
    	 * - **whitespace**: tokenize by whitespace only (punctuation and other characters will be kept with words)
    	 * 
    	 * See also [Creating a Corpus Tokenization](#!/guide/corpuscreator-section-tokenization).
    	 */
    	
    	/**
    	 * @cfg {String} xmlContentXpath The XPath expression that defines the location of document content (the body); only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><head>Hello world!</head><body>This is Voyant!</body></doc>", {
    	 * 			 xmlContentXpath: "//body"
    	 * 		}); // document would be: "This is Voyant!"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlTitleXpath The XPath expression that defines the location of each document's title; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><title>Hello world!</title><body>This is Voyant!</body></doc>", {
    	 * 			 xmlTitleXpath: "//title"
    	 * 		}); // title would be: "Hello world!"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */

    	/**
    	 * @cfg {String} xmlAuthorXpath The XPath expression that defines the location of each document's author; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><author>Stéfan Sinclair</author><body>This is Voyant!</body></doc>", {
    	 * 			 xmlAuthorXpath: "//author"
    	 * 		}); // author would be: "Stéfan Sinclair"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlPubPlaceXpath The XPath expression that defines the location of each document's publication place; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><pubPlace>Montreal</pubPlace><body>This is Voyant!</body></doc>", {
    	 * 			 xmlPubPlaceXpath: "//pubPlace"
    	 * 		}); // publication place would be: "Montreal"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */

    	/**
    	 * @cfg {String} xmlPublisherXpath The XPath expression that defines the location of each document's publisher; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><publisher>The Owl</publisher><body>This is Voyant!</body></doc>", {
    	 * 			 xmlPublisherXpath: "//publisher"
    	 * 		}); // publisher would be: "The Owl"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */

    	/**
    	 * @cfg {String} xmlKeywordXpath The XPath expression that defines the location of each document's keywords; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><keyword>text analysis</keyword><body>This is Voyant!</body></doc>", {
    	 * 			 xmlKeywordXpath: "//keyword"
    	 * 		}); // publisher would be: "text analysis"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlCollectionXpath The XPath expression that defines the location of each document's collection name; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><collection>documentation</collection><body>This is Voyant!</body></doc>", {
    	 * 			 xmlCollectionXpath: "//collection"
    	 * 		}); // publisher would be: "documentation"
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlGroupByXpath The XPath expression that defines the location of each document's collection name; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><sp s='Juliet'>Hello!</sp><sp s='Romeo'>Hi!</sp><sp s='Juliet'>Bye!</sp></doc>", {
    	 * 			 xmlDocumentsXPath: '//sp',
    	 *           xmlGroupByXpath: "//@s"
    	 * 		}); // two docs: "Hello! Bye!" (Juliet) and "Hi!" (Romeo)
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlExtraMetadataXpath A value that defines the location of other metadata; only used for XML-based documents.
    	 * 
    	 * 		new Corpus("<doc><tool>Voyant</tool><phase>1</phase><body>This is Voyant!</body></doc>", {
    	 * 			 xmlExtraMetadataXpath: "tool=//tool\nphase=//phase"
    	 * 		}); // tool would be "Voyant" and phase would be "1"
    	 * 
    	 * Note that `xmlExtraMetadataXpath` is a bit different from the other XPath expressions in that it's
    	 * possible to define multiple values (each on its own line) in the form of name=xpath.
    	 * 
    	 * See also [Creating a Corpus with XML](#!/guide/corpuscreator-section-xml).
    	 */
    	
    	/**
    	 * @cfg {String} xmlExtractorTemplate Pass the XML document through the XSL template located at the specified URL before extraction (this is ignored in XML-based documents).
    	 * 
    	 * This is an advanced parameter that allows you to define a URL of an XSL template that can
    	 * be called *before* text extraction (in other words, the other XML-based parameters apply
    	 * after this template has been processed).
    	 */

    	/**
    	 * @cfg {String} inputRemoveUntil Omit text up until the start of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveUntil: "This"
    	 * 		}); // document would be: "This is Voyant!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} inputRemoveUntilAfter Omit text up until the end of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveUntilAfter: "world!"
    	 * 		}); // document would be: "This is Voyant!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} inputRemoveFrom Omit text from the start of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveFrom: "This"
    	 * 		}); // document would be: "Hello world!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} inputRemoveFromAfter Omit text from the end of the matching regular expression (this is ignored in XML-based documents).
    	 * 
    	 * 		new Corpus("Hello world! This is Voyant!", {
    	 * 			 inputRemoveFromAfter: "world!"
    	 * 		}); // document would be: "Hello world!"
    	 * 
    	 * See also [Creating a Corpus with Text](#!/guide/corpuscreator-section-text).
    	 */
    	
    	/**
    	 * @cfg {String} subTitle A sub-title for the corpus.
    	 * 
    	 * This is currently not used, except in the Dynamic Table of Contexts skin. Still, it may be worth specifying a subtitle for later use.
    	 */
    	
    	/**
    	 * @cfg {String} title A title for the corpus.
    	 * 
    	 * This is currently not used, except in the Dynamic Table of Contexts skin. Still, it may be worth specifying a title for later use.
    	 */
    	 
    	 /**
    	 * @cfg {String} curatorTsv a simple TSV of paths and labels for the DToC interface
    	 *
    	 * The DToC skin allows curation of XML tags and attributes in order to constrain the entries shown in the interface or to provide friendlier labels. This assumes plain text unicode input with one definition per line where the simple XPath expression is separated by a tab from a label.
    	 *
    	 *   	 p    	 paragraph
    	 *   	 ref[@target*="religion"]    	 religion
    	 *
    	  * For more information see the DToC documentation on [Curating Tags](http://cwrc.ca/Documentation/public/index.html#DITA_Files-Various_Applications/DToC/CuratingTags.html)
    	 */
    	 
    	
    	
    	documentsStore: undefined
    },
    statics: {
    	i18n: {}
    },
    fields: [
         {name: 'documentsCount', type: 'int'},
         {name: 'lexicalTokensCount', type: 'int'},
         {name: 'lexicalTypesCount', type: 'int'},
         {name: 'createdTime', type: 'int'},
         {name: 'createdDate', type: 'date', dateFormat: 'c'},
         {name: 'title', type: 'string'},
         {name: 'subTitle', type: 'string'},
         {name: 'languagueCodes', type: 'string'}
    ],
    
	/**
     * Create a promise for a new Corpus with relevant data loaded.
     * 
     * The typical usage in Spyral is to call {@link #assign} in a first code block:
     * 
     * 		new Corpus("Hello Voyant!").assign("corpus");
     * 
     * Then use the named variable in a subsequent code block:
     * 
     * 	  corpus.show();
     * 
     * Alternatively, the returned promise can be chained with {@link Ext.promise.Promise#then then}
     * and a function argument that receives the Corpus as an argument.
     * 
     * 	var corpus;
     * 	new Corpus("Hello Voyant!").then(function(data) {
     * 		corpus = data;
     * 		corpus.show();
     * 	});
     * 
     * The following scenarios are possible for the config argument:
     * 
     * - a string that looks like a corpus ID (not a URL and no spaces): treated as a {@link #corpus} config
     * - a string that doesn't look like a corpus ID: treated as an {@link #input} config
     * - an array of strings: treated as an array of {@link #input} config values
     * - an object: treated a normal config object
     * 
     * As such, these two constructions do the same thing:
     * 
     * 	new Corpus("Hello World!");
     * 	new Corpus({input: "Hello World!"});
	 * @param  {String|String[]|Object} source The source document(s) as a text string, a URL, an array of text strings and URLs, or a config object.
     * @param {String|String[]|Object} [config] An additional config to use with the source.
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return a Corpus but a promise to return a Corpus when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * Corpus as an argument, as per the example above).
	 */
	constructor : function(source, config) {
		source = source || {};
		config = config || {};
				
		this.callParent([]); // only send config, not source
		
		var dfd = new Ext.Deferred();
		
		if (Ext.isString(source)) { // a string could be a corpus ID or an input string (text or URL)
			if (/\s/.test(source)==false && source.indexOf(":")==-1) { // looks like a corpus ID
				Ext.apply(config, {
					corpus: source
				});
			} else { // looks like input (text or URL)
				Ext.apply(config, {
					input: source
				});
			}
		} else if (Ext.isArray(source)) { // assume we have an array of texts or URLs
			Ext.apply(config, {
				input: source
			});
		} else if (Ext.isObject(source)) { // copy the source to the config
			Ext.apply(config, source);
		} else {
			Voyant.application.showError(this.localize("badDataTypeCorpus")+": ("+ (typeof source)+") "+source);
			Ext.defer(function() {
				dfd.reject(this.localize("badDataTypeCorpus")+": ("+ (typeof source)+") "+source)
			}, 50, this);
			return dfd.promise;
		}
		
		if (Ext.isObject(config)) {
			
			if (!config.corpus && !config.input && !config.inlineData) {
				Voyant.application.showError(this.localize("noCorpusOrInput")+": "+config);
				Ext.defer(function() {
					dfd.reject(this.localize("noCorpusOrInput")+": "+config)
				}, 50, this);
				return dfd.promise;
			}
			
			Ext.apply(config, {tool: 'corpus.CorpusMetadata'})

			var me = this;
			var promise = Ext.Ajax.request({
				url: Voyant.application.getTromboneUrl(),
				params: config
			}).then(function(response) {
				me.set(Ext.JSON.decode(response.responseText).corpus.metadata);
				// removed calls to set title and subtitle which should now be in metadata
				if (config.title || config.subTitle) {
					me.set('title', config.title);
					me.set('subTitle', config.subTitle);
				} else {
					// (removed calls for title and subtitle which should now be part of metadata
				}
				
				return me;
			}, function(response){
				Voyant.application.showResponseError(me.localize('failedCreateCorpus'), response);
				dfd.reject(me.localize('failedCreateCorpus'));
			}).then(function(corpus) {
				if (corpus.getDocumentsCount()==0) {
					Voyant.application.showError(me.localize("thisCorpus")+" "+me.localize("isEmpty")+".");
				}
				if (!('docsLimit' in config) || (config.docsLimit!==false && config.docsLimit>0)) {
					me.getDocuments().load({
						params: {
							limit: ('docsLimit' in config) ? config.docsLimit : me.getDocumentsCount()
						},
						callback: function(records, operation, success) {
							if (success) {
								me.setDocumentsStore(this);
								dfd.resolve(corpus)
							} else {
								dfd.reject(operation)
							}
						}
					})
				} else {
					dfd.resolve(corpus)
				}
			})
			return dfd.promise
		} else {
			Voyant.application.showError(this.localize("badDataTypeCorpus")+": ("+ (typeof config)+") "+config);
			Ext.defer(function() {
				dfd.reject(this.localize("badDataTypeCorpus")+": ("+ (typeof config)+") "+config)
			}, 50, this);
			return dfd.promise;
		}
	},
	
	getId: function() {
		// overrides the getId() function from the model to handle promises
    	return this.get('id');		
	},
	
	
	getAliasOrId: function() {
		// overrides the getId() function from the model to handle promises
    	return (this.get('alias') || this.get('id'));		
	},
	
	/**
     * Create a promise for {@link Voyant.data.store.CorpusTerms Corpus Terms}.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the {@link Voyant.data.store.CorpusTerms Corpus Terms} as an argument.
     * 
     * 	new Corpus("Hello Voyant!").loadCorpusTerms().then(function(corpusTerms) {
     * 		corpusTerms.show();
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of corpus terms to load (see {@link Voyant.data.store.CorpusTerms#limit})
     * - otherwise this is a regular config object
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return corpus terms but a promise to return a corpus terms when they're finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * corpus terms as an argument, as per the example above).
	 */
	loadCorpusTerms: function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config};
		}
		Ext.applyIf(config, {
			limit: 0
		})
		var corpusTerms = this.getCorpusTerms();
		corpusTerms.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(corpusTerms)
				} else {
					dfd.reject(operation)
				}
			}
		})
		return dfd.promise
	},
	
	/**
     * Create a promise for {@link Voyant.data.store.Tokens Tokens}.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the {@link Voyant.data.store.Tokens Tokens} as an argument.
     * 
     * 	new Corpus("Hello Voyant!").loadTokens().then(function(tokens) {
     * 		tokens.show();
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of corpus terms to load (see {@link Voyant.data.store.CorpusTerms#limit})
     * - otherwise this is a regular config object
     * 	- **limit**: the maximum number of tokens to return (default is no limit)
     * 	- **perDocLimit**: the maximum number of tokens to return per document
     * 	- **start**: where to start (when pageing, default is 0)
     * 	- **noOthers**: determine if only word tokens are returned (default is false)
     * 	- **withPosLemmas**: try to populate pos (part-of-speech) tags and lemmas (only works in English for now)
     * 	- **docIndex**: a comma-separated list of integers of document indices
     * 	- **docId**: a comma-separated list of document IDs
     * 	- **stopList**: the ID of an existing stopList resource or an array of words to skip
     * 	- **whitelist**: the ID of an existing whitelist resource or an array of words to keep
     * 
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return tokens but a promise to return tokens when they're finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * tokens as an argument, as per the example above).
	 */
	loadTokens: function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config};
		}
		Ext.applyIf(config, {
			limit: 0
		})
		var tokens = this.getTokens();
		tokens.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(tokens)
				} else {
					dfd.reject(operation)
				}
			}
		})
		return dfd.promise
	},
	
	getCorpusTerms: function(config) {
		return Ext.create("Voyant.data.store.CorpusTerms", Ext.apply(config || {}, {corpus: this}));
	},
	
	getTokens: function(config) {
		return Ext.create("Voyant.data.store.Tokens", Ext.apply(config || {}, {corpus: this}));
	},
	
	each: function(fn, scope) {
		this.getDocuments().each(function(doc, i) {
			fn.call(scope || doc, doc, i);
		})
	},
	
	map: function(fn, scope) {
		return this.getDocuments().getRange().map(function(doc, i) {
			return fn.call(scope || doc, doc, i)
		}, scope || this)
	},
	
	getCorpusCollocates: function(config) {
		return Ext.create("Voyant.data.store.CorpusCollocates", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocumentQueryMatches: function(config) {
		// not expected to be called before corpus is defined
		return Ext.create("Voyant.data.store.DocumentQueryMatches", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocumentTerms: function(config) {
		return Ext.create("Voyant.data.store.DocumentTerms", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocumentEntities: function(config) {
		return Ext.create("Voyant.data.store.DocumentEntities", Ext.apply(config || {}, {corpus: this}));
	},
	
	loadContexts: function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config};
		}
		Ext.applyIf(config, {
			limit: 0
		})
		var contexts = this.getContexts();
		contexts.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(contexts)
				} else {
					dfd.reject(operation)
				}
			}
		})
		return dfd.promise
	},
	
	getContexts: function(config) {
		return Ext.create("Voyant.data.store.Contexts", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocuments: function(config) {
		return this.getDocumentsStore() ? this.getDocumentsStore() : Ext.create("Voyant.data.store.Documents", Ext.apply(config || {}, {corpus: this}));
	},
	
	getDocument: function(config) {
		if (this.getDocumentsStore()) {
			if (config instanceof Voyant.data.model.Document) {
				return config;
			}
			else if (Ext.isNumeric(config)) {
				return this.getDocumentsStore().getAt(parseInt(config))
			}
			else if (Ext.isString(config)) {
				return this.getDocumentsStore().getById(config)
			}
		}
		return this.getDocumentsStore().getDocument(config);
	},
	
	getDocumentsCount: function() {
		return this.get('documentsCount');
	},
	
	getWordTokensCount: function() {
    	return this.get('lexicalTokensCount');
	},
	
	getWordTypesCount: function() {
    	return this.get('lexicalTypesCount');
	},
	
	getCreatedTime: function() {
    	return this.get('createdTime');		
	},
	
	requiresPassword: function() {
		var noPasswordAccess = this.getNoPasswordAccess();
		return noPasswordAccess=='NONE' || noPasswordAccess=='NONCONSUMPTIVE';
	},
	
	getNoPasswordAccess: function() {
		// overrides the getId() function from the model to handle promises
    	return this.get('noPasswordAccess');		
	},
	
	getTitle: function() {
		return this.get('title');		
	},
	
	getSubTitle: function() {
		return this.get('subTitle');		
	},
	
	getRelatedWords : function(config) {
		return Ext.create("Voyant.data.store.RelatedTerms", Ext.apply(config || {}, {corpus: this}))
	},
	
	loadRelatedWords : function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config};
		}
		Ext.applyIf(config, {
			limit: 0
		})
		var relatedTerms = this.getRelatedWords();
		relatedTerms.load({
			params: config,
			callback: function(records, operation, success) {
				if (success) {
					dfd.resolve(records)
				} else {
					dfd.reject(operation.error.response);
				}
			}
		})
		return dfd.promise
	},
		
	/**
     * Create a promise for a text representation of all the document bodies in the corpus.
     * 
     * This does NOT necessarily return the full original document, but rather the body or main
     * content, as extracted by Voyant. You can also request a {@link #plainText} version with
     * the tags stripped.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getText().then(function(text) {
     * 		show(text.replace(/</g, "&lt;")); // show the markup 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object that can contain the following:
     * 	 - `limit`: a limit on the total number of words (by default there's no limit)
     * 	 - `perDocLimit`: a limit on the number of words to fetch for each document (by default there's no limit)
     * 	 - `start`: start at this word index for each document
     * 	 - `stopList`: the ID of an existing stopList resource or an array of words to skip
     * 	 - `whitelist`: the ID of an existing whitelist resource or an array of words to keep
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return text but a promise to return text when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * text as an argument, as per the example above).
	 */
	getText: function(config) {
		var dfd = new Ext.Deferred();
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config}
		} else if (Ext.isString(config)) {
			config = {limit: parseInt(config)}
		};
		Ext.applyIf(config, {
			limit: 0,
			outputFormat: "text",
			template: "docTokens2text"
		});
		Ext.apply(config, {
			tool: 'corpus.DocumentTokens',
			corpus: this.getAliasOrId()
		});
		Ext.Ajax.request({
			url: Voyant.application.getTromboneUrl(),
			params: config,
			success: function(response, opts) {
				var text = response.responseText.trim();
				if (config.transformCase) {
					if (config.transformCase.indexOf("lower")>-1) {
						text = text.toLowerCase();
					} else if (config.transformCase.indexOf("upper")>-1) {
						text = text.toUpperCase();
					}
				}
				dfd.resolve(text);
			},
			failure: function(response, opts) {
				dfd.reject(response);
			},
			scope: this
		})
		return dfd.promise
    },
    
	/**
     * Create a promise for a plain text representation of all the text in the corpus.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getPlainText().then(function(text) {
     * 		show(text.trim().replace(/\s+/g, " ").substr(-150)); // show the end 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object – see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return text but a promise to return text when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * text as an argument, as per the example above).
	 */
    getPlainText: function(config) {
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config}
		} else if (Ext.isString(config)) {
			config = {limit: parseInt(config)}
		}
		Ext.apply(config, {
			template: "docTokens2plainText"
		});
		return this.getText(config);
    },

	/**
     * Create a promise for a string containing just the words from the corpus.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getWords().then(function(words) {
     * 		show(words); // show the words 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object – see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return the words but a promise to return words when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * words as a string argument, as per the example above).
	 */
    getWords: function(config) {
		config = config || {};
		if (Ext.isNumber(config)) {
			config = {limit: config}
		} else if (Ext.isString(config)) {
			config = {limit: parseInt(config)}
		};
		Ext.applyIf(config, {
			template: "docTokens2words"
		});
		return this.getText(config);
    },
	
	/**
     * Create a promise for a string containing just the words from the corpus.
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the text as an argument.
     * 
     * 	new Corpus("http://hermeneuti.ca").getWords().then(function(words) {
     * 		show(words); // show the words 
     * 	});
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object – see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return the words but a promise to return words when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * words as a string argument, as per the example above).
	 */
    getWordsArray: function(config) {
		var dfd = new Ext.Deferred();
		this.getWords(config).then(function(text) {
			dfd.resolve(text.split(" "));
		})
		return dfd.promise
    },
    
	/**
     * Create a promise for an array of lemmas from the corpus (only works for English).
     * 
     * The typical usage is to chain the returned promise with {@link Ext.promise.Promise#then then} and
     * provide a function that receives the lemmas as an argument.
     * 
	 * 	new Corpus("Hello world, I like Spyral notebooks!", {language: "en"}).getLemmasArray().then(function(lemmas) {
			show(lemmas.join(", "))
	 *  });
     * 
     * @param {Number/Object} config
     * 
     * - when this is a number, it's the maximum number of words to fetch (though there may be any number of other tokens, like punctuation and space (but no tags).
     * - otherwise this is a regular config object – see {@link #getText} for more details.
     * 
	 * @returns {Ext.promise.Promise} *Important*: This doesn't immediately return the words but a promise to return words when it's finished loading
	 * (you should normally chain the promise with {@link Ext.promise.Promise#then then} and provide a function that receives the
	 * words as a string argument, as per the example above).
	 */
    getLemmasArray: function(config) {
    	config = config || {};
		var dfd = new Ext.Deferred();
		Ext.applyIf(config, {
			template: "docTokens2lemmas",
			withPosLemmas: true,
			noOthers: true
		})
		this.getWords(config).then(function(text) {
			var lemmas = text.split(" ").map(function(word) {return word.substring(0, word.indexOf("/"))})
			dfd.resolve(lemmas);
		})
		return dfd.promise
    },

	/**
	 * Get the readability index for the documents in this corpus.
	 * @param {String} indexType Which index to use: 'automated', 'coleman-liau', 'dale-chall', 'fog', 'lix', 'smog'
	 * @param {Object} config A config object to limit the results to certain documents, using docIndex or docId keys
	 * 
	 * @returns {Ext.promise.Promise}
	 */
	 getReadability: function(indexType, config) {
		indexType = indexType === undefined ? 'coleman-liau' : indexType;
		config = config || {};
		
		var tool = 'corpus.';
		switch (indexType) {
			case 'automated':
				tool += 'DocumentAutomatedReadabilityIndex';
				break;
			case 'coleman-liau':
				tool += 'DocumentColemanLiauIndex';
				break;
			case 'dale-chall':
				tool += 'DocumentDaleChallIndex';
				break;
			case 'fog':
				tool += 'DocumentFOGIndex';
				break;
			case 'lix':
				tool += 'DocumentLIXIndex';
				break;
			case 'smog':
				tool += 'DocumentSMOGIndex';
				break;
		}

		Ext.apply(config, {
			corpus: this.getId(),
			tool: tool
		});

		var dfd = new Ext.Deferred();

		var corpus = this.getId();
		Ext.Ajax.request({
			url: Voyant.application.getTromboneUrl(),
			params: config
		}).then(function(response) {
			var data = Ext.JSON.decode(response.responseText);
			// remove extraneous json data
			var parentKey;
			for (var key in data) {
				if (key.indexOf('document') === 0) {
					parentKey = key;
					break;
				}
			}
			if (parentKey) {
				var indexKey;
				for (var subkey in data[parentKey]) {
					indexKey = subkey;
					break;
				}
				var readabilityKey = indexKey.substring(0,indexKey.length-2); // assume the indexKey ends in Indexes, so remove the "es"
				var indexData = data[parentKey][indexKey].map(function(item) {
					return {
						docIndex: item.docIndex,
						docId: item.docId,
						text: item.text,
						readability: item[readabilityKey] // standardize the key for the readability score
					}
				})
				dfd.resolve(indexData);
			} else {
				dfd.reject();
			}
		}, function(response){
			dfd.reject();
		});

		return dfd.promise;
	},
    
    /**
	 * Returns a one-line summary of this corpus.
	 * 
	 * @method getString
	 * @param {boolean} [withID] Includes the corpus ID in parentheses at the end, if true.
	 */
    getString: function(withID) {
		var size = this.getDocumentsCount();
		var message = this.localize('thisCorpus');
		if (size==0) {message += ' '+this.localize('isEmpty')+'.';}
		else {
			message+=' ';
			if (size>1) {
				message+=new Ext.XTemplate(this.localize('hasNdocuments')).apply({count: Ext.util.Format.number(size,"0,000")});
			}
			else {
				message+=this.localize('has1document');
			}
			message+=' '+new Ext.XTemplate(this.localize('widthNwordsAndNTypes')).apply({words: Ext.util.Format.number(this.getWordTokensCount(),"0,000"), types: Ext.util.Format.number(this.getWordTypesCount(),"0,000")})+'.'
			message+=" "+this.localize('created')+" ";
			var createdDate = this.get('createdDate');
			var now = new Date();
			if (Ext.Array.each([
		    				['year', Ext.Date.YEAR],
		    				['month', Ext.Date.MONTH],
		    				['day', Ext.Date.DAY],
		    				['hour', Ext.Date.HOUR],
		    				['minute', Ext.Date.MINUTE],
		    				['second', Ext.Date.SECOND]
		    	], function(time) {
        			if (Ext.Date.diff(createdDate, now, time[1])>(time[0]=='second' ? 1 : 0)) {
        				var count = Ext.Date.diff(createdDate, now, time[1]);
        				message+="<span class='info-tip' data-qtip='"+Ext.Date.format(createdDate, "Y-m-d, H:i:s")+"'>";
        				if (count==1) {message+=new Ext.XTemplate(this.localize(time[0]+'Ago')).apply({count: count, date: createdDate})}
        				else {message+=new Ext.XTemplate(this.localize(time[0]+'sAgo')).apply({count: count, date: createdDate})}
        				message+="</span>";
        				return false
        			}
				}, this
			)===true) { // if array returns true, none of the conditions matched, so say now
				message+=this.localize('now');
			}
			message+='.';
			
			message+='';
		}
		if (withID===true) {message+=' ('+this.getId()+")";}
		return message;
    }
    
    

});
Ext.define('Voyant.widget.CorpusSelector', {
	extend: 'Ext.form.field.ComboBox',
	mixins: ['Voyant.util.Localization', 'Voyant.util.Api'],
	alias: 'widget.corpusselector',
	statics: {
		i18n: {
		},
		api: {
			openMenu: undefined
		}
	},

	constructor: function(config) {
		config = config || {};
		
		// need to call here to get openMenu
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);

		var data = [['shakespeare',"Shakespeare's Plays"],['austen',"Austen's Novels"],['frank',"Mary Shelley's Frankenstein"]];	
		// check API and server option for open menu values
		if (this.getApiParam("openMenu")) {
			data = this.getStoreItemsFromDefinition(this.getApiParam("openMenu"));
		} else if (Voyant.application && Voyant.application.getOpenMenu && Voyant.application.getOpenMenu()) {
			var arg = Voyant.application.getOpenMenu();
			arg = decodeURIComponent(arg);
			arg = arg.replace(/\+/g,' ');
			if (arg.charAt(0)=='"' && arg.charAt(arg.length-1)=='"') {
				arg = arg.substring(1, arg.length-1);
			}
			data = this.getStoreItemsFromDefinition(arg);
		}
	
		Ext.applyIf(config, {
			fieldLabel: this.localize('chooseCorpus'),
			labelWidth: 125,
			width: 330,
			labelAlign: 'right',
			name:'corpus',
			queryMode:'local',
			store: data
		});
		this.callParent([config]);
	},

	initComponent: function(config) {
		config = config || {};
		this.callParent([config]);
	},
		
	getStoreItemsFromDefinition: function(definition) {
		var data = [], items = definition.split(";");
		for (var i=0; i<items.length; i++) {
			var nameValue = items[i].split(":");
			if (nameValue[0]) {
				data.push([nameValue[0],nameValue[1] ? nameValue[1] : nameValue[0]]);
			}
		}
		return data;
	}
})
Ext.define('Voyant.widget.ListEditor', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.listeditor',
    layout: 'hbox',
	margin: '0 0 5px 0',
    statics: {
    	i18n: {
    	}
    },
    initComponent: function(config) {
    	var me = this;
    	var value = this.up('window').panel.getApiParam(this.name);
    	var data = value ? [{name: value, value: value}] : [];
    	
    	data.splice(0, 0, {name : this.localize('none'),   value: ''},  {name : this.localize('new'),   value: 'new'})
    	Ext.apply(me, {
	    		items: [{
	    	        xtype: 'combo',
	    	        queryMode: 'local',
	    	        value: value,
	    	        triggerAction: 'all',
	    	        editable: true,
	    	        fieldLabel: this.localize(this.name+'Label'),
	    	        labelAlign: 'right',
	    	        name: this.name,
	    	        displayField: 'name',
	    	        valueField: 'value',
	    	        store: {
	    	            fields: ['name', 'value'],
	    	            data: data
	    	        }
	    		}, {width: 10}, {xtype: 'tbspacer'}, {
	    			xtype: 'button',
	    			text: this.localize('editList'),
		            ui: 'default-toolbar',
	    			handler: this.editList,
	    			scope: this
	    		}]
    	})
        me.callParent(arguments);
    },
    
    editList: function() {
    	var win = this.up('window');
    	var panel = win.panel;
    	var value = this.down('combo').getValue();
    	Ext.Ajax.request({
    	    url: panel.getTromboneUrl(),
    	    params: {
        		tool: 'resource.KeywordsManager',
        		list: value
    	    },
    	    success: function(response){
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var keywords = json.keywords.keywords.sort().join("\n");
    			Ext.Msg.show({
	    		    title: this.localize('editListTitle'),
	    		    message: this.localize('editListMessage'),
	    		    buttons: Ext.Msg.OKCANCEL,
	    		    buttonText: {
	    		        ok: this.localize('ok'),
	    		        cancel: this.localize('cancel')
	    		    },
	    		    icon: Ext.Msg.INFO,
	    		    prompt: true,
	    	        multiline: true,
	    	        value: keywords,
	    	        original: keywords,
	    	        fn: function(btn,value,list) {
	    	        	if (btn=='ok' && list.original!=value) {
	    	        		var combo = this.down('combo')
	    	        		if (Ext.String.trim(value).length==0) {
	    	        			combo.setValue('empty');
	    	        		}
	    	        		else {
	    	        	    	Ext.Ajax.request({
	    	        	    	    url: panel.getTromboneUrl(),
	    	        	    	    params: {
	    	        	        		tool: 'resource.StoredResource',
	    	        	    			storeResource: value
	    	        	    	    },
	    	        	    	    combo: combo,
	    	        	    	    success: function(response, req) {
	    	        	    	    	var json = Ext.util.JSON.decode(response.responseText);
	    	        	    	    	var store = req.combo.getStore();
	    	        	    	    	var value = 'keywords-'+json.storedResource.id;
	    	        	    	    	store.add({name: value, value: value});
	    	        	    	    	req.combo.setValue(value)
	    	        	    	    	req.combo.updateLayout()
	    	        	    	    },
	    	        	    	    scope: this
	    	        	    	})
	    	        		}
	    	        	}
	    	        },
	    	        scope: this
    			})
    	    },
    	    scope: this
    	});
    }
})
Ext.define('Voyant.widget.StopListOption', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.stoplistoption',
    layout: 'hbox',
	margin: '0 0 5px 0',
    statics: {
    		stoplists: {
    		    ar: "stop.ar.txt",
    			bg: "stop.bu.txt",
    			br: "stop.br.txt",
    			ca: "stop.ca.txt",
    			ckb: "stop.ku.txt",
    			cn: "stop.zh.txt",
    			cz: "stop.cz.txt",
    			de: "stop.de.txt",
    			el: "stop.el.txt",
    			en: "stop.en.txt",
    			es: "stop.es.txt",
    			eu: "stop.eu.txt",
    			fa: "stop.fa.txt",
    			fr: "stop.fr.txt",
    			ga: "stop.ga.txt",
    			gl: "stop.gl.txt",
    			grc: "stop.grc.txt",
				he: "stop.he.txt",
    			hi: "stop.hi.txt",
    			hu: "stop.hu.txt",
    			hy: "stop.hy.txt",
    			id: "stop.id.txt",
    			it: "stop.it.txt",
    			ja: "stop.ja.txt",
    			la: "stop.la.txt",
    			lv: "stop.lv.txt",
    			lt: "stop.lt.txt",
    			mu: "stop.multi.txt",
    			nl: "stop.nl.txt",
    			no: "stop.no.txt",
    			pt: "stop.pt.txt",
    			ro: "stop.ro.txt",
    			ru: "stop.ru.txt",
    			se: "stop.sv.txt",
    			th: "stop.th.txt",
    			tr: "stop.tr.txt",
				uk: "stop.uk.txt"
    		},
	    	i18n: {
	    		
	    	}
    },
    initComponent: function(config) {
    	var me = this;
    	var value = this.up('window').panel.getApiParam('stopList');
    	var data = [];
    	for (id in Voyant.widget.StopListOption.stoplists) {
    		data.push({name: this.localize(id), value: Voyant.widget.StopListOption.stoplists[id]})
    	}
    	data.sort(function(a,b) { // sort by label
    		return a.name < b.name ? -1 : 1;
    	})
    	data.splice(0, 0, {name : this.localize('auto'),   value: 'auto'}, {name : this.localize('none'),   value: ''},  {name : this.localize('new'),   value: 'new'})
    	Ext.apply(me, {
	    		items: [{
	    	        xtype: 'combo',
	    	        queryMode: 'local',
	    	        value: value,
	    	        triggerAction: 'all',
	    	        editable: true,
	    	        fieldLabel: this.localize('label'),
	    	        labelAlign: 'right',
	    	        name: 'stopList',
	    	        displayField: 'name',
	    	        valueField: 'value',
	    	        store: {
	    	            fields: ['name', 'value'],
	    	            data: data
	    	        }
	    		}, {width: 10}, {xtype: 'tbspacer'}, {
	    			xtype: 'button',
	    			text: this.localize('editList'),
		            ui: 'default-toolbar',
	    			handler: this.editList,
	    			scope: this
	    		}, {width: 10}, {
	    			xtype: 'checkbox',
	    			name: 'stopListGlobal',
	    			checked: true,
	    			boxLabel: this.localize('applyGlobally')
	    		}]
    	})
        me.callParent(arguments);
    },
    
    editList: function() {
    	var win = this.up('window');
    	var panel = win.panel;
    	var value = this.down('combo').getValue();
    	var corpusId = panel.getApplication && panel.getApplication().getCorpus ? panel.getApplication().getCorpus().getId() : undefined;
    	if (value=='auto' && !corpusId) {
    		Ext.Msg.show({
			    title: this.localize('noEditAutoTitle'),
			    message: this.localize('noEditAutoMessage'),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
    		return
    	}
    	Ext.Ajax.request({
    	    url: panel.getTromboneUrl(),
    	    params: {
        		tool: 'resource.KeywordsManager',
    			stopList: value,
    			corpus: corpusId
    	    },
    	    success: function(response){
    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	var keywords = json.keywords.keywords.sort().join("\n");
    			Ext.Msg.show({
	    		    title: this.localize('editStopListTitle'),
	    		    message: this.localize('editStopListMessage'),
	    		    buttons: Ext.Msg.OKCANCEL,
	    		    buttonText: {
	    		        ok: this.localize('ok'),
	    		        cancel: this.localize('cancel')
	    		    },
	    		    icon: Ext.Msg.INFO,
	    		    prompt: true,
	    	        multiline: true,
	    	        value: keywords,
	    	        original: keywords,
	    	        fn: function(btn,value,stoplist) {
	    	        	// force lowercase for simple stopword list since it's lexical (this may change if the widget is used elsewhere)	    	        	value = value.toLowerCase();
	    	        	value = value.toLowerCase();
	    	        	if (btn=='ok' && stoplist.original!=value) {
	    	        		var combo = this.down('combo')
	    	        		if (Ext.String.trim(value).length==0) {
	    	        			combo.setValue('empty');
	    	        		}
	    	        		else {
	    	        	    	Ext.Ajax.request({
	    	        	    	    url: panel.getTromboneUrl(),
	    	        	    	    params: {
	    	        	        		tool: 'resource.StoredResource',
	    	        	    			storeResource: value,
	    	        	    			corpus: corpusId
	    	        	    	    },
	    	        	    	    combo: combo,
	    	        	    	    success: function(response, req) {
	    	        	    	    	var json = Ext.util.JSON.decode(response.responseText);
	    	        	    	    	var store = req.combo.getStore();
	    	        	    	    	var value = 'keywords-'+json.storedResource.id;
	    	        	    	    	store.add({name: value, value: value});
	    	        	    	    	req.combo.setValue(value)
	    	        	    	    	req.combo.updateLayout()
	    	        	    	    },
	    	        	    	    scope: this
	    	        	    	})
	    	        		}
	    	        	}
	    	        },
	    	        scope: this
    			})
    	    },
    	    scope: this
    	});
    }
})
Ext.define('Voyant.widget.TermColorsOption', {
	extend: 'Ext.container.Container',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.termcolorsoption',
	layout: 'hbox',
	margin: '0 0 5px 0',
	statics: {
			i18n: {
				label: 'Term Colors',
				none: 'None',
				categories: 'Categories Only',
				categoriesTerms: 'Categories and Terms',
				applyGlobally: 'apply globally'
			}
	},
	initComponent: function(config) {
		var me = this;
		Ext.apply(me, {
			items: [{
				xtype: 'combo',
				queryMode: 'local',
				value: 'categories',
				fieldLabel: this.localize('label'),
				labelAlign: 'right',
				name: 'termColors',
				displayField: 'name',
				valueField: 'value',
				store: {
					fields: ['name', 'value'],
					data: [{
						name: this.localize('categories'),
						value: 'categories'
					},{
						name: this.localize('categoriesTerms'),
						value: 'terms'
					},{
						name: this.localize('none'),
						value: ''
					}]
				}
			}, {width: 20}, {
				xtype: 'checkbox',
				name: 'termColorsGlobal',
				checked: true,
				boxLabel: this.localize('applyGlobally')
			}],
			listeners: {
				boxready: function(cmp) {
					var win = cmp.up('window');
					var value = win.panel.getApiParam('termColors');
					cmp.down('combo').setValue(value);
				}
			}
		})
		me.callParent(arguments);
	}
});

/**
 * A column field for use in grid panels.
 * Uses the term's color for display.
 */
Ext.define('Voyant.widget.ColoredTermField', {
	extend: 'Ext.grid.column.Template',
	alias: 'widget.coloredtermfield',
	config: {
		useCategoriesMenu: false
	},
	initComponent: function() {
		var panel = this.up('gridpanel');

		if (this.getUseCategoriesMenu()) {
			this.categoriesMenu = Ext.create('Voyant.categories.CategoriesMenu', {
				panel: panel,
				listeners: {
					categorySet: function(src, cats) {
						var store = panel.getStore();
						store.removeAll();
    					store.load();
					}
				}
			});
			panel.on('rowcontextmenu', function(cmp, record, tr, rowIndex, evt) {
				evt.preventDefault();
					
				var terms = panel.getSelection().map(function(sel) { return sel.get('term') });
				this.categoriesMenu.setTerms(terms);
				this.categoriesMenu.showAt(evt.getXY());
			}, this);
		}

		var dataIndex = this.dataIndex;
		Ext.apply(this, {
			tpl: new Ext.XTemplate('<span style="{[this.getColorStyle(values.'+dataIndex+')]}; padding: 1px 3px; border-radius: 2px;">{'+dataIndex+'}</span>', {
				getColorStyle: function(term) {
					var termColors = panel.getApiParam('termColors');
					if (termColors !== undefined && termColors !== '' &&
						(termColors === 'categories' && panel.getApplication().getCategoriesManager().getCategoriesForTerm(term).length > 0) ||
						(termColors === 'terms')) {
						var bgColor = panel.getApplication().getColorForTerm(term);
						var textColor = panel.getApplication().getTextColorForBackground(bgColor);
						return 'background-color: rgb('+bgColor.join(',')+'); color: rgb('+textColor.join(',')+')';
					} else {
						return 'color: rgb(0,0,0)';
					}
				}
			})
		});
		this.callParent(arguments);
	}
});

Ext.define('Voyant.widget.QuerySearchField', {
    extend: 'Ext.form.field.Tag',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.querysearchfield',
	statics: {
		i18n: {
		}
	},
	config: {
		corpus: undefined,
		tokenType: 'lexical',
		isDocsMode: false,
		inDocumentsCountOnly: undefined,
		stopList: undefined,
		showAggregateInDocumentsCount: false,
		clearOnQuery: false,
		parentPanel: undefined,
		currentOriginalRawQueryPlan: undefined
	},
	hasCorpusLoadedListener: false,
	isClearing: false, // flag for clearOnQuery
    
    constructor: function(config) {
    	
    	config = config || {};
    	var itemTpl = config.itemTpl ? config.itemTpl : (config.inDocumentsCountOnly ?
    			('<tpl><tpl if="term.charAt(0)==\'@\'">{term}</tpl><tpl if="term.charAt(0)!=\'@\'">{term} ({inDocumentsCount})</tpl></tpl>') :
    			('<tpl><tpl if="term.charAt(0)==\'@\'">{term}</tpl><tpl if="term.charAt(0)!=\'@\'">{term} ({rawFreq})</tpl></tpl>'))
    	Ext.applyIf(config, {
    		minWidth: 100,
    		maxWidth: 200,
    		matchFieldWidth : false,
    		minChars: 2,
    	    displayField: 'term',
    	    valueField: 'term',
    	    filterPickList: true,
    	    createNewOnEnter: true,
    	    createNewOnBlur: false,
    	    autoSelect: false,
//    	    emptyText: this.localize('querySearch'),
    	    tpl: [
    	    	'<ul class="x-list-plain"><tpl for=".">',
    	    	'<li role="option" class="x-boundlist-item" style="white-space: nowrap;">'+itemTpl+'</li>',
    	    	'</tpl></ul>'
    	    ],
    	    triggers: {
    	        help: {
    	            weight: 2,
    	            cls: 'fa-trigger form-fa-help-trigger',
    	            handler: function() {
    	            	Ext.Msg.show({
    	            	    title: this.localize('querySearch'),
    	            	    message: this.getIsDocsMode() ? this.localize('querySearchDocsModeTip') : this.localize('querySearchTip'),
    	            	    buttons: Ext.OK,
    	            	    icon: Ext.Msg.INFO
    	            	});
    	            },
    	            scope: 'this'
    	        }
    	   }
    	})
    	if (config.showAggregateInDocumentsCount) {
    		config.triggers.count = {
	            cls: 'fa-trigger',
	            handler: 'onHelpClick',
	            scope: 'this',
	            hidden: true
    		}
    	}
    	if (config.clearOnQuery) {
    		this.setClearOnQuery(config.clearOnQuery);
    	}
        this.callParent(arguments);
    },
    initComponent: function(config) {

    	var me = this;

    	me.on("beforequery", function(queryPlan) {

    		if (queryPlan.query) {
    			queryPlan.query = queryPlan.query.trim();
    			
    			// set it in the raw state because we use it in the load event to add categories
    			var originalRawQueryPlan = queryPlan.query.toLowerCase();
    			this.setCurrentOriginalRawQueryPlan(queryPlan.query)
    			
    			if (queryPlan.query.charAt(0)!="@") {
	    			if (queryPlan.query.charAt(0)=="^") {
	    				queryPlan.query=queryPlan.query.substring(1)
	    				queryPlan.cancel = queryPlan.query.length==0; // cancel if it's just that character
	    			}
	    			if (queryPlan.query.charAt(0)=="*") { // convert leading wildcard to regex
	    				queryPlan.query = "."+queryPlan.query;
	    			}
	    			if (queryPlan.query.charAt(queryPlan.query.length-1)=='*' || queryPlan.query.charAt(queryPlan.query.length-1)=='|') {
	    				queryPlan.query=queryPlan.query.substring(0,queryPlan.query.length-1)
	    				queryPlan.cancel = queryPlan.query.length==0; // cancel if it's just that character
	    			}
	    			if (queryPlan.query.charAt(0)==".") {
	    				queryPlan.cancel = queryPlan.query.length< (/\W/.test(queryPlan.query.charAt(1)) ? 5 : 4) // cancel if we only have 3 or fewer after .
	    			}
	    			try {
	                    new RegExp(queryPlan.query);
		            }
		            catch(e) {
		            	queryPlan.cancel = true;
		            }
		            if (queryPlan.query.indexOf('"')>-1) { // deal with unfinished phrases
		            	if (queryPlan.query.indexOf(" ")==-1) {queryPlan.cancel=true} // no space in phrase
		            	if ((queryPlan.query.match(/"/) || []).length!=2) {queryPlan.cancel=true;} // not balanced quotes
		            }
		            if (queryPlan.query.indexOf("*")>-1) {
		            	// skip for multiword or pipes
		            	if (queryPlan.query.indexOf(" ")==-1 && queryPlan.query.indexOf("|")==-1) {
		            		queryPlan.query += ",^"+queryPlan.query;
		            	}
		            } else {
		            	queryPlan.query = queryPlan.query+"*"+ (queryPlan.query.indexOf(" ")==-1  && queryPlan.query.indexOf("|")==-1 ? ","+"^"+queryPlan.query+"*" : "")
		            }
    			} else if (queryPlan.query=="@") { // no letters yet
    				queryPlan.cancel = true;
    			}
	            
	            var parent = me.getParentPanel();
	            if (queryPlan.cancel==false && parent) {
	            	var originalRawQueryPlanWithoutAt = originalRawQueryPlan.charAt(0)=="@" ? originalRawQueryPlan.substring(1) : originalRawQueryPlan;
		            for (var cat in parent.getApplication().getCategoriesManager().getCategories()) {
		            	if (cat.toLowerCase().indexOf(originalRawQueryPlanWithoutAt)>-1) {
		            		queryPlan.query = "@"+cat+(originalRawQueryPlan.charAt(0)=="@" ? "" : ","+queryPlan.query);
		            	}
		            }	
	            }
    		}
	            
	            
    	}, this);
    	
    	me.on("change", function(tags, queries) {
    		
    		if (!me.isClearing) {
	    		queries = queries.map(function(query) {return query.replace(/^(\^?)\*/, "$1.*")});
	    		me.up('panel').fireEvent("query", me, queries);
	    		if (me.getClearOnQuery()) {
	    			me.isClearing = true;
	    			me.removeValue(me.getValueRecords());
	    		}
	    		if (me.triggers.count) {
	    			me.triggers.count.show();
	    			me.triggers.count.getEl().setHtml('0');
	    			if (queries.length>0) {
	    				me.getCorpus().getCorpusTerms().load({
	    					params: {
	    						query: queries.map(function(q) {return '('+q+')'}).join("|"),
				    			tokenType: me.getTokenType(),
				    			stopList: me.getStopList(),
				    			inDocumentsCountOnly: true
	    					},
	    					callback: function(records, operation, success) {
	    						if (success && records && records.length==1) {
	    							me.triggers.count.getEl().setHtml(records[0].getInDocumentsCount())
	    						}
	    					}
	    				})
	    			} else {
	    				me.triggers.count.hide();
	    			}
	    		}
    		} else {
    			me.isClearing = false;
    		}
    	});

    	// we need to make sure the panel is a voyantpanel
    	// so that we get loadedCorpus event after a call to Voyant.util.Toolable.replacePanel
    	var parentPanel = me.findParentBy(function(clz) {
    		return clz.mixins["Voyant.panel.Panel"];
		});
    	if (parentPanel != null) {
    		this.setParentPanel(parentPanel);
    		if (parentPanel.getCorpus && parentPanel.getCorpus()) {
    			me.on("afterrender", function(c) {
    				this.doSetCorpus(parentPanel.getCorpus());	
    			})
    			me.hasCorpusLoadedListener = true;    			
    		} else {
	    	    	parentPanel.on("loadedCorpus", function(src, corpus) {
	    	    		me.doSetCorpus(corpus);
	    	    	}, me);
	    	    	me.hasCorpusLoadedListener = true;    			
    		}
    	}
    	
    	me.on("afterrender", function(c) {
    		
    		if (me.hasCorpusLoadedListener === false) {
    			if (!me.getCorpus()) {
    	    		parentPanel = me.findParentBy(function(clz) {
    	    			return clz.mixins["Voyant.panel.Panel"];
        			});
    	    		if (parentPanel == null) {
    	    			parentPanel = me.up('window').panel;
    	    		}
    	    		var corpus = parentPanel.getApplication().getCorpus();
    				if (corpus !== undefined) {
    					me.doSetCorpus(corpus);
    				} else {
    					parentPanel.on("loadedCorpus", function(src, corpus) {
    						me.doSetCorpus(corpus);
    			    	}, me);
    					me.hasCorpusLoadedListener = true;
    				}
    			}
    		}
			
    		if (me.triggers && me.triggers.help) {
    			Ext.tip.QuickTipManager.register({
    				target: me.triggers.help.getEl(),
    				text: me.getIsDocsMode() ? me.localize('querySearchDocsModeTip') : me.localize('querySearchTip')
				});
			}
    		if (me.triggers && me.triggers.count) {
    			Ext.tip.QuickTipManager.register({
    				target: me.triggers.count.getEl(),
    				text: me.localize('aggregateInDocumentsCount')
				});
			}
    	});
    	
    	me.on("beforedestroy", function(c) {
    		
    		if (me.triggers && me.triggers.help) {
    			Ext.tip.QuickTipManager.unregister(me.triggers.help.getEl());
    		}
    		if (me.triggers && me.triggers.count) {
    			Ext.tip.QuickTipManager.unregister(me.triggers.count.getEl());
    		}
    	});
    	
    	me.callParent(arguments);
    },
    
    doSetCorpus: function(corpus) {
		
    	if (corpus != null) {
	    	this.setCorpus(corpus);
			var stopList = this.getStopList();
			if (stopList==undefined) {
	    		if (this.getApiParam) {this.setStopList(this.getApiParam("stopList"))}
	    		else {
	    			var parent = this.up("panel");
	    			while (parent) {
	    				if (parent && parent.getApiParam) {
		    				this.setStopList(parent.getApiParam("stopList"))
		    				break;
		    			}
	    				parent = parent.up("panel");
	    			}
	    		}
			}

			var categories = this.getApiParam ? this.getApiParam("categories") : undefined;
			if (!categories) {
    			var parent = this.up("panel");
    			while (parent) {
    				if (parent && parent.getApiParam) {
    					categories = parent.getApiParam('categories');
	    				break;
	    			}
    				parent = parent.up("panel");
    			}
			}
			var store = corpus.getCorpusTerms({				
				corpus: corpus.getAliasOrId(),
				proxy: {
					extraParams: {
			    			limit: 10,
			    			tokenType: this.tokenType,
			    			stopList: this.getStopList(),
			    			inDocumentsCountOnly: this.getInDocumentsCountOnly(),
			    			categories: categories
					}
				}
			});
//			store.on("load", function() {
//				this.fireEvent.apply(this, ["load"].concat(Array.prototype.slice.call(arguments)));
//			}, this);

			this.setStore(store);
    	}
    }
    
});

Ext.define('Voyant.widget.TotalPropertyStatus', {
    extend: 'Ext.Component',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.totalpropertystatus',
	statics: {
		i18n: {
		}
	},
    initComponent: function() {
        Ext.applyIf(this, {
            tpl: this.localize('totalPropertyStatus'),
            itemId: 'totalpropertystatus',
            style: 'margin-right:5px',
            listeners: {
            	afterrender: function(cmp) {
            		var grid = cmp.up('grid')
            		if (grid) {
            			var store = grid.getStore();
                        cmp.update({count: store.getTotalCount()});
            			store.on('datachanged', function(store) {
                            cmp.update({count: store.getTotalCount()});
                        });
            		}
            	}
            }
        });
        this.callParent(arguments);
    }
});

Ext.define('Voyant.widget.DocumentSelector', {
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.documentselector',
	glyph: 'xf10c@FontAwesome',
	statics: {
		i18n: {
		}
	},

	config: {
		docs: undefined,
		corpus: undefined,
		singleSelect: false
	},
	
    initComponent: function() {

		var me = this;
		
		this.setSingleSelect(this.config.singleSelect == undefined ? this.getSingleSelect() : this.config.singleSelect);
		
		Ext.apply(me, {
			text: this.localize('documents'),
			menu: {
				width: 250,
				fbar: [{
					xtype: 'checkbox',
					hidden: this.getSingleSelect(),
					boxLabel: this.localize("all"),
					listeners: {
						change: {
							fn: function(item, checked) {
								this.getMenu().items.each(function(item) {
									item.setChecked(checked);
								});
							},
							scope: this
						}
					}
				},{xtype:'tbfill'},{
		    		xtype: 'button',
		    		text: this.localize('ok'),
					hidden: this.getSingleSelect(),
	    	    	scale: 'small',
		    		handler: function(button, e) {
		    			var docs = [];
		    			this.getMenu().items.each(function(item) {
		    				if (item.checked) {
			    				docs.push(item.docId);
		    				}
		    			}, this);
		    			
		    			// tell parent tool
						var panel = button.findParentBy(function(clz) {
							return clz.mixins["Voyant.panel.Panel"];
						});
						if (panel) {
			    			panel.fireEvent('documentsSelected', button, docs);
						}

		    			// hide the opened menu
		    			button.findParentBy(function(clz) {
		    				if (clz.isXType("button") && clz.hasVisibleMenu()) {
		    					clz.hideMenu();
		    					return true;
		    				}
		    				return false;
		    			});
		    		},
		    		scope: this
		    	},{
		    		xtype: 'button',
		    		text: this.localize('cancel'),
	    	    	scale: 'small',
		    		handler: function(b, e) {
		    			this.findParentBy(function(clz) {
		    				if (clz.isXType("button") && clz.hasVisibleMenu()) {
		    					clz.hideMenu();
		    					return true;
		    				}
		    				return false;
		    			}, this);
		    			this.hideMenu();
		    		},
		    		scope: this
		    	}]
			},
			listeners: {
				afterrender: function(selector) {
					selector.on("loadedCorpus", function(src, corpus) {
						this.setCorpus(corpus);
						if (corpus.getDocumentsCount()==1) {
							this.hide();
						} else {
							selector.populate(corpus.getDocumentsStore().getRange(), true);
						}
					}, selector);
					var panel = selector.findParentBy(function(clz) {
						return clz.mixins["Voyant.panel.Panel"];
					});
					if (panel) {
						panel.on("loadedCorpus", function(src, corpus) {
							selector.fireEvent("loadedCorpus", src, corpus);
						}, selector);
						if (panel.getCorpus && panel.getCorpus()) {selector.fireEvent("loadedCorpus", selector, panel.getCorpus());}
						else if (panel.getStore && panel.getStore() && panel.getStore().getCorpus && panel.getStore().getCorpus()) {
							selector.fireEvent("loadedCorpus", selector, panel.getStore().getCorpus());
						}
					}
				}
			}
		});


    },
    
    populate: function(docs, replace) {
    	this.setDocs(docs);
    	
    	var menu = this.getMenu();
    	if (replace) {
    		menu.removeAll();
    	}
    	
    	var isSingleSelect = this.getSingleSelect();
    	
    	var groupId = 'docGroup'+Ext.id();
    	docs.forEach(function(doc, index) {
    		menu.add({
    			xtype: 'menucheckitem',
    			text: doc.getShortTitle(),
    			docId: doc.get('id'),
    			checked: isSingleSelect && index == 0 || !isSingleSelect,
    			group: isSingleSelect ? groupId : undefined,
    			checkHandler: function(item, checked) {
    				if (this.getSingleSelect() && checked) {
    					var panel = this.findParentBy(function(clz) {
    						return clz.mixins["Voyant.panel.Panel"];
    					});
    					if (panel) {
	    					panel.fireEvent('documentSelected', this, doc);
    					}
    				}
    			},
    			scope: this
    		});
    	}, this);
    	
    }
});

Ext.define('Voyant.widget.DocumentSelectorButton', {
    extend: 'Ext.button.Button',
    alias: 'widget.documentselectorbutton',
    mixins: ['Voyant.widget.DocumentSelector'],
    initComponent: function() {
    	this.mixins["Voyant.widget.DocumentSelector"].initComponent.apply(this, arguments);
		this.callParent();
    }
})
    
Ext.define('Voyant.widget.DocumentSelectorMenuItem', {
    extend: 'Ext.menu.Item',
    alias: 'widget.documentselectormenuitem',
    mixins: ['Voyant.widget.DocumentSelector'],
    initComponent: function() {
    	this.mixins["Voyant.widget.DocumentSelector"].initComponent.apply(this, arguments);
		this.callParent();
    }
})

Ext.define('Voyant.widget.CorpusDocumentSelector', {
    extend: 'Ext.button.Button',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.corpusdocumentselector',
	statics: {
		i18n: {
		}
	},
	config: {
		corpus: undefined,
		singleSelect: false
	},
	
    initComponent: function() {
		var me = this;
		
		this.setSingleSelect(this.config.singleSelect == undefined ? this.getSingleSelect() : this.config.singleSelect);
		
		Ext.apply(me, {
			text: this.localize('scale'),
			glyph: 'xf059@FontAwesome',
			menu: {
				items: [{
					text: this.localize("corpus"),
					glyph: 'xf111@FontAwesome',
					handler: function(button) {
						var panel = this.findParentBy(function(clz) {
							return clz.mixins["Voyant.panel.Panel"];
						});
						if (panel) {
							button.nextSibling().menu.items.each(function(item) {
								item.setChecked(false, true);
							});
							panel.fireEvent("corpusSelected", this, this.getCorpus());
						}
					},
					scope: this
				},{
					xtype: 'documentselectormenuitem',
					singleSelect: this.getSingleSelect()
				}]
			},
			listeners: {
				afterrender: function(selector) {
					selector.on("loadedCorpus", function(src, corpus) {
						this.setCorpus(corpus);
						if (corpus.getDocumentsCount()==1) {
							this.hide();
						}
					}, selector);
					var panel = selector.findParentBy(function(clz) {
						return clz.mixins["Voyant.panel.Panel"];
					});
					if (panel) {
						panel.on("loadedCorpus", function(src, corpus) {
							selector.fireEvent("loadedCorpus", src, corpus);
						}, selector);
						if (panel.getCorpus && panel.getCorpus()) {selector.fireEvent("loadedCorpus", selector, panel.getCorpus())}
						else if (panel.getStore && panel.getStore() && panel.getStore().getCorpus && panel.getStore().getCorpus()) {
							selector.fireEvent("loadedCorpus", selector, panel.getStore().getCorpus());
						}
					}
				}
			}
		});

		me.callParent(arguments);	
    }
});
Ext.define('Voyant.widget.DownloadFilenameBuilder', {
    extend: 'Ext.form.FieldContainer', //'Ext.container.Container',
    mixins: ['Voyant.util.Localization', 'Ext.form.field.Field'],
    alias: 'widget.downloadfilenamebuilder',
	statics: {
		i18n: {
		}
	},
	config: {
	    name: 'documentFilename',
	    itemId: 'documentFilename',
		fields: ['pubDate', 'title', 'author'],
		value: ['pubDate', 'title'],
		width: 400
	},
	

    initComponent: function(config) {
    	config = config || {};
        var me = this;
        
        me.initField();

        me.on('afterrender', function() {
        	this.items.eachKey(function(key) {
        		new Ext.dd.DropZone(this.items.get(key).getTargetEl(), {
        			ddGroup: 'downloadfilename',
        			getTargetFromEvent: function(e) {
        				var target = e.getTarget();
        				// check that we're not dropping on another source
        				return target.className && target.className.indexOf('dragsource')>-1 ? target.parentNode : target;
        	        },
        	        onNodeDrop : function(target, dd, e, data){
        	        	target.appendChild(dd.el.dom);
        	            return true;
        	        }
        		});
        	}, this)
        	
        	this.getFields().map(function(item) {
        		item = Ext.isString(item) ? {
            		tag: 'span',
            		html: this.localize(item+"Label"),
            		value: item
        		} : item;
        		var container = this.queryById(Ext.Array.contains(this.getValue(), item.value) ? 'enabled' : 'available')
				var el = Ext.dom.Helper.append(container.getTargetEl(), Ext.apply(item, {cls: 'dragsource'}));
    			Ext.create('Ext.dd.DragSource', el, {
    				ddGroup: 'downloadfilename'
                });
        	}, this)
        }, me);
        me.callParent(arguments);
    }, 
    defaults: {
    	xtype: 'container',
    	width: '100%'
    },
    items: [{
    	itemId: 'enabled',
    	cls: 'dropzone dropzone-enabled'
    }, {
    	itemId: 'available',
    	cls: 'dropzone dropzone-disabled'
    }],
    
    
    getValue: function() {
    	return this.rendered ? this.getTargetEl().query('.dropzone-enabled .dragsource').map(function(source) {return source.getAttribute('value')}) : this.value;
    },
    
    setValue: function(val) {
    	if (this.rendered) {
        	this.getTargetEl().query(".dragsource", false).forEach(function(source) {
        		var enabled = Ext.Array.contains(this.value, source.getAttribute('value'))
        		if (enabled && source.parent().hasCls('dropzone-disabled')) {
        			this.queryById('enabled').getTargetEl().appendChild(source.dom);
        		} else if (!enabled && source.parent().hasCls('dropzone-enabled')) {
        			this.queryById('available').getTargetEl().appendChild(source.dom);
        		}
        	}, this)
    	} else {
    		this.value = val;
    	}
    }
    
    
});

Ext.define('Voyant.widget.DownloadFileFormat', {
    extend: 'Ext.form.CheckboxGroup', //'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.downloadfileformat',
	statics: {
		i18n: {
		}
	},
    initComponent: function(config) {
    	config = config || {};
        var me = this;
        
        Ext.apply(this, {
        	labelAlign: config.labelAlign ? config.labelAlign : 'right'
        })

        Ext.applyIf(this, {
        	fieldLabel: this.localize('fieldLabel'),
        	items: [
	            {boxLabel: this.localize('original'), name: 'documentFormat', inputValue: 'SOURCE'},
	            {boxLabel: this.localize('voyantXml'), name: 'documentFormat', inputValue: 'VOYANT'},
                {boxLabel: this.localize('plainText'), name: 'documentFormat', inputValue: 'TXT'}
        	],
        	width: 450
        })
        me.on('afterrender', function() {
        	this.query('checkbox').forEach(function(cmp) {
        		var tooltip = this.localize(cmp.inputValue+"Tip");
        		if (tooltip.indexOf(cmp.inputValue+"Tip")==-1) {
		        	Ext.tip.QuickTipManager.register({
		                 target:cmp.getEl(),
		                 text: tooltip
		             });
        		}
        	}, this)
        }, this)
        me.on('beforedestroy', function() {
        	this.query('checkbox').forEach(function(cmp) {
        		Ext.tip.QuickTipManager.unregister(cmp.getEl());
        	}, this);
        }, this);

        me.callParent(arguments);
    }
});

Ext.define('Voyant.widget.DownloadOptions', {
    extend: 'Ext.form.FieldSet',
    mixins: ['Voyant.util.Localization'],
    requires: ['Voyant.widget.DownloadFileFormat', 'Voyant.widget.DownloadFilenameBuilder'],
    alias: 'widget.downloadoptions',
	statics: {
		i18n: {
		}
	},
	config: {
		items: [{xtype: 'downloadfileformat'}, {xtype: 'downloadfilenamebuilder'}]
	},
    initComponent: function(config) {
    	config = config || {};
    	var me = this;
        Ext.apply(this, {
        	title: config.title ? config.title : this.localize('title')
        })
        me.callParent(arguments);
    }
});

Ext.define('Voyant.widget.FontFamilyOption', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.fontfamilyoption',
    statics: {
    	i18n: {
    	},
    	fonts: [{name: "Georgia", value: 'Georgia, serif'},
	            {name: "Palatino", value: '"Palatino Linotype", "Book Antiqua", Palatino, serif'},
	            {name: "Times New Roman", value: '"Times New Roman", Times, serif'},
	            {name: "Arial", value: 'Arial, Helvetica, sans-serif'},
	            {name: "Arial Black", value: '"Arial Black", Gadget, sans-serif'},
	            {name: "Comic Sans MS", value: '"Comic Sans MS", cursive, sans-serif'},
	            {name: "Impact", value: 'Impact, Charcoal, sans-serif'},
	            {name: "Lato", value: 'LatoWeb'},
	            {name: "Lucida", value: '"Lucida Sans Unicode", "Lucida Grande", sans-serif'},
	            {name: "Tahoma/Geneva", value: 'Tahoma, Geneva, sans-serif'},
	            {name: "Trebuchet MS/Helvetica", value: '"Trebuchet MS", Helvetica, sans-serif'},
	            {name: "Verdana/Geneva", value: 'Verdana, Geneva, sans-serif'},
	            {name: "Courrier New", value: '"Courier New", Courier, monospace'},
	            {name: "Lucida/Monaco", value: '"Lucida Console", Monaco, monospace'}]
    },
    name: 'fontFamily',
    initComponent: function(config) {
    	config = config || {};
    	var me = this;
    	var value = this.up('window').panel.getApiParam('fontFamily');
    	var data = Ext.ClassManager.getClass(this).fonts;

    	if (!Ext.Array.contains(data.map(function(item) {return item.value}), value)) {
        	data.splice(0, 0, {name : value, value: value});//
    	}
    	
    	Ext.apply(me, {
    		items: {
    			xtype: 'combo',
    	        queryMode: 'local',
    	        name: 'fontFamily',
    	        value: value,
    	        triggerAction: 'all',
    	        editable: true,
    	        fieldLabel: this.localize('label'),
    	        labelAlign: 'right',
    	        displayField: 'name',
    	        valueField: 'value',
    	        store: {
    	            fields: ['name', 'value'],
    	            data: data
    	        },
    	        width: 400
    		}
    	})
        me.callParent(arguments);
    }
})
Ext.define('Voyant.widget.ColorPaletteOption', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.colorpaletteoption',
    layout: 'hbox',
	margin: '0 0 5px 0',
    statics: {
    	i18n: {
    	}
    },
    
    paletteTpl: new Ext.XTemplate(
		'<tpl for=".">',
			'<div class="color" style="background-color: rgb({color});"></div>',
		'</tpl>'
	),
	paletteStore: new Ext.data.ArrayStore({
        fields: ['id', 'color'],
        listeners: {
        	update: function(store, record, op, mod, details) {
        	},
        	scope: this
        } 
    }),
    
    editPaletteWin: null,
    spectrum: null,
    
    initComponent: function(config) {
    	var me = this;

    	var app = this.up('window').panel.getApplication();
    	var data = [];
    	for (var key in app.getPalettes()) {
    		data.push({name: key, value: key});
    	}
    	var value = app.getApiParam('palette');
    	
    	Ext.apply(me, {
	    		items: [{
	    	        xtype: 'combo',
	    	        queryMode: 'local',
	    	        value: value,
	    	        triggerAction: 'all',
	    	        editable: true,
	    	        fieldLabel: me.localize('palette'),
	    	        labelAlign: 'right',
	    	        name: 'palette',
	    	        displayField: 'name',
	    	        valueField: 'value',
	    	        store: {
	    	            fields: ['name', 'value'],
	    	            data: data
	    	        }
	    		}, {width: 10}, {xtype: 'tbspacer'}, {
	    			xtype: 'button',
	    			text: this.localize('editList'),
		            ui: 'default-toolbar',
	    			handler: this.editPalette,
	    			scope: this
	    		}
//	    		, {width: 10}, {
//	    			xtype: 'checkbox',
//	    			name: 'paletteGlobal',
//	    			checked: true,
//	    			boxLabel: this.localize('applyGlobally')
//	    		}
	    		]
    	});
        me.callParent(arguments);
    },
    
    editPalette: function() {
    	var value = this.down('combo').getValue();
    	this.loadPalette(value);
    	
    	this.editPaletteWin = Ext.create('Ext.window.Window', {
			title: this.localize('paletteEditor'),
			modal: true,
			height: 300,
			width: 425,
			padding: 5,
			layout: {
				type: 'hbox',
				align: 'stretch'
			},
			items:[{
				flex: 1,
				layout: {
					type: 'vbox',
					align: 'stretch'
				},
				items: [{
					height: 24,
					margin: '0 0 5 0',
					items: [{
						xtype: 'button',
						text: this.localize('add'),
						margin: '0 5 0 0',
						handler: function(btn) {
							var color = this.spectrum.spectrum('get').toRgb();
							var dv = this.editPaletteWin.down('dataview');
							this.paletteStore.add([ [Ext.id(), [color.r, color.g, color.b]] ]);
							dv.refresh();
						},
						scope: this
					},{
						xtype: 'button',
						text: this.localize('remove'),
						margin: '0 5 0 0',
						handler: function(btn) {
							var dv = this.editPaletteWin.down('dataview');
							var sel = dv.getSelectionModel().getSelection()[0];
							if (sel != null) {
								this.paletteStore.remove(sel);
							}
							dv.refresh();
						},
						scope: this
					},{
						xtype: 'button',
						text: this.localize('clear'),
						handler: function(btn) {
							this.paletteStore.removeAll();
						},
						scope: this
					}]
				},{
					xtype: 'dataview',
					flex: 1,
					scrollable: 'y',
		        	store: this.paletteStore,
		        	tpl: this.paletteTpl,
		        	itemSelector: 'div.color',
		        	overItemCls: 'over',
		        	selectedItemCls: 'selected',
		        	selectionModel: {
		        		mode: 'SINGLE'
		        	},
		        	listeners: {
		        		selectionchange: function(viewmodel, selected, opts) {
		        			if (selected[0] != null) {
								var color = selected[0].get('color');
								var parentPanel = this.up('window').panel;
								var hex = parentPanel.getApplication().rgbToHex(color);
								this.spectrum.spectrum('set', hex);
							}
		        		},
		        		scope: this
		        	}
				}]
			},{
				itemId: 'colorEditor',
				width: 200,
				margin: '0 0 0 5',
				html: '<input type="text" style="display: none;" />'
			}],
			buttons: [{
				text: this.localize('saveNewPalette'),
				handler: function(btn) {
					this.savePalette();
					btn.up('window').close();
				},
				scope: this
			},{
				text: this.localize('cancel'),
				handler: function(btn) {
					btn.up('window').close();
				},
				scope: this
			}],
			listeners: {
				close: function(panel) {
					if (this.spectrum) {
						this.spectrum.spectrum('destroy');
						this.spectrum = null;
					}
				},
				scope: this
			}
    	}).show();
    	
    	this.initSpectrum();
    },
    
    setColorForSelected: function(color) {
    	if (this.spectrum !== null) { // need check due to https://github.com/bgrins/spectrum/issues/387
			var rgb = color.toRgb();
			var rgbA = [rgb.r, rgb.g, rgb.b];
			var dv = this.editPaletteWin.down('dataview');
			var sel = dv.getSelectionModel().getSelection()[0];
			if (sel != null) {
				sel.set('color', rgbA);
			}
    	}
	},
    
	initSpectrum: function() {
		if (this.spectrum === null) {
			var editor = this.editPaletteWin.down('#colorEditor');
			var input = editor.el.down('input');
			this.spectrum = $(input.dom).spectrum({
				flat: true,
				showInput: true,
				showButtons: false,
				preferredFormat: 'hex',
				change: this.setColorForSelected.bind(this),
				move: this.setColorForSelected.bind(this)
			});
		}
	},
	
    loadPalette: function(paletteId) {
    	var application = this.up('window').panel.getApplication();
    	
    	var palette = application.getColorPalette(paletteId);

		if (palette == undefined) {
			application.loadCustomColorPalette(paletteId).then(function(id) {
				this.loadPalette(paletteId);
			}.bind(this), function() {
				// error loading palette
			})
		} else {
			var paletteData = [];
			palette.forEach(function(c) {
				paletteData.push([Ext.id(), c]);
			}, this);
			this.paletteStore.loadData(paletteData);
		}
    },
    
    savePalette: function() {
    	var value = [];
    	this.paletteStore.each(function(c) {
    		value.push(c.get('color'));
    	});
    	
		this.up('window').panel.getApplication()
			.saveCustomColorPalette(value).then(function(id) {
				var combo = this.down('combo');
				var store = combo.getStore();
				store.add({name: id, value: id});
				combo.setValue(id);
				combo.updateLayout();
			}.bind(this));
    }
});
Ext.define('Voyant.widget.VoyantChart', {
    extend: 'Ext.chart.CartesianChart',
    mixins: ['Voyant.util.Localization','Voyant.util.Api'],
    alias: 'widget.voyantchart',
    statics: {
    	i18n: {
    	},
    	api: {
    		tableJson: undefined
    	}
    },
    constructor: function(config) {
    	config = config || {};
    	var me = this;
    	this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	this.callParent(arguments)
    	
    },
    initComponent: function(config) {
    	config = config || {};
    	this.on("afterrender", function() {
        	if (config && "tableJson" in config) {
        		Ext.apply(this, this.getConfigFromTableJson(config.tableJson));
        	}
        	else if (this.getApiParam('tableJson')) {
        		var chart = this.getConfigFromTableJson();
        		this.setAxes(chart.axes);
        		this.setSeries(chart.series);
        		this.setLegend(chart.legend);
        		this.setStore(chart.store);
        		this.redraw();
        	}
    	}, this)
    	this.callParent(arguments)
    },
    
    getConfigFromTableJson: function(jsonString) {
    	jsonString = jsonString || this.getApiParam('tableJson');
    	if (!jsonString) {return {}};
    	
		var json = JSON.parse(jsonString);
		
		json.headers = json.headers.map(function(header) {return header})
		// if we have only one column add a second column with a counter (as category)
		if (json.headers.length==1) {
			json.headers.push(1);
			json.rowKey = 1;
			json.rows.forEach(function(row, i) {if (row) {row.push(i)}})
		}
		
		// data
		var data = [];
		if (!json.rowKey) {json.rowKey=json.headers[0];}
		json.rows.forEach(function(row, i) {
			if (row) {
				var map = {};
				map[json.rowKey] = i;
				row = row.forEach(function(cell, j) {
					map[json.headers[j]] = cell
				})
				data.push(map);
			}
		})

		// start chart
		if (!json.config) {json.config = {}}
		var chart = {
			store: {
		        fields: Object.keys(data[0]),
		        data: data
			},
	        axes: Ext.isArray(json.config.axes) ? json.config.axes : [{},{}],
	        series: [],
    		legend: json.config.noLegend || Object.keys(data[0]).length<3 ? undefined : {docked:'top'}

		}

		// axes
		if (!json.config.axes) {json.config.axes = [{},{}]}
		chart.axes.forEach(function(axis, i) {
			if (Ext.isObject(json.config.axes)) {
				Ext.apply(axis, json.config.axes);
			} else if (Ext.isArray(json.config.axes)) {
				Ext.apply(axis, json.config.axes[i]);
			}
			Ext.applyIf(axis, {
	        	type: i==0 ? 'numeric' : 'category',
	        	position: i==0 ? 'left' : 'bottom',
	        	label: i==0 ? {} : {rotation: {degrees:-30}}
	        });
		})

		// series
		for (var i=0, len=json.headers.length; i<len;i++) {
			if (json.headers[i]==json.rowKey) {continue;} // don't chart the row key, that's the x axis 
			var cfg = {};
			if (json.config.series) {
				if (Ext.isObject(json.config.series)) {
					Ext.apply(cfg, json.config.series);
				} else if (Ext.isArray(json.config.series)) {
					Ext.apply(cfg, json.config.series[chart.series.length]);
				}
			}
			Ext.applyIf(cfg, {
		        type: 'line',
		        xField: json.rowKey,
		        yField: json.headers[i],
		        marker: {
		        	radius: 2
		        },
		        highlightCfg: {
	                scaling: 2
	            },
	            tooltip: {
	            	trackMouse: true,
	            	renderer: function (tooltip, record, item) {
	                    tooltip.setHtml(record.get(item.series.getYField())+": "+record.get(item.series.getYField()));
	                }
	            }
			});
			chart.series.push(cfg);
		}
		
		return chart;
    	
    }

})
Ext.define('Voyant.widget.LiveSearchGrid', {
    extend: 'Ext.grid.Panel',
    
    /**
     * @private
     * search value initialization
     */
    searchValue: null,
    
    /**
     * @private
     * The matched positions from the most recent search
     */
    matches: [],
    
    /**
     * @private
     * The current index matched.
     */
    currentIndex: null,
    
    /**
     * @private
     * The generated regular expression used for searching.
     */
    searchRegExp: null,
    
    /**
     * @private
     * Case sensitive mode.
     */
    caseSensitive: false,
    
    /**
     * @private
     * Regular expression mode.
     */
    regExpMode: false,
    
    /**
     * @cfg {String} matchCls
     * The matched string css classe.
     */
    matchCls: 'keyword',
    
    // Component initialization override: adds the top and bottom toolbars and setup headers renderer.
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },
    
    // detects html tag
    tagsRe: /<[^>]*>/gm,
    
    // DEL ASCII code
    tagsProtect: '\x0f',
    
    /**
     * Finds all strings that matches the searched value in each grid cells.
     * @private
     */
     onTextFieldChange: function(field, val) {
         var me = this,
             count = 0,
             view = me.view,
             cellSelector = view.cellSelector,
             innerSelector = view.innerSelector,
             columns = me.visibleColumnManager.getColumns();

         view.refresh();

         me.searchValue = val;
         me.matches = [];
         me.currentIndex = null;

         if (me.searchValue !== null) {
             me.searchRegExp = new RegExp(val, 'g' + (me.caseSensitive ? '' : 'i'));

             me.store.each(function(record, idx) {
                var node = view.getNode(record);

                if (node) {
                    Ext.Array.forEach(columns, function(column) {
                    	
                        var cell = Ext.fly(node).down(column.getCellInnerSelector(), true),
                            matches, cellHTML,
                            seen;

                        if (cell && column.isXType('widgetcolumn')==false) {
                            matches = cell.innerHTML.match(me.tagsRe);
                            cellHTML = cell.innerHTML.replace(me.tagsRe, me.tagsProtect);

                            // populate indexes array, set currentIndex, and replace wrap matched string in a span
                            cellHTML = cellHTML.replace(me.searchRegExp, function(m) {
                                ++count;
                                if (!seen) {
                                    me.matches.push({
                                        record: record,
                                        column: column
                                    });
                                    seen = true;
                                }
                                return '<span class="' + me.matchCls + '">' + m + '</span>';
                            }, me);
                            // restore protected tags
                            Ext.each(matches, function(match) {
                                cellHTML = cellHTML.replace(me.tagsProtect, match);
                            });
                            // update cell html
                            cell.innerHTML = cellHTML;
                        }
                    });
                }
             }, me);

             // results found
             if (count) {
                me.currentIndex = 0;
                me.gotoCurrent();
             }
         }

         // no results found
         if (me.currentIndex === null) {
             me.getSelectionModel().deselectAll();
         }
         field.focus();
     },

    privates: {
        gotoCurrent: function() {
            var pos = this.matches[this.currentIndex];
            this.getNavigationModel().setPosition(pos.record, pos.column);
            this.getSelectionModel().select(pos.record);
        }
    }
});

Ext.define('Voyant.widget.ProgressMonitor', {
	extend: "Ext.Base",
	mixins: ['Voyant.util.Localization'],
	msgbox: undefined,
	statics: {
		i18n: {
		}
	},
	config: {
		progress: undefined,
		scope: undefined,
		success: undefined,
		failure: undefined,
		args: undefined,
		tool: undefined, // TODO unused?
		delay: 1000,
		maxMillisSinceStart: undefined
	},
	constructor: function(config) {
		config = config || {};
		this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
		if (!config || !config.progress || !config.progress.id) {
			return Voyant.application.showError(this.localize("noProgress"))
		}
		this.initConfig(config);
		this.callParent(arguments);
		this.update();
	},

	update: function() {
		var progress = this.getProgress()
		var scope = this.getScope();
		
		var msg = scope.localize ? scope.localize(progress.code) : this.localize(progress.code);
		if (msg=="["+progress.code+"]") {msg=progress.message}
		msg+=" ("+(parseInt(progress.completion*100))+"%)";
		
		var text = this.localize(progress.status.toLowerCase());
		if (!this.msgbox || this.msgbox.msg.html!=msg || !this.msgbox.progressBar || this.msgbox.progressBar.getText()!=text) {
			this.msgbox = Ext.Msg.wait(msg, this.localize("progress"), {
				text: text
			});
		}

		if (progress.status=="LAUNCH" || progress.status=="RUNNING") {
			var me = this;
			Ext.defer(function() {
				Ext.Ajax.request({
				     url: Voyant.application.getTromboneUrl(),
				     params: {
				    	 	tool: "progress.ProgressMonitor",
				    	 	id: progress.id,
				    	 	maxMillisSinceStart: me.getMaxMillisSinceStart()
				     }
				 }).then(function(response, opt) {
					 var data = Ext.decode(response.responseText);
					 if (data && data.progress.progress) {
						 me.setProgress(data.progress.progress);
						 me.update();
					 } else {
						 me.finish(false, me.localize("badProgress"))
					 }
				 }, function(response, opt) {
					 me.finish(false, response);
				 });
			}, this.getDelay(), this)
		} else {
			this.finish(progress.status=="FINISHED", msg);
		}
		if (this.getDelay()<5000) {this.setDelay(this.getDelay()+500)} // longer delay, up to 5 secs
	},
	
	finish: function(success, response) {
		var callback = success ? this.getSuccess() : this.getFailure();
		var args = this.getArgs(), progress = this.getProgress(), scope = this.getScope();
		
		this.close();
		
		if (callback && callback.apply) {
			callback.apply(scope, [success ? args : response || progress]);
		} else {
			Voyant.application.showError(response);
		}
	},
	
	close: function() {
		if (this.msgbox) {
			this.msgbox.close();
		}
		this.destroy();
	}

});

Ext.define('Voyant.widget.VoyantTableTransform', {
	extend: 'Ext.panel.Panel',
    mixins: ['Voyant.util.Localization','Voyant.util.Api'],
	alias: 'widget.voyanttabletransform',
    statics: {
    	i18n: {},
		api: {
			tableHtml: undefined,
			tableJson: undefined,
			width: undefined,
			api: undefined
		}
    },
    html: '',
    config: {
    	hiddenColumns: undefined
    },
	constructor: function(config) {
    	config = config || {};
		var me = this;
        me.callParent(arguments);
	},
	initComponent: function(config) {
    	var me = this, config = config || {};
    	me.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	if (this.config.api && this.config.api.tableJson) {
    		this.setApiParam("tableJson", this.config.api.tableJson);
    	}
		me.on('afterrender', function() {
	    	me.buildFromParams();
			var table = this.getTargetEl().down('table');
			if (table) {
				var parent = table.parent();
				var grid = new Ext.ux.grid.TransformGrid(table, {
					width: this.getApiParam('width') || parent.getWidth(),
					height: this.getApiParam('height') || 20+(table.query('tr').length*24) // based on grid heights in crisp
				});
				grid.render(parent);
				if (this.getHiddenColumns()) {
					var hides = {}; // map for speed
					Ext.Array.from(this.getHiddenColumns()).forEach(function(header) {hides[header]=true})
					grid.getColumns().forEach(function(column) {
						if (column.text in hides) {column.hide()}
					});
					Ext.defer(function() {
						grid.setWidth(grid.getEl().dom.parentNode.offsetWidth); // resize
					},10)
				}
			}
		}, me);
		
    	me.callParent(arguments);
	},
	
	buildFromParams: function() {
		var me = this, tableHtml = this.getApiParam('tableHtml'), tableJson = this.getApiParam('tableJson');
		if (tableHtml) {
			this.setHtml(tableHtml);
		} else if (tableJson) {
			var html = "<table><thead><tr>", json = JSON.parse(tableJson);
			
			if (json.headers) {
				json.headers.forEach(function(header) {
					html+="<th>"+header+"</th>"
				});
			} else {
				json.rows[0].forEach(function(cell, i) {
					html+="<th>"+(i+1)+"</th>";
				})
			}
			html+="</tr></thead><tbody>";
			json.rows.forEach(function(row) {
				html+="<tr>";
				row.forEach(function(cell) {
					html+="<td>"+cell+"</td>"
				})
				html+="</tr>";
			})
			html+="</tbody></table>";
			this.setHtml(html);
			if (json.config && json.config.hidden) {this.setHiddenColumns(json.config.hidden)}
		}
		
	}

})



/**
 * A Grid which creates itself from an existing HTML table element.
 */
Ext.define('Ext.ux.grid.TransformGrid', {
    extend: 'Ext.grid.Panel',

    /**
     * Creates the grid from HTML table element.
     * @param {String/HTMLElement/Ext.Element} table The table element from which this grid will be created -
     * The table MUST have some type of size defined for the grid to fill. The container will be
     * automatically set to position relative if it isn't already.
     * @param {Object} [config] A config object that sets properties on this grid and has two additional (optional)
     * properties: fields and columns which allow for customizing data fields and columns for this grid.
     */
    constructor: function(table, config) {
        config = Ext.apply({}, config);
        this.table = Ext.get(table);

        var configFields = config.fields || [],
            configColumns = config.columns || [],
            fields = [],
            cols = [],
            headers = table.query("thead th"),
            i = 0,
            len = headers.length,
            data = table.dom,
            width,
            height,
            store,
            col,
            text,
            name;

        for (; i < len; ++i) {
            col = headers[i];

            text = col.innerHTML;
            name = 'tcol-' + i;

            fields.push(Ext.applyIf(configFields[i] || {}, {
                name: name,
                mapping: 'td:nth(' + (i + 1) + ')/@innerHTML'
            }));

            cols.push(Ext.applyIf(configColumns[i] || {}, {
                text: text,
                dataIndex: name,
                //width: col.offsetWidth,
                flex: 1,
                tooltip: col.title,
                sortable: true
            }));
        }

        if (config.width) {
            width = config.width;
        } else {
            width = table.getWidth() + 1;
        }

        if (config.height) {
            height = config.height;
        }

        Ext.applyIf(config, {
            store: {
                data: data,
                fields: fields,
                proxy: {
                    type: 'memory',
                    reader: {
                        record: 'tbody tr',
                        type: 'xml'
                    }
                }
            },
            columns: cols,
            width: width,
            height: height
        });
        this.callParent([config]);
        
        if (config.remove !== false) {
            // Don't use table.remove() as that destroys the row/cell data in the table in
            // IE6-7 so it cannot be read by the data reader.
            data.parentNode.removeChild(data);
        }
    },

    doDestroy: function() {
        this.table.remove();
        this.tabl = null;
        this.callParent();
    }
});

Ext.namespace('Voyant.categories');

Ext.define('Voyant.categories.CategoriesOption', {
	extend: 'Ext.container.Container',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.categoriesoption',
	statics: {
		i18n: {
		}
	},
	initComponent: function() {
		var value = this.up('window').panel.getApiParam('categories');
    	var data = value ? [{name: value, value: value}] : [];
		if (value !== 'auto') {
			data.push({name: 'auto', value: 'auto'});
		}
		
		Ext.apply(this, {
    		layout: 'hbox',
			margin: '0 0 5px 0',
    		items: [{
    			xtype: 'combo',
    			queryMode: 'local',
    			triggerAction: 'all',
    			fieldLabel: this.localize('categories'),
    			labelAlign: 'right',
    			displayField: 'name',
    			valueField: 'value',
    			store: {
    				fields: ['name', 'value'],
    				data: data
    			},
    			name: 'categories',
    			value: value
    		}, {width: 10}, {xtype: 'tbspacer'}, {
    			xtype: 'button',
    			text: this.localize('edit'),
    			ui: 'default-toolbar',
    			handler: function() {
    				if (Voyant.categories.Builder === undefined) {
						Voyant.categories.Builder = Ext.create('Voyant.categories.CategoriesBuilder', {
							panel: this.up('window').panel
						});
					}
					Voyant.categories.Builder.on('close', function(win) {
						var id = win.getCategoriesId();
						if (id !== undefined) {
							var combo = this.down('combo');
							var name = id;
							combo.getStore().add({name: name, value: id});
							combo.setValue(id);
							
							this.up('window').panel.setApiParam('categories', id);
						}
					}, this, { single: true });
    				
    				var categoriesId = this.down('combo').getValue();
    				Voyant.categories.Builder.setCategoriesId(categoriesId);
					Voyant.categories.Builder.show();
    			},
    			scope: this
    		}]
    	});
		
		this.callParent(arguments);
	}
});

Ext.define('Voyant.categories.CategoriesBuilder', {
    extend: 'Ext.window.Window',
    requires: ['Voyant.widget.FontFamilyOption'],
    mixins: ['Voyant.util.Localization','Voyant.util.Api'],
    alias: 'widget.categoriesbuilder',
    statics: {
    	i18n: {
    		title: 'Categories Builder',
    		terms: 'Terms',
    		term: 'Term',
    		rawFreq: 'Count',
    		relativeFreq: 'Relative',
    		categories: 'Categories',
    		addCategory: 'Add Category',
    		removeCategory: 'Remove Category',
    		removeTerms: 'Remove Selected Terms',
    		categoryName: 'Category Name',
    		add: 'Add',
    		cancel: 'Cancel',
    		exists: 'Category already exists',
    		confirmRemove: 'Are you sure you want to remove the category?',
    		save: 'Save',
    		features: 'Features',
			category: 'Category',
			increaseCategory: 'Increase Category Priority',
			decreaseCategory: 'Decrease Category Priority',
    		
    		color: 'Color',
    		font: 'Font',
    		orientation: 'Orientation'
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined
    	},
    	features: {
        	color: {
        		xtype: 'colorfield',
        		format: '#hex6'
//        		,listeners: {
//        			render: function(field) {
//        				field.on('change', function(field, color) {
//        					field.inputEl.setStyle('background-color', color);
//        				});
//        			}
//        		}
        	},
        	font: {
        		xtype: 'combobox',
        		queryMode: 'local',
        		displayField: 'name',
        		valueField: 'value',
        		store: {
        			fields: ['name', 'value'],
        			data: Voyant.widget.FontFamilyOption.fonts
        		}
        	},
        	orientation: {
        		xtype: 'combobox',
        		queryMode: 'local',
        		displayField: 'name',
        		valueField: 'value',
        		store: {
        			fields: ['name', 'value'],
        			data: [{name: 'Horizontal', value: 0}, {name: 'Vertical', value: 90}]
        		}
        	}
        }
    },
    config: {
    	corpus: undefined,
    	builderWin: undefined,
    	addCategoryWin: undefined,
    	categoriesId: undefined
    },
    
    // window defaults
    closeAction: 'hide',
    modal: true,
	height: 250,
	width: 500,

    constructor: function(config) {
    	config = config || {};

    	if (config.panel) {
    		this.panel = config.panel;
			this.app = this.panel.getApplication();
			this.categoriesManager = this.app.getCategoriesManager();
		} else {
			console.warn('CategoriesBuilder cannot find panel!');
		}

		config.height = this.app.getViewport().getHeight()*0.75;
		config.width = this.app.getViewport().getWidth()*0.75;
    	
    	this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
    	this.callParent(arguments);
    },
    
    initComponent: function() {
    	Ext.apply(this, {
    		header: false,
    		layout: 'fit',
    		onEsc: Ext.emptyFn,
    		items: {
	    		xtype: 'tabpanel',
	    		title: this.localize('title'),
	    		tabBarHeaderPosition: 1,
	    		items: [{
		    		layout: 'border',
		    		title: this.localize('categories'),
		    		items: [{
		    			title: this.localize('terms'),
		    			split: true,
		    			width: 250,
		    			region: 'west',
		    			layout: 'fit',
		    			items: {
		    				itemId: 'terms',
		    				xtype: 'grid',
		    				store: Ext.create('Voyant.data.store.CorpusTermsBuffered', {
		    		        	parentPanel: this
		    		        }),
		    				viewConfig: {
		    					plugins: {
		    						ptype: 'gridviewdragdrop',
		    						ddGroup: 'terms',
		    						copy: true,
		    						enableDrop: false, // can't drop on grid with buffered store
		    						dragZone: {
		    							getDragText: function() {
		    								var text = '';
		    								this.dragData.records.forEach(function(d) {
		    									text += d.get('term')+', ';
		    								});
		    								text = text.substr(0, text.length-2);
		    								if (text.length > 20) {
		    									text = text.substr(0, 20) + '...';
		    								}
		    								return text;
		    							}
		    						}
		    					}
		    				},
		    				selModel: {
		    	    			mode: 'MULTI'
		    	    		},
		    				columns: [{
				    			text: this.localize('term'),
				        		dataIndex: 'term',
				        		flex: 1,
				                sortable: true
				            },{
				            	text: this.localize('rawFreq'),
				            	dataIndex: 'rawFreq',
				                width: 'autoSize',
				            	sortable: true
				            },{
				            	text: this.localize('relativeFreq'),
				            	dataIndex: 'relativeFreq',
				            	renderer: function(val) {
				            		return Ext.util.Format.number(val*1000000, "0,000");
				            	},
				                width: 'autoSize',
				                hidden: true,
				            	sortable: true
				            }],
				            dockedItems: [{
				                dock: 'bottom',
				                xtype: 'toolbar',
				                overflowHandler: 'scroller',
				                items: [{
				                    xtype: 'querysearchfield'
				                }]
				            }],
				            listeners: {
				            	query: function(src, query) {
				            		this.setApiParam('query', query);
				            		var store = this.queryById('terms').getStore();
				            		store.removeAll();
				            		store.load();
				            	},
				            	scope: this
				            }
		    			}
		    		},{
		    			title: this.localize('categories'),
		    			itemId: 'categories',
		    			region: 'center',
		    			xtype: 'panel',
		    			layout: {
		    				type: 'hbox',
		    				align: 'stretch'
		    			},
		    			scrollable: 'x',
		    			dockedItems: [{
		                    dock: 'bottom',
		                    xtype: 'toolbar',
		                    overflowHandler: 'scroller',
		                    items: [{
								xtype: 'textfield',
								fieldLabel: 'Category Filter',
								labelAlign: 'right',
								enableKeyEvents: true,
								listeners: {
									keyup: function(cmp, e) {
										var query = cmp.getValue().trim();
										this.queryById('categories').query('grid').forEach(function(grid) {
											if (query === '') {
												grid.getStore().clearFilter();
											} else {
												grid.getStore().filter('term', query);
											}
										}, this);
									},
									scope: this
								}
							},'-',{
		                    	text: this.localize('addCategory'),
		                    	handler: function() {
		                    		this.getAddCategoryWin().show();
		                    	},
		                    	scope: this
		                    },{
		                    	text: this.localize('removeTerms'),
		                    	handler: function() {
		                    		this.queryById('categories').query('grid').forEach(function(grid) {
										var sels = grid.getSelection();
										sels.forEach(function(sel) {
											this.categoriesManager.removeTerm(grid.category, sel.get('term'));
										}, this);
		                    			grid.getStore().remove(sels);
		                    		}, this);
		                    	},
		                    	scope: this
		                    }]
		    			}],
		    			items: []
		    		}]
	    		},{
	    			layout: 'fit',
	    			itemId: 'features',
	    			title: this.localize('features'),
	    			xtype: 'grid',
	    			scrollable: 'y',
	    			store: Ext.create('Ext.data.JsonStore', {
		    			fields: ['category']
		    		}),
	    			columns: [{
	    				text: this.localize('category'),
	    				dataIndex: 'category',
	    				sortable: false,
	    				hideable: false,
	    				flex: 1
	    			}]
	    		}]
    		},
    		buttons: [{
				text: this.localize('cancel'),
				handler: function(btn) {
					this.setCategoriesId(undefined);
					btn.up('window').close();
				},
				scope: this
			},{
				text: this.localize('save'),
				handler: function(btn) {
					this.processFeatures();
					this.setColorTermsFromCategoryFeatures();
					this.app.saveCategoryData().then(function(id) {
						this.setCategoriesId(id);
						btn.up('window').close();
					}.bind(this), function() {
						this.setCategoriesId(undefined);
						btn.up('window').close();
					}.bind(this));
				},
				scope: this
			}],
			listeners: {
				show: function() {
					// check to see if the widget value is different from the API
					if (this.getCategoriesId() && this.getCategoriesId() !== this.getApiParam("categories")) {
		    			this.app.loadCategoryData(this.getCategoriesId()).then(function(data) {
							this.setColorTermsFromCategoryFeatures();
							this.buildCategories();
							this.buildFeatures();
						}.bind(this));
					} else {
						this.buildCategories();
						this.buildFeatures();
					}					
					this.down('tabpanel').setActiveTab(0);
				},
				afterrender: function(builder) {
					builder.on('loadedCorpus', function(src, corpus) {
		    			this.setCorpus(corpus);
			    		var terms = this.queryById('terms');
			    		terms.getStore().load();
		    		}, builder);
		    		
					this.panel.on('loadedCorpus', function(src, corpus) {
	    				builder.fireEvent('loadedCorpus', src, corpus);
	    			}, builder);
	    			if (this.panel.getCorpus && this.panel.getCorpus()) {builder.fireEvent('loadedCorpus', builder, this.panel.getCorpus());}
	    			else if (this.panel.getStore && this.panel.getStore() && this.panel.getStore().getCorpus && this.panel.getStore().getCorpus()) {
	    				builder.fireEvent('loadedCorpus', builder, this.panel.getStore().getCorpus());
					}
				},
				scope: this
			}
    	});
    	
    	this.setAddCategoryWin(Ext.create('Ext.window.Window', {
    		title: this.localize('addCategory'),
    		modal: true,
    		closeAction: 'hide',
    		layout: 'fit',
    		items: {
    			xtype: 'form',
    			width: 300,
				bodyPadding: '10 5 5',
    			defaults: {
    				labelAlign: 'right'
    			},
	    		items: [{
	    			xtype: 'textfield',
	    			fieldLabel: this.localize('categoryName'),
	    			name: 'categoryName',
	    			allowBlank: false,
	    			validator: function(val) {
	    				return this.categoriesManager.getCategoryTerms(val) === undefined ? true : this.localize('exists');
	    			}.bind(this),
	    			enableKeyEvents: true,
	    			listeners: {
	    				keypress: function(field, evt) {
	    					if (evt.getKey() === Ext.event.Event.ENTER) {
	    						field.up('form').queryById('addCategoryButton').click();
	    					}
	    				},
	    				scope: this
	    			}
	    		}],
	    		buttons: [{
	    			text: this.localize('cancel'),
	    			handler: function(btn) {
	    				btn.up('window').close();
	    			}
	    		},{
	    			itemId: 'addCategoryButton',
	    			text: this.localize('add'),
	    			handler: function(btn) {
	    				var form = btn.up('form');
	    				if (form.isValid()) {
	    					var name = form.getValues()['categoryName'];
	    					this.addCategory(name);
	    					btn.up('window').close();
	    				}
	    			},
	    			scope: this
	    		}]
    		},
    		listeners: {
    			show: function(win) {
    				var form = win.down('form').getForm();
    				form.reset();
					form.clearInvalid();
    			}
    		}
		}));
    	
    	this.callParent(arguments);
    },
    
    addCategory: function(name) {
    	this.categoriesManager.addCategory(name);
    	
    	this.queryById('features').getStore().add({category: name});

    	var termsData = [];
    	var terms = this.categoriesManager.getCategoryTerms(name);
    	if (terms !== undefined) {
    		for (var i = 0; i < terms.length; i++) {
    			termsData.push({term: terms[i]});
    		}
    	}
    	
    	var grid = this.queryById('categories').add({
    		xtype: 'grid',
    		category: name,
    		title: name,
    		frame: true,
    		width: 150,
    		margin: '10 0 10 10',
    		layout: 'fit',
    		tools: [{
    			type: 'close',
    			tooltip: this.localize('removeCategory'),
    			callback: function(panel) {
    				Ext.Msg.confirm(this.localize('removeCategory'), this.localize('confirmRemove'), function(btn) {
    					if (btn === 'yes') {
    						this.removeCategory(name);
    					}
    				}, this);
    			},
    			scope: this
			}],
			bbar: [{
				xtype: 'button',
				text: '',
				tooltip: this.localize('increaseCategory'),
				glyph: 'xf067@FontAwesome',
				handler: function(b) {
					var grid = b.findParentByType('grid');
					var parent = this.queryById('categories');
					var prev = parent.prevChild(grid);
					if (prev !== null) {
						parent.moveBefore(grid, prev);
						this.app.getCategoriesManager().setCategoryRanking(grid.getTitle(), parent.items.indexOf(grid));
					}
				},
				scope: this
			},'->',{
				xtype: 'button',
				text: '',
				tooltip: this.localize('decreaseCategory'),
				glyph: 'xf068@FontAwesome',
				handler: function(b) {
					var grid = b.findParentByType('grid');
					var parent = this.queryById('categories');
					var next = parent.nextChild(grid);
					if (next !== null) {
						parent.moveAfter(grid, next);
						this.app.getCategoriesManager().setCategoryRanking(grid.getTitle(), parent.items.indexOf(grid));
					}
				},
				scope: this
			}],
    		
    		store: Ext.create('Ext.data.JsonStore', {
    			data: termsData,
    			fields: ['term']
    		}),
    		viewConfig: {
	    		plugins: {
	    			ptype: 'gridviewdragdrop',
					ddGroup: 'terms',
					dragZone: {
						getDragText: function() {
							var text = '';
							this.dragData.records.forEach(function(d) {
								text += d.get('term')+', ';
							});
							return text.substr(0, text.length-2);
						}
					}
	    		}
    		},
    		selModel: {
    			mode: 'MULTI'
    		},
    		columns: [{
        		dataIndex: 'term',
        		flex: 1,
                sortable: true
            }],
    		listeners: {
    			beforedrop: function(node, data) {
					var categoriesManager = this.up('categoriesbuilder').categoriesManager;
					var source = data.view.up('grid');

					if (source.category !== undefined) {
						// we're moving a term from one category to another
						for (var i = data.records.length-1; i >= 0; i--) {
							var term = data.records[i].get('term');
							categoriesManager.removeTerm(source.category, term);
						}
					}
    			},
    			drop: function(node, data) {
    				data.view.getSelectionModel().deselectAll();
    				this.getSelectionModel().deselectAll();
    				
    				var categoriesManager = this.up('categoriesbuilder').categoriesManager;
    				var terms = [];
    				for (var i = 0; i < data.records.length; i++) {
    					var term = data.records[i].get('term');
    					terms.push(term);
    				}
    				categoriesManager.addTerms(name, terms);
    			}
    		}
    	});
    	
    	var titleEditor = new Ext.Editor({
    		updateEl: true,
    		alignment: 'l-l',
    		autoSize: {
    			width: 'boundEl'
    		},
    		field: {
    			xtype: 'textfield',
    			allowBlank: false,
    			validator: function(val) {
    				return this.categoriesManager.getCategoryTerms(val) === undefined || val ===  grid.getTitle() ? true : this.localize('exists');
    			}.bind(this)
    		},
    		listeners: {
    			complete: function(ed, newvalue, oldvalue) {
    				this.categoriesManager.renameCategory(oldvalue, newvalue);
    				this.buildFeatures();
    			},
    			scope: this
    		}
    	});
    	
    	grid.header.getTitle().textEl.on('dblclick', function(e, t) {
    		titleEditor.startEdit(t);
		});
    },
    
    removeCategory: function(name) {
    	var categoriesParent = this.queryById('categories');
    	var panel = categoriesParent.queryBy(function(cmp) {
    		if (cmp.category && cmp.category == name) {
    			return true;
    		}
    		return false;
    	});
    	categoriesParent.remove(panel[0]);
    	
    	var featuresStore = this.queryById('features').getStore();
    	featuresStore.removeAt(featuresStore.findExact('category', name));
    	
		this.categoriesManager.removeCategory(name);
    },
    
    addFeature: function(name) {
		this.categoriesManager.addFeature(name);
		this.buildFeatures();
    },
    
    buildFeatures: function() {
    	this.queryById('features').getStore().removeAll();
    	
    	var fields = ['category'];
		var columns = [{
			sortable: false,
			text: this.localize('category'),
			dataIndex: 'category',
			flex: 1
		}];
		var data = [];
		
		for (var category in this.categoriesManager.getCategories()) {
			data.push({category: category});
		}
		
		var features = this.categoriesManager.getFeatures();
		var featuresConfigs = Ext.ClassManager.getClass(this).features;
		
		// populate with default features if there are none (can happen when creating categories programmatically)
		if (Object.entries(features).length === 0) {
			for (var feature in featuresConfigs) {
				features[feature] = {};
				for (var category in this.categoriesManager.getCategories()) {
					features[feature][category] = undefined;
				}
			}
		}

		for (var feature in features) {
			fields.push(feature);
			
			var featureConfig = featuresConfigs[feature];
			var widgetConfig = Ext.applyIf({
				feature: feature,
				listeners: {
					change: function(cmp, newvalue) {
						if (cmp.rendered) {
							var rowIndex = cmp.up('gridview').indexOf(cmp.el.up('table'));
							var record = cmp.up('grid').getStore().getAt(rowIndex);
							if (record) {
								record.set(cmp.feature, newvalue);
							} else {
								if (window.console) {
									console.warn('no record for', rowIndex, cmp);
								}
							}
						}
					},
					scope: this
				}
			}, featureConfig);
			if (featureConfig.listeners) {
				Ext.applyIf(widgetConfig.listeners, featureConfig.listeners);
			}
			
			columns.push({
				sortable: false,
				hideable: false,
				text: this.localize(feature),
				dataIndex: feature,
				flex: 0.5,
				xtype: 'widgetcolumn',
				widget: widgetConfig
			});
			
			for (var category in this.categoriesManager.getCategories()) {
				var value = this.categoriesManager.getCategoryFeature(category, feature);
				for (var i = 0; i < data.length; i++) {
					if (data[i].category == category) {
						data[i][feature] = value;
						break;
					}
				}
			}
		}
		
		var store = Ext.create('Ext.data.JsonStore', {
			fields: fields,
			data: data
		});
		this.queryById('features').reconfigure(store, columns);
    },
	
	processFeatures: function() {
		var store = this.queryById('features').getStore();
		var features = Object.keys(this.categoriesManager.getFeatures());
		store.each(function(record) {
			var category = record.get('category');
			features.forEach(function(feature) {
				var featureValue = record.get(feature);
				if (featureValue !== undefined) {
					this.categoriesManager.setCategoryFeature(category, feature, featureValue);
				}
			}, this)
		}, this)
	},

	setColorTermsFromCategoryFeatures: function() {
        for (var category in this.categoriesManager.getCategories()) {
            var color = this.categoriesManager.getCategoryFeature(category, 'color');
            if (color !== undefined) {
                var rgb = this.app.hexToRgb(color);
                var terms = this.categoriesManager.getCategoryTerms(category);
                for (var i = 0; i < terms.length; i++) {
                    this.app.setColorForTerm(terms[i], rgb);
                }
            }
        }
    },

    buildCategories: function() {

    	this.queryById('categories').removeAll();
    	
    	var cats = this.categoriesManager.getCategories();
    	for (var key in cats) {
    		this.addCategory(key);
    	}
    }
});

Ext.define('Voyant.categories.CategoriesMenu', {
	extend: 'Ext.menu.Menu',
	alias: 'widget.categoriesmenu',

	config: {
		terms: []
	},

	constructor: function(config) {
		config = config || {};
		if (config.panel) {
			this.panel = config.panel;
			this.app = this.panel.getApplication();
			this.categoriesManager = this.app.getCategoriesManager();
		} else {
			if (window.console) {
				console.warn('can\'t find panel!');
			}
		}
		this.callParent(arguments);
	},

	setColorTermsFromCategoryFeatures: function() {
		for (var category in this.categoriesManager.getCategories()) {
			var color = this.categoriesManager.getCategoryFeature(category, 'color');
			if (color !== undefined) {
				var rgb = this.app.hexToRgb(color);
				var terms = this.categoriesManager.getCategoryTerms(category);
				for (var i = 0; i < terms.length; i++) {
					this.app.setColorForTerm(terms[i], rgb);
				}
			}
		}
	},

	initComponent: function() {
		Ext.apply(this, {
			items: [{
				text: 'Set category for selected terms',
				menu: {
					minWidth: 250,
					itemId: 'cats',
					items: [],
					minButtonWidth: 50,
					fbar: [{
						xtype: 'button',
						text: 'Ok',
						handler: function(button) {
							var terms = this.getTerms();
							var addCats = [];
							var remCats = [];
							button.up('menu').items.each(function(item) {
								if (item.checked) {
									addCats.push(item.text);
								} else {
									remCats.push(item.text);
								}
							});
							remCats.forEach(function(cat) { this.categoriesManager.removeTerms(cat, terms); }, this);
							addCats.forEach(function(cat) { this.categoriesManager.addTerms(cat, terms); }, this);
		
							button.up('menu').up('menu').hide();

							this.setColorTermsFromCategoryFeatures();
							this.fireEvent('categorySet', this, addCats);
						},
						scope: this
					},{
						xtype: 'button',
						text: 'Cancel',
						handler: function(button) {
							button.up('menu').up('menu').hide();
						}
					},{xtype: 'tbfill'},{
						xtype: 'button',
						glyph: 'xf013@FontAwesome',
						tooltip: 'Show Categories Builder',
						handler: function(button) {
							if (Voyant.categories.Builder === undefined) {
								Voyant.categories.Builder = Ext.create('Voyant.categories.CategoriesBuilder', {
									panel: this.panel
								});
							}
							Voyant.categories.Builder.show();
						},
						scope: this
					}]
				}
			}],
			listeners: {
				beforeshow: function(menu) {
					var categories = this.categoriesManager.getCategories();
					var catsMenu = menu.down('#cats');
					catsMenu.removeAll();

					var terms = this.getTerms();
					var term = Array.isArray(terms) ? terms[0] : terms;
					var termCats = this.categoriesManager.getCategoriesForTerm(term);

					catsMenu.add(Object.keys(categories).map(function(cat) { return {text: cat, xtype: 'menucheckitem', checked: termCats.indexOf(cat) !== -1} }));
				},
				scope: this
			}
		});

		this.callParent(arguments);
	}
})
/**
 * This class is essentially a wrapper for a D3 force directed graph.
 * It provides defaults for physics and styling and simplifies loading data.
 * It fires the following events:
 * 	nodeclicked, nodedblclicked, nodecontextclicked,
 * 	edgeclicked,
 * 	nodedragstart, nodedrag, nodedragend
 */
Ext.define('Voyant.widget.VoyantNetworkGraph', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.util.Localization','Voyant.util.Api'],
	alias: 'widget.voyantnetworkgraph',
	statics: {
		i18n: {
		},
		api: {
			jsonData: undefined,
			docId: undefined,
			docIndex: undefined,
			json: undefined,
			api: undefined
		}
	},
	config: {
		vis: undefined, // svg > g element
		visLayout: undefined, // d3 layout algorithm
		
		// backing data. don't set through config, use config.nodes & config.edges
		nodeData: undefined,
		edgeData: undefined,
		
		nodeSelection: undefined, // d3 selection for nodes
		edgeSelection: undefined, // d3 selection for edges
		
		currentNode: undefined,
		currentEdge: undefined,
		
		zoom: undefined, // d3 zoom
		zoomExtent: [0.25, 8],
		
		dragging: false, // is the user currently dragging a node
		
		nodeScaling: {
			minSize: 8,
			maxSize: 36,
			scalingFunction: undefined
		},
		edgeScaling: {
			minSize: 1,
			maxSize: 10,
			scalingFunction: undefined
		},
		
		graphStyle: {
			node: {
				normal: {
					fill: '#c6dbef',
					fillOpacity: 1,
					stroke: '#6baed6',
					strokeOpacity: 1,
					strokeWidth: 1
				},
				highlight: {
					fill: '#9ecae1',
					fillOpacity: 1,
					stroke: '#3182bd',
					strokeOpacity: 1,
					strokeWidth: 3
				}
			},
			edge: {
				normal: {
					stroke: '#000000',
					strokeOpacity: 0.25,
					strokeWidth: 1
				},
				highlight: {
					stroke: '#000000',
					strokeOpacity: 0.5,
					strokeWidth: 3
				}
			}
		},
		
		graphPhysics: {
			damping: 0.4, // 0 = no damping, 1 = full damping
			centralGravity: 0.1, // 0 = no grav, 1 = high grav
			nodeGravity: -50,  // negative = repel, positive = attract
			springLength: 100,
			springStrength: 0.25, // 0 = not strong, >1 = probably too strong
			collisionScale: 1.25 // 1 = default, 0 = no collision 
		}
	},
	
	constructor: function(config) {
		config = config || {};
		
		this.setNodeData([]);
		this.setEdgeData([]);
		
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		this.callParent(arguments);
		
		var json = {};
		if (this.getApiParam('jsonData')) {
			json = Ext.decode(this.getApiParam('jsonData'));
		} else if (this.getApiParam('json')) {
			json = this.getApiParam('json');
		} else if (config.json) {
			json = config.json;
		} else if (config.edges) {
			json.edges = config.edges;
			if (config.nodes) {
				json.nodes = config.nodes;
			}
		} else if (config && config.jsonData) {
			json = JSON.parse(config.jsonData);
		}
		this.loadJson(json);
	},

	initComponent: function(config) {
		this.on('boxready', function(src, corpus) {
			this.initGraph();
			this.refreshGraph();
		}, this);
		
		this.on('resize', function(panel, width, height) {
			var vis = this.body.down('svg');
			if (vis) {
				var el = this.body;
				var elHeight = el.getHeight();
				var elWidth = el.getWidth();
				vis.dom.setAttribute('width', elWidth);
				vis.dom.setAttribute('height', elHeight);
				this.getVisLayout()
					.force('x', d3.forceX(elWidth/2))
					.force('y', d3.forceY(elHeight/2));
				
				Ext.Function.defer(this.zoomToFit, 100, this);
			}
		}, this);
		
		this.callParent(arguments);
	},
	
	/**
	 * Primary method for adding data to the graph.
	 * @param {Object} json The json data to load
	 * @param {Array} json.nodes An array of objects that will become nodes
	 * @param {String} json.nodes[].term The only required node property (used as ID for edges)
	 * @param {Array} json.edges An array of objects that will become edges
	 * @param {String} json.edges[].source The term/ID of the source node
	 * @param {String} json.edges[].target The term/ID of the target node
	 */
	loadJson: function(json) {
		this.processJson(json);
		
		var existingTerms = {};
		this.getNodeData().forEach(function(node) {
			existingTerms[node.term] = true;
		}, this);
		
		var newNodes = [];
		var newEdges = [];
		
		json.nodes.forEach(function(node) {
			if (existingTerms[node.term] === undefined) {
				node.id = this.idGet(node.term);
				newNodes.push(node);
			}
		}, this);
		json.edges.forEach(function(newedge) {
			var sourceId = this.idGet(newedge.source);
			var targetId = this.idGet(newedge.target);
			var edges = this.getEdgeData();
			var exists = false;
			for (var i = 0; i < edges.length; i++) {
				var edge = edges[i];
				if ((edge.source.id == sourceId && edge.target.id == targetId) || (edge.target.id == sourceId && edge.source.id == targetId)) {
					exists = true;
					break;
				}
			}
			if (!exists) {
				newedge.source = sourceId;
				newedge.target = targetId;
				newedge.id = sourceId+'-'+targetId;
				newEdges.push(newedge);
			}
		}, this);
		
		this.setNodeData(this.getNodeData().concat(newNodes));
		this.setEdgeData(this.getEdgeData().concat(newEdges));
		
		this.refreshGraph();
	},
	
	processJson: function(json) {
		if (!json || !json.edges) {
			if (json && json.links) {
				json.edges = json.links;
				delete json.links;
			}
			if (!json || !json.edges) {
				json = json || {};
				json.edges = [];
			}
		}
		if (!json.nodes) {
			json.nodes = [];
		}
		if (json.nodes.length === 0) {
			var wordFreq = {};
			json.edges.forEach(function(edge) {
				['source', 'target'].forEach(function(loc) {
					var term = edge[loc];
					if (term in wordFreq == false) {
						wordFreq[term] = 1;
						json.nodes.push({term: term});
					} else {
						wordFreq[term]++;
					}
					edge.value = 1;
				});
			}, this);
			json.nodes.forEach(function(node) {
				var val = wordFreq[node.term] === undefined ? 1 : wordFreq[node.term];
				Ext.applyIf(node, {value: val});
			});
		} else {
			json.nodes.forEach(function(node) {
				Ext.applyIf(node, {value: 1});
			});
		}
		
		return json;
	},
	
	/**
	 * Get a DOM appropriate ID
	 * @param {String} term 
	 * @returns {String}
	 */
	idGet: function(term) {
		return 'vng_'+term.replace(/\W/g, '_');
	},
	
	/**
	 * Update the data for a specific node
	 * @param {String} nodeId 
	 * @param {Object} dataObj 
	 */
	updateDataForNode: function(nodeId, dataObj) {
		var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				Ext.apply(data[i], dataObj);
				break;
			}
		}
	},
	
	/**
	 * Update the data for a specific edge
	 * @param {String} edgeId 
	 * @param {Object} dataObj 
	 */
	updateDataForEdge: function(edgeId, dataObj) {
		var data = this.getEdgeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === edgeId) {
				Ext.apply(data[i], dataObj);
				break;
			}
		}
	},
	
	/**
	 * Add a new node to the graph
	 * @param {Object|String} dataObj 
	 */
	addNode: function(dataObj) {
		if (Ext.isString(dataObj)) {
			dataObj = {term: dataObj};
		}
		if (dataObj.term) {
			this.loadJson({nodes: [dataObj]});
		}
	},
	
	/**
	 * Remove a node from the graph
	 * @param {String} nodeId 
	 * @param {Boolean} removeOrphans 
	 */
	removeNode: function(nodeId, removeOrphans) {
		var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				data.splice(i, 1);
				break;
			}
		}
		
		var potentialOrphans = {};
		data = this.getEdgeData();
		for (var i = data.length-1; i >= 0; i--) {
			var match = false;
			if (data[i].source.id === nodeId) {
				match = true;
				potentialOrphans[data[i].target.id] = true;
			}
			if (data[i].target.id === nodeId) {
				match = true;
				potentialOrphans[data[i].source.id] = true;
			}
			if (match) {
				data.splice(i, 1);
			}
		}
		
		if (removeOrphans) {
			for (var i = 0; i < data.length; i++) {
				if (potentialOrphans[data[i].source.id]) {
					delete potentialOrphans[data[i].source.id];
				}
				if (potentialOrphans[data[i].target.id]) {
					delete potentialOrphans[data[i].target.id];
				}
			}
			for (var orphanId in potentialOrphans) {
				this.removeNode(orphanId, true);
			}
		}
		
		this.refreshGraph();
	},
	
	/**
	 * Add a new edge to the graph
	 * @param {Object} dataObj 
	 */
	addEdge: function(dataObj) {
		if (Ext.isObject(dataObj) && dataObj.source && dataObj.target) {
			this.loadJson({edges: [dataObj]});
		}
	},
	
	/**
	 * Remove a specific edge from the graph
	 * @param {String} edgeId 
	 * @param {Boolean} removeOrphans 
	 */
	removeEdge: function(edgeId, removeOrphans) {
		var data = this.getEdgeData();
		for (var i = data.length-1; i >= 0; i--) {
			if (data[i].id === edgeId) {
				data.splice(i, 1);
			}
		}
		
		if (removeOrphans) {
			var potentialOrphans = {};
			data = this.getNodeData();
			for (var i = 0; i < data.length; i++) {
				potentialOrphans[data[i].id] = true;
			}
			data = this.getEdgeData();
			for (var i = 0; i < data.length; i++) {
				if (potentialOrphans[data[i].source.id]) {
					delete potentialOrphans[data[i].source.id];
				}
				if (potentialOrphans[data[i].target.id]) {
					delete potentialOrphans[data[i].target.id];
				}
			}
			for (var orphanId in potentialOrphans) {
				this.removeNode(orphanId, true);
			}
			
		}
		
		this.refreshGraph();
	},
	
	/**
	 * Initialize graph
	 */
	initGraph: function() {
		var el = this.getLayout().getRenderTarget();
		el.update('');
		var width = el.getWidth();
		var height = el.getHeight();
		
		var physics = this.getGraphPhysics();
		this.setVisLayout(d3.forceSimulation()
			.velocityDecay(physics.damping)
			.force('x', d3.forceX(width/2).strength(physics.centralGravity))
			.force('y', d3.forceY(height/2).strength(physics.centralGravity))
			.force('link', d3.forceLink().id(function(d) { return d.id; }).distance(physics.springLength).strength(physics.springStrength))
			.force('charge', d3.forceManyBody().strength(physics.nodeGravity))
			.force('collide', d3.forceCollide().radius(function(d) { return Math.sqrt(d.bbox.width * d.bbox.height)*physics.collisionScale; }))
			.on('tick', function() {
				this.getEdgeSelection()
					.attr('x1', function(d) { return d.source.x; })
					.attr('y1', function(d) { return d.source.y; })
					.attr('x2', function(d) { return d.target.x; })
					.attr('y2', function(d) { return d.target.y; });
		
				this.getNodeSelection()
					.attr('transform', function(d) {
						var x = d.x - d.bbox.width*0.5;
						var y = d.y - d.bbox.height*0.5;
						return 'translate('+x+','+y+')';
					});
				
				if (this.getVisLayout().alpha() < 0.075) {
 					this.getVisLayout().alpha(-1); // trigger end event
 				}
			}.bind(this))
			.on('end', function() {
				Ext.Function.defer(this.zoomToFit, 100, this);
			}.bind(this))
		);
		
		var svg = d3.select(el.dom).append('svg').attr('width', width).attr('height', height);
		var g = svg.append('g');
		
		var zoom = d3.zoom()
			.scaleExtent(this.getZoomExtent())
			.on('zoom', function() {
				g.attr('transform', d3.event.transform);
			});
		this.setZoom(zoom);
		svg.call(zoom);
		
		this.setEdgeSelection(g.append('g').attr('class', 'edges').selectAll('.edge'));
		this.setNodeSelection(g.append('g').attr('class', 'nodes').selectAll('.node'));
		this.setVis(g);
	},
	
	resetGraph: function() {
		this.setNodeData([]);
		this.setEdgeData([]);
		this.refreshGraph();
	},
	
	/**
	 * Rebuild graph from data
	 */
	refreshGraph: function() {
		if (this.getVisLayout() === undefined) return;
		
		var edgeData = this.getEdgeData();
		var nodeData = this.getNodeData();
		
		var nodeExtent = d3.extent(nodeData, function(d) { return d.value; });
		var edgeExtent = d3.extent(edgeData, function(d) { return d.value; });

		var edgeScaling = this.getEdgeScaling();
		if (edgeScaling.scalingFunction === undefined) {
			edgeScaling.scalingFunction = d3.scaleLinear().domain(edgeExtent).range([edgeScaling.minSize, edgeScaling.maxSize]);
		}
		
		var nodeScaling = this.getNodeScaling();
		if (nodeScaling.scalingFunction === undefined) {
			nodeScaling.scalingFunction = d3.scaleLog().domain(nodeExtent).range([nodeScaling.minSize, nodeScaling.maxSize]);
		}
		
		var edge = this.getEdgeSelection().data(edgeData, function(d) { return d.id; });
		edge.exit().remove();
		var edgeEnter = edge.enter().append('line')
			.attr('class', 'edge')
			.attr('id', function(d) { return d.id; })
			.style('cursor', 'pointer')
			.style('stroke-width', function(d) { return edgeScaling.scalingFunction(d.value); })
			.on('mouseover', this.edgeMouseOver.bind(this))
			.on('mouseout', this.edgeMouseOut.bind(this))
			.on('click', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.setCurrentEdge(d);
				this.fireEvent('edgeclicked', this, d);
			}.bind(this));
		
		this.setEdgeSelection(edgeEnter.merge(edge));
		
		var node = this.getNodeSelection().data(nodeData, function(d) { return d.id; });
		node.exit().remove();
		var nodeEnter = node.enter().append('g')
			.attr('class', 'node')
			.attr('id', function(d) { return d.id; })
			.style('cursor', 'pointer')
			.on('mouseover', this.nodeMouseOver.bind(this))
			.on('mouseout', this.nodeMouseOut.bind(this))
			.on('click', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.setCurrentNode(d);
				this.fireEvent('nodeclicked', this, d);
			}.bind(this))
			.on('dblclick', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.fireEvent('nodedblclicked', this, d);
			}.bind(this))
			.on('contextmenu', function(d) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.fireEvent('nodecontextclicked', this, d);
			}.bind(this))
			.call(d3.drag()
				.on('start', function(d) {
					this.setDragging(true);
					if (!d3.event.active) {
						this.getVisLayout().alpha(0.3).restart();
					}
					d.fx = d.x;
					d.fy = d.y;
					d.fixed = true;
					this.fireEvent('nodedragstart', this, d);
				}.bind(this))
				.on('drag', function(d) {
					this.getVisLayout().alpha(0.3); // don't let simulation end while the user is dragging
					d.fx = d3.event.x;
					d.fy = d3.event.y;
					this.fireEvent('nodedrag', this, d);
				}.bind(this))
				.on('end', function(d) {
					this.setDragging(false);
					// if (!d3.event.active) this.getVisLayout().alpha(0);
					if (d.fixed != true) {
						d.fx = null;
						d.fy = null;
					}
					this.fireEvent('nodedragend', this, d);
				}.bind(this))
			);

		// TODO detect title
		// nodeEnter.append('title').text(function(d) { return d.title; });

		nodeEnter.append('rect');
				
		nodeEnter.append('text')
			.text(function(d) { return d.term; })
			.attr('font-family', function(d) { return Voyant.application.getCategoriesManager().getFeatureForTerm('font', d.term); })
			.attr('font-size', function(d) {return nodeScaling.scalingFunction(d.value)+'px';})
//            .attr('text-anchor', 'middle')
			.attr('dominant-baseline', 'middle')
			.style('user-select', 'none')
			.each(function(d) { d.bbox = this.getBBox(); });
		
		this.setNodeSelection(nodeEnter.merge(node));
		
		this.getNodeSelection().selectAll('rect')
			.attr('width', function(d) { return d.bbox.width+16; })
			.attr('height', function(d) { return d.bbox.height+8; })
			.attr('rx', function(d) { return Math.max(2, d.bbox.height * 0.2); })
			.attr('ry', function(d) { return Math.max(2, d.bbox.height * 0.2); });
		
		this.getNodeSelection().selectAll('text')
			.attr('dx', 8)
			.attr('dy', function(d) { return d.bbox.height*0.5+4; });
		

		this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
		this.getNodeSelection().call(this.applyNodeStyle.bind(this));
		
		this.getVisLayout().nodes(nodeData);
		this.getVisLayout().force('link').links(edgeData);
		this.getVisLayout().alpha(1).restart();
	},
	
	zoomToFit: function(paddingPercent, transitionDuration) {
		var bounds = this.getVis().node().getBBox();
		var width = bounds.width;
		var height = bounds.height;
		var midX = bounds.x + width/2;
		var midY = bounds.y + height/2;
		var svg = this.getVis().node().parentElement;
		var svgRect = svg.getBoundingClientRect();
		var fullWidth = svgRect.width;
		var fullHeight = svgRect.height;
		var scale = (paddingPercent || 0.8) / Math.max(width/fullWidth, height/fullHeight);
		var translate = [fullWidth/2 - scale*midX, fullHeight/2 - scale*midY];
		if (width<1) {return} // FIXME: something strange with spyral
		
		d3.select(svg)
			.transition()
			.duration(transitionDuration || 500)
			.call(this.getZoom().transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
	},
	
	nodeScaling: function(min, max, total, value) {
		if (min === max) {
			return 0.5;
		} else {
			var scale = 1 / (max - min);
			return Math.max(0, (value-min)*scale);
		}
	},
	
	/**
	 * Method for styling nodes, using the default config.graphStyle.
	 * Override this method for custom styling.
	 * @param {*} sel D3 selection
	 * @param {String} nodeState  The state of the node: 'normal' or 'highlight'
	 */
	applyNodeStyle: function(sel, nodeState) {
		var state = nodeState === undefined ? 'normal' : nodeState;
		var style = this.getGraphStyle().node[state];
		sel.selectAll('rect')
			.style('fill', function(d) { return style.fill; }.bind(this))
			.style('fill-opacity', function(d) { return style.fillOpacity; }.bind(this))
			.style('stroke', function(d) { return style.stroke; }.bind(this))
			.style('stroke-opacity', function(d) { return style.strokeOpacity; }.bind(this))
			.style('stroke-width', function(d) { return style.strokeWidth; }.bind(this));
	},
	
	/**
	 * Method for styling edges, using the default config.graphStyle.
	 * Override this method for custom styling.
	 * @param {*} sel D3 selection
	 * @param {String} edgeState The state of the edge: 'normal' or 'highlight'
	 */
	applyEdgeStyle: function(sel, edgeState) {
		var state = edgeState === undefined ? 'normal' : edgeState;
		var style = this.getGraphStyle().edge[state];
		sel.style('stroke', function(d) { return style.stroke; }.bind(this))
			.style('stroke-opacity', function(d) { return style.strokeOpacity; }.bind(this));
//	    	.style('stroke-width', function(d) { return style.strokeWidth; }.bind(this));
	},

	edgeMouseOver: function(d) {
		this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
		this.getVis().select('#'+d.id).call(this.applyEdgeStyle.bind(this), 'highlight');
	},
	
	edgeMouseOut: function(d) {
		this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
	},
	
	nodeMouseOver: function(d) {
		this.setCurrentNode(d);
		
		this.getNodeSelection().call(this.applyNodeStyle.bind(this));
		
		this.getEdgeSelection().each(function(link) {
			var id;
			if (link.source.id == d.id) {
				id = link.target.id;
			} else if (link.target.id == d.id) {
				id = link.source.id;
			}
			if (id !== undefined) {
				this.getVis().select('#'+id).call(this.applyNodeStyle.bind(this), 'highlight');
				this.getVis().select('#'+link.id).call(this.applyEdgeStyle.bind(this), 'highlight');
			}
		}.bind(this));
		
		this.getVis().select('#'+d.id).call(this.applyNodeStyle.bind(this), 'highlight');
	},
	
	nodeMouseOut: function(d) {
		this.getNodeSelection().call(this.applyNodeStyle.bind(this));
		this.getEdgeSelection().call(this.applyEdgeStyle.bind(this));
	}
});
Ext.define('Voyant.widget.ReaderGraph', {
    extend: 'Ext.container.Container',
    mixins: ['Voyant.util.Localization'],
    alias: 'widget.readergraph',
    statics: {
        i18n: {
        }
    },
    config: {
        parentPanel: undefined,
        corpus: undefined,
        documentsStore: undefined,
    	locationMarker: undefined,
    	isDetailedGraph: true,
		seriesToolTip: undefined
    },
    
    locationMarkerColor: '#157fcc',

    DETAILED_GRAPH_DOC_LIMIT: 25, // upper limit on document count for showing detailed graphs
    LOCATION_UPDATE_FREQ: 100,

    SCROLL_UP: -1,
    SCROLL_EQ: 0,
    SCROLL_DOWN: 1,

    RESERVED_KEYS: ['id', 'docIndex', 'readerGraphPadding', 'readerGraphTotal'],

    constructor: function(config) {
        this.callParent(arguments);
    },

    initComponent: function() {
        Ext.apply(this, {
            layout: {
                type: 'hbox'
            },
            items: []
        });

        this.callParent(arguments);

        var parentPanel = this.findParentBy(function(clz) {
    		return clz.mixins["Voyant.panel.Panel"];
        });
    	if (parentPanel != null) {
            this.setParentPanel(parentPanel);
    		if (parentPanel.getCorpus && parentPanel.getCorpus()) {
    			this.on("afterrender", function(c) {
    				this.setCorpus(parentPanel.getCorpus());	
    			}, this);
    		} else {
                parentPanel.on("loadedCorpus", function(src, corpus) {
                    this.setCorpus(corpus);
                }, this);
                this.hasCorpusLoadedListener = true;
    		}
        }

		this.setSeriesToolTip(Ext.create('Ext.tip.ToolTip', {
			style: 'background: #fff',
			dismissDelay: 0
		}));
        
        this.on('boxready', function() {
            if (this.getLocationMarker() == undefined) {
                this.setLocationMarker(Ext.DomHelper.append(this.getEl(), {tag: 'div', style: 'background-color: '+this.locationMarkerColor+'; height: 100%; width: 2px; z-index: 3; position: absolute; top: 0; left: 0;'}));
            }
        });        
    },

    updateCorpus: function(corpus) {
        var docs = corpus.getDocuments();
        this.setDocumentsStore(docs);
        this.setIsDetailedGraph(docs.getTotalCount() < this.DETAILED_GRAPH_DOC_LIMIT);

        this.generateChart();
    },

    loadQueryTerms: function(queryTerms) {
        // TODO add categories param?
        if (this.getIsDetailedGraph()) {
            this.getCorpus().getDocumentTerms().load({
                params: {
                    query: queryTerms,
                    limit: -1,
                    withDistributions: true
                },
                callback: function(records, operation) {
                    this.populateDetailedChart(records);
                },
                scope: this
            })
        } else {
            this.getCorpus().getCorpusTerms().load({
                params: {
                    query: queryTerms,
                    limit: -1,
                    withDistributions: true
                },
                callback: function(records, operation) {
                    this.populateChart(records);
                },
                scope: this
            })
        }
            
    },

    populateDetailedChart: function(records) {
        var graphDatas = {};
        var maxValue = 0;
        records.forEach(function(r) {
            var graphData = [];
            var dist = r.get('distributions');
            var docId = r.get('docId');
            var docIndex = r.get('docIndex');
            var term = r.get('term');
            for (var i = 0; i < dist.length; i++) {
                var val = dist[i];
                if (val > maxValue) maxValue = val;
                graphData.push([docId, docIndex, i, val, term]);
            }
            if (graphDatas[docIndex] === undefined) {
                graphDatas[docIndex] = {};
            }
            graphDatas[docIndex][term] = graphData;
        });
        var graphs = this.query('cartesian');
        for (var i = 0; i < graphs.length; i++) {
            var graph = graphs[i];

            var docData = graphDatas[i];
            if (docData !== undefined) {
                var series = [];
                for (var term in docData) {
                    var termData = docData[term];
                    var sColor = this.getParentPanel().getApplication().getColorForTerm(term, true);
                    series.push({
                        type: 'line',
                        xField: 'bin',
                        yField: 'distribution',
                        style: { lineWidth: 1, strokeStyle: sColor },
                        store: Ext.create('Ext.data.ArrayStore', {
                            fields: ['docId', 'docIndex', 'bin', 'distribution', 'term'],
                            data: termData
                        })
                    });
                }
                graph.getAxes()[0].setMaximum(maxValue);
                graph.setSeries(series);
            }
        }
    },

	populateChart: function(records) {
		var graphDatas = {};
        this.getCorpus().getDocuments().each(function(doc, index) {
            graphDatas[index] = {};
        });
        var terms = [];
        records.forEach(function(r) {
            var term = r.get('term');
            if (terms.indexOf(term) === -1) {
                terms.push(term);
            }
            var dists = r.get('distributions');
            dists.forEach(function(val, docIndex) {
                graphDatas[docIndex][term] = val;
            });
        });
        terms.push('readerGraphPadding');

        var seriesData = Object.entries(graphDatas).map(function(termData) {
            return Object.assign({docIndex: parseInt(termData[0])}, termData[1]);
        });

        var maxValue = -1;
        seriesData.forEach(function(termData) {
            var total = Object.entries(termData)
                .filter(function(td) { return td[0] !== 'docIndex'})
                .map(function(td) { return td[1]})
                .reduce(function(prevVal, currVal) { return prevVal+currVal});
            
            termData.readerGraphTotal = total;

            if (total > maxValue) {
                maxValue = total;
            }
        });

        seriesData.forEach(function(termData) {
            termData.readerGraphPadding = maxValue - termData.readerGraphTotal;
        });

        var series = {
            type: 'bar',
            stacked: true,
            fullStack: true,
            xField: 'docIndex',
            yField: terms,
            style: {
                minGapWidth: 0,
                minBarWidth: 1,
                lineWidth: 0,
                strokeStyle: 'none'
            },
            renderer: function (sprite, config, rendererData, index) {
                var term = sprite.getField();
                var color;
                if (term === 'readerGraphPadding') {
                    color = this.getColor(index, 0.3);
                } else {
                    color = this.getParentPanel().getApplication().getColorForTerm(term, true);
                }
                return {fillStyle: color};
            }.bind(this)
        };
        var graph = this.down('cartesian');
        graph.getAxes()[0].setFields(terms);
        graph.setSeries(series);
        graph.setStore(Ext.create('Ext.data.JsonStore', {
            fields: ['docIndex'].concat(terms),
            data: seriesData
        }));
    },

	getColor: function(index, alpha) {
		var c = index % 2 === 0 ? [200,200,200] : [240,240,240];
		return 'rgba('+c.join(',')+','+alpha+')';
	},

    generateChart: function() {
		var me = this;
        
        function addChart(docInfo) {
            var index = docInfo.docIndex;
            var fraction = docInfo.fraction;
            var height = docInfo.relativeHeight;
            var bColor = this.getColor(index, 0.3);
            var chart = me.add({
                xtype: 'cartesian',
                plugins: {
                    ptype: 'chartitemevents'
                },
                flex: fraction,
                height: '100%',
                insetPadding: 0,
                background: {
                    type: 'linear',
                    degrees: 90,
                    stops: [{
                        offset: 0,
                        color: bColor
                    },{
                        offset: height,
                        color: bColor
                    },{
                        offset: height,
                        color: 'white'
                    },{
                        offset: 1,
                        color: 'white'
                    }]
                },
                axes: [{
                    type: 'numeric',
                    position: 'left',
                    fields: 'distribution',
                    hidden: true
                },{
                    type: 'category',
                    position: 'bottom',
                    fields: 'bin',
                    hidden: true
                }],
				listeners: {
					itemmouseover: function(chart, item, event) {
						var tooltipHtml = this.getCorpus().getDocument(item.record.get('docIndex')).getTitle();
						chart.getSeries().forEach(function(series) {
							var seriesItem = series.getItemByIndex(item.index);
							var term = seriesItem.record.get('term');
							var dist = seriesItem.record.get('distribution');
							tooltipHtml += '<br>'+term+': '+dist;
						}, this);
						this.getSeriesToolTip().setHtml(tooltipHtml);
						var xy = event.getXY();
						xy[0] += 15;
						xy[1] += 18;
						this.getSeriesToolTip().showAt(xy);
					},
					scope: this
				}
            });

            chart.body.on('mouseenter', function(event, target) {
                if (chart.getSeries().length === 0) {
                    var tooltipHtml = this.getCorpus().getDocument(docInfo.docIndex).getTitle();
                    this.getSeriesToolTip().setHtml(tooltipHtml);
                    var xy = event.getXY();
                    xy[0] += 15;
                    xy[1] += 18;
                    this.getSeriesToolTip().showAt(xy);
                }
            }, this);

			chart.body.on('mouseleave', function(event, target) {
				this.getSeriesToolTip().hide();
			}, this);
            
            chart.body.on('click', function(event, target) {
                var el = Ext.get(target);
                
                var x = event.getX();
                var box = el.getBox();
                var fraction = (x - box.x) / box.width;

                var chartContainer = el.parent('.x-panel');
                var containerParent = chartContainer.parent();
                var children = Ext.toArray(containerParent.dom.children);
                var docIndex = children.indexOf(chartContainer.dom);

                this.fireEvent('documentRelativePositionSelected', this, {docIndex: docIndex, fraction: fraction});
            }, this);
        }
        
        me.removeAll();
        
        var docs = me.getCorpus().getDocuments();
        var tokensTotal = me.getCorpus().getWordTokensCount();
        var docInfos = [];
        for (var i = 0; i < docs.getCount(); i++) {
            var d = docs.getAt(i);
            var docIndex = d.get('index');
            var count = d.get('tokensCount-lexical');
            var fraction = count / tokensTotal;
            docInfos.push({
                docIndex: docIndex,
                count: 1, // same height for all
                fraction: fraction
            });
        }
        
        if (this.getIsDetailedGraph()) {
            for (var i = 0; i < docInfos.length; i++) {
                var d = docInfos[i];
                d.relativeHeight = 1; // same height for all
                addChart.call(this, d);
            }
        } else {
            var chart = me.add({
                xtype: 'cartesian',
                plugins: {
                    ptype: 'chartitemevents'
                },
                flex: 1,
                height: '100%',
                animation: false,
                insetPadding: 0,
                axes: [{
                    type: 'numeric',
                    position: 'left',
                    fields: 'count',
                    hidden: true
                },{
                    type: 'category',
                    position: 'bottom',
                    fields: 'docIndex',
                    hidden: true
                }],
                series: [{
                    type: 'bar',
                    xField: 'docIndex',
                    yField: 'count',
                    style: {
                        minGapWidth: 0,
                        minBarWidth: 1,
                        lineWidth: 0,
                        strokeStyle: 'none'
                    },
                    renderer: function (sprite, config, rendererData, index) {
                        return {fillStyle: this.getColor.call(this, index, 0.3)};
                    }.bind(this)
                }],
                store: Ext.create('Ext.data.JsonStore', {
                    fields: [{name: 'docIndex', type: 'int'}, {name: 'count', type: 'int'}],
                    data: docInfos
                }),
                listeners: {
                    itemmouseover: function(chart, item, event) {
						var tooltipHtml = this.getCorpus().getDocument(item.record.get('docIndex')).getTitle();

                        if (chart.getSeries()[0].getFullStack()) {
                            Object.keys(item.record.data)
                                .filter(function(key) { return me.RESERVED_KEYS.indexOf(key) === -1 })
                                .forEach(function(key) {
                                    var val = item.record.data[key];
                                    tooltipHtml += '<br>'+key+': '+val;
                                }, this);
                        }
                        
						this.getSeriesToolTip().setHtml(tooltipHtml);
						var xy = event.getXY();
						xy[0] += 15;
						xy[1] += 18;
						this.getSeriesToolTip().showAt(xy);
					},
                    itemclick: function(chart, item, event) {
                        var el = Ext.get(event.getTarget());
                        var x = event.getX();
                        var box = el.getBox();
                        var docWidth = box.width / this.getCorpus().getDocuments().getCount();
                        var docX = (x - box.x) % docWidth;
                        var fraction = docX / docWidth;

            			var docIndex = item.record.get('docIndex');
                        var doc = this.getDocumentsStore().getAt(docIndex);
                        var docIndex = doc.getIndex();

                        this.fireEvent('documentRelativePositionSelected', this, {docIndex: docIndex, fraction: fraction});
                    },
                    scope: this
                }
            });
            chart.body.on('mouseleave', function(event, target) {
				this.getSeriesToolTip().hide();
			}, this);
        }

    },

    moveLocationMarker: function(docIndex, fraction, scrollDir) {
        var locMarkEl = Ext.get(this.getLocationMarker());
        var locX = locMarkEl.getX();
        if (this.getIsDetailedGraph()) {
            var graph = this.query('cartesian')[docIndex];
            if (graph) {
                locX = graph.getX() + graph.getWidth()*fraction;
            }
        } else {
            var graph = this.down('cartesian');
            if (graph) {
                var docWidth = graph.getWidth() / this.getCorpus().getDocuments().getCount();
                locX = graph.getX() + docWidth*docIndex + docWidth*fraction;
            }
        }
        if (scrollDir != null) {
            var currX = locMarkEl.getX();
            // prevent location being set in opposite direction of scroll
            if ((scrollDir == this.SCROLL_DOWN && currX > locX) || (scrollDir == this.SCROLL_UP && currX < locX)) locX = currX;
        }
        locMarkEl.setX(locX);
    }
});
Ext.define('Voyant.widget.EntitiesList', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.entitieslist',
	statics: {
		i18n: {
			term: 'Term',
			count: 'Count',
			next: 'Next Occurrence',
			prev: 'Previous Occurrence',
			date: 'Date',
			person: 'Person',
			gpe: 'Geopolitical Entity',
			loc: 'Location',
			money: 'Money',
			time: 'Time',
			product: 'Product',
			cardinal: 'Cardinal',
			quantity: 'Quantity',
			event: 'Event',
			fac: 'Facility',
			language: 'Language',
			law: 'Law',
			norp: 'National/Religious/Political',
			percent: 'Percent',
			work_of_art: 'Work of Art',
			unknown: 'Unknown',
			duration: 'Duration',
			location: 'Location',
			misc: 'Misc',
			organization: 'Organization',
			set: 'Set'
		}
	},

	bins: 25,

	initComponent: function() {
		var me = this;
		Ext.apply(this, {
			title: 'Entities',
			forceFit: true,
			store: Ext.create('Ext.data.JsonStore', {
				fields: ['term','normalized','type','docIndex','rawFreq','positions','offset'],
				groupField: 'type',
				sorters: [{
					property: 'rawFreq',
					direction: 'DESC'
				}]
			}),
			features: [{
				ftype: 'grouping',
				hideGroupedHeader: true,
				enableGroupingMenu: false,
				startCollapsed: true,
				groupHeaderTpl: ['{name:this.localizeName} ({children.length})',{
					localizeName: function(name) {
						return me.localize(name);
					}
				}]
			}],
			plugins: [{
				ptype: 'rowexpander',
				rowBodyTpl: new Ext.XTemplate(''),
				expandOnDblClick: false
			}],
			viewConfig: {
				listeners: {
					expandbody: function(rowNode, record, expandRow, eOpts) {
						me.getSelectionModel().select(record, false, true); // select expanded row, otherwise select event gets triggered later when interacting with prev/next buttons
						if (expandRow.textContent === '' || (eOpts && eOpts.force)) {
							var parentEl = expandRow.querySelector('div.x-grid-rowbody');
							var expandedRow = Ext.create('Ext.container.Container', {
								currentEntityPositionIndex: 0,
								handlePositionChange: function(dir) {
									if (dir < 0) {
										this.currentEntityPositionIndex--;
										if (this.currentEntityPositionIndex < 0) this.currentEntityPositionIndex = record.get('positions').length-1;
									} else {
										this.currentEntityPositionIndex++;
										if (this.currentEntityPositionIndex > record.get('positions').length-1) this.currentEntityPositionIndex = 0;
									}

									// programatically highlight the current bar
									var dist = record.get('distribution');
									var distBinToHighlight = 0;
									var distBinCount = 0;
									for (var i = 0; i < dist.length; i++) {
										distBinCount += dist[i];
										if (distBinCount > this.currentEntityPositionIndex) {
											distBinToHighlight = i;
											break;
										}
									}
									var sparkline = this.down('sparklinebar');
									var sparklineBox = sparkline.canvas.el.getBox();
									var binWidth = sparkline.getBarWidth()+sparkline.getBarSpacing();
									var mouseX = sparklineBox.x + (binWidth * distBinToHighlight);
									var mouseY = sparklineBox.y + (sparklineBox.height*.5);
									var event = Ext.create('Ext.event.Event', new MouseEvent('mousemove', {clientX: mouseX, clientY: mouseY}));
									sparkline.onMouseMove(event);

									Voyant.application.dispatchEvent('entityLocationClicked', this, record, this.currentEntityPositionIndex);
								},
								layout: {
									type: 'hbox',
									align: 'middle'
								},
								renderTo: parentEl,
								items: [{
									xtype: 'button',
									glyph: 'xf060@FontAwesome',
									tooltip: me.localize('prev'),
									handler: function(btn, e) {
										btn.up('container').handlePositionChange(-1);
									}
								},{
									xtype: 'button',
									glyph: 'xf061@FontAwesome',
									tooltip: me.localize('next'),
									margin: '0 5',
									handler: function(btn, e) {
										btn.up('container').handlePositionChange(1);
									}
								},{
									xtype: 'sparklinebar',
									values: record.get('distribution'),
									highlightColor: '#f80',
									height: 24,
									tipTpl: false,
									width: parentEl.offsetWidth - 80 // TODO resize when layout changes
								}],
								listeners: {
									boxready: function(cmp) {
										setTimeout(function() {
											cmp.currentEntityPositionIndex = -1;
											cmp.handlePositionChange(1);
										}, 50);
									}
								}
							});
						}
					}
				}
			},
			columns: [{
				text: this.localize('term'),
				dataIndex: 'term',
				flex: 1
			},{
				text: this.localize('count'),
				dataIndex: 'rawFreq',
				width: 50
			}],
			listeners: {
				select: function(cmp, record, index) {
					Voyant.application.dispatchEvent('entityClicked', this, record);
				},
				columnresize: function(ct, column, width) {
				}
			}
		});
		
		this.callParent(arguments);
	},

	addEntities: function(entities) {
		var store = this.getStore();
		if (store !== undefined) {
			var append = false;
			if (store.count() > 0 && entities.length > 0) {
				var oldDocIndex = store.first().get('docIndex');
				var newDocIndex = entities[0].docIndex;
				append = oldDocIndex === newDocIndex;
			}
			entities.forEach(function(entity) {
				if (entity.positions) {
					entity.distribution = this.getDistributionFromPositions(entity.docIndex, entity.positions, this.bins);
				} else {
					console.warn('no positions for:',entity);
					entity.distribution = [];
				}
			}, this);
			store.loadData(entities, append);
			if (append === false) {
				this.view.findFeature('grouping').collapseAll();
			}
		}
	},

	getDistributionFromPositions: function(docIndex, positions, bins) {
		var totalTokens = Voyant.application.getCorpus().getDocument(docIndex).get('tokensCount-lexical');
		var binSize = Math.floor(totalTokens/bins);
		
		var distribution = new Array(bins);
		for (var i = 0; i < bins; i++) { distribution[i] = 0; }

		positions.forEach(function(position) {
			var bin;
			if (Array.isArray(position)) {
				bin = Math.floor(position[0] / binSize);
			} else {
				bin = Math.floor(position / binSize);
			}
			distribution[bin]++;
		});

		return distribution;
	}
});
Ext.define('Voyant.panel.Panel', {
	mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.util.Toolable','Voyant.util.DetailedError'],
	requires: ['Voyant.widget.QuerySearchField','Voyant.widget.StopListOption','Voyant.categories.CategoriesOption','Voyant.widget.TotalPropertyStatus'],
	alias: 'widget.voyantpanel',
	statics: {
		i18n: {
		},
		config: {
			corpusValidated: false
		},
		api: {
			corpus: undefined,
			input: undefined,
			inputFormat: undefined,
			subtitle: undefined
		}
	},
	config: {
		corpus: undefined
	},
	constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		this.mixins['Voyant.util.Toolable'].constructor.apply(this, arguments);
		if (!this.glyph) {
			this.glyph = Ext.ClassManager.getClass(this).glyph
		}
		
		this.on("afterrender", function() {
			if (this.getXType()!='facet' && this.getApiParam('subtitle') && this.getTitle()) {
				this.setTitle(this.getTitle()+" <i style='font-size: smaller;'>"+this.getApiParam('subtitle')+"</i>")
			}
			if (this.isXType("grid")) {
				this.getSelectionModel().on("selectionchange", function(store, records) {
//					console.warn(records, this.selectedRecordsToRemember)
//					this.selectedRecordsToRemember = records;
				}, this);
				this.getStore().on("beforeload", function() {
					this.selectedRecordsToRemember = this.getSelection();
				}, this)
				this.getStore().on("load", function(store, records) {
					if (Ext.Array.from(this.selectedRecordsToRemember).length>0) {
						// combine contents of store with contents of remembered items, filtering out duplicates
						var seen = {}
						var mergedRecords = Ext.Array.merge(this.selectedRecordsToRemember, records).filter(function(item) {
							if (!(item.getId() in seen)) {
								seen[item.getId()]=true;
								return true
							} else {
								return false;
							}
						});
						if (store.isBufferedStore) {
							if (store.currentPage==1) {
								store.data.addAll(mergedRecords);
								store.totalCount = mergedRecords.length;
								store.fireEvent('refresh', store);
							}
						} else {
							store.loadRecords(mergedRecords);
							this.getSelectionModel().select(this.selectedRecordsToRemember);
							store.fireEvent('refresh', store);
							this.selectedRecordsToRemember = [];
						}
					}
				}, this);
			}
		}, this);
		
		this.on({
			loadedCorpus: {
				fn: function(src, corpus) {
		    		// make sure API is updated if we had a corpus and it's changed, this should be registered first, so hopefully be fired before tools receive notification
		    		this.setApiParam("corpus", corpus.getAliasOrId());
					this.setCorpus(corpus);
				},
				priority: 999, // very high priority
				scope: this
			}
		});
	},
	
	getApplication: function() {
		return Voyant.application;
	},
	
	getBaseUrl: function() {
		return this.getApplication().getBaseUrl();
	},
	
	openUrl: function(url) {
		this.getApplication().openUrl.apply(this, arguments);
	},
	
	getTromboneUrl: function() {
		return this.getApplication().getTromboneUrl();
	},
	
	dispatchEvent: function() {
		var application = this.getApplication();
		application.dispatchEvent.apply(application, arguments);
	},
	
	showError: function(config, response) {
		if (Ext.isString(config)) {
			config = {
				message: config
			}
		}
		Ext.applyIf(config, {
			title: this.localize("error")+" ("+this.localize("title")+")"
		})
		this.getApplication().showError(config, response)
	},
	
	showResponseError: function(config, response) {
		this.getApplication().showResponseError(config, response)
	},
	
	toastError: function(config) {
		if (Ext.isString(config)) {
			config = {html: config}
		}
		Ext.applyIf(config, {
			glyph: 'xf071@FontAwesome',
			title: this.localize("error")
		})
		this.toast(config);
	},
	
	toastInfo: function(config) {
		if (Ext.isString(config)) {
			config = {html: config}
		}
		Ext.applyIf(config, {
			glyph: 'xf05a@FontAwesome',
			title: this.localize("info")
		})
		this.toast(config);
	},
	
	toast: function(config) {
		if (Ext.isString(config)) {
			config = {html: config}
		}
		Ext.applyIf(config, {
			 slideInDuration: 500,
			 shadow: true,
			 align: 'b',
			 anchor: this.getTargetEl()			
		})
		Ext.toast(config);
	},

	/**
	 * Checks to see if we have access to this corpus, first by checking the application's
	 * access setting for the corpus, then by checking the corpus setting.
	 * 
	 * Assumes we're only calling this from a non-consumptive tool.
	 */
	hasCorpusAccess: function(corpus) {
		var app = this.getApplication();
		if (app) {
			var corpusAccess = app.getCorpusAccess();
			if (corpusAccess=='ADMIN' || corpusAccess=='ACCESS') {return true;}
		}
		if (!corpus) {
			if (this.getCorpus) {
				corpus = this.getCorpus();
			}
			if (!corpus && app.getCorpus) {
				corpus = app.getCorpus();
			}
		}
		if (corpus) {
			return corpus.getNoPasswordAccess()!='NONCONSUMPTIVE' && corpus.getNoPasswordAccess()!='NONE';
		}
		return false; // don't know if we ever get here
	}
	
});

Ext.define('Voyant.panel.VoyantTabPanel', {
	extend: 'Ext.tab.Panel',
	alias: 'widget.voyanttabpanel',
	mixins: ['Voyant.panel.Panel'],
	statics: {
		i18n: {
		}
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	initComponent: function() {
    	this.callParent(arguments);
	},
	listeners: {
		tabchange: function(panel, newTab) {
			this.tools = [];
			this.getHeader().tools = [];
			this.query("toolmenu").forEach(function(toolMenu) {
				toolMenu.destroy();
			})
			this.addTool(newTab.tools)
			this.getApplication().dispatchEvent("panelChange", this)
		},
		afterrender: function(panel) {
			this.fireEvent("tabchange", this, this.getActiveTab())
		}
	},
	showOptionsClick: function(panel) {
		var tab = panel.getActiveTab();
		if (tab.showOptionsClick) {
			tab.showOptionsClick.apply(tab, arguments)
		}
	}
});
Ext.define('Voyant.widget.Facet', {
	extend: 'Ext.grid.Panel',
    mixins: ['Voyant.panel.Panel'],
    alias: 'widget.facet',
	statics: {
		i18n: {
		},
		api: {
			stopList: 'auto',
			query: undefined
		}
	},
	
	constructor: function(config) {
        this.callParent(arguments);
        Ext.applyIf(config || {}, {
        	includeTools: [], // don't show tools in header
        	rowLines: false,
			subtitle: undefined
        });
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, [config]);
	},
	
	rowLines: false,
	
    initComponent: function(){

    	var me = this;
    	if (!this.store) {
    		this.store = new Ext.create("Voyant.data.store.CorpusFacets", {
    			proxy: {
    				extraParams: {
    					facet: this.facet
    				}
    			},
    			parentPanel: this
    		})
    		this.store.getProxy().on("exception", function(proxy, request, operation, eOpts) {
		    	me.showResponseError("Unable to fetch facet: "+me.facet, request);
    		})
    	}
    	
        Ext.applyIf(this, {
        	emptyText: this.localize("emptyText"),
        	hideHeaders: true,
        	selType: 'checkboxmodel',
        	columns: [
				{ renderer: function(value, metaData, record) {return "("+record.getInDocumentsCount()+") "+record.getLabel()}, flex: 1 }
        	]
        });
        this.callParent();
        
        if (this.corpus) {
        	this.setStoreCorpus(this.corpus);
        }
        
        this.on('loadedCorpus', function(src, corpus) {
        	this.setStoreCorpus(corpus);
        }, this);
        
        this.on("query", function(src, query) {
        	this.setApiParam("query", query);
        	// not getting set from beforeload, so set params here
        	this.store.load({
        		params: this.getApiParams()
        	})
        })
    },
    
    setStoreCorpus: function(corpus) {
//    	this.callParent(arguments)
    	if (this.getStore()) {
        	this.getStore().setCorpus(corpus);
        	this.getStore().load();
    	}
    }
});

// assuming Bubblelines library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Bubbles', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.bubbles',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		docIndex: 0,
    		
    		limit: 100,
    		
    		audio: false,
    		
    		speed: 30
    			
    			
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
    	options: {xtype: 'stoplistoption'},
    	audio: false
	},
	
	corpusLoaded: false,
	processingLoaded: false,
	bubblesAppCode: undefined,
	
	bubbles: undefined,
	oscillator: undefined,
	gainNode: undefined,
	
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	Ext.apply(this, {
    		title: this.localize('title'),
			html: '<canvas style="width: 100%; height: 100%"></canvas>',
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					fieldLabel: this.localize('speed'),
					labelAlign: 'right',
					labelWidth: 40,
					width: 100,
					increment: 1,
					minValue: 1,
					maxValue: 60,
					value: 30,
					listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(parseInt(this.getApiParam("speed")));
	                		if (this.bubbles) {this.bubbles.frameRate(cmp.getValue())}
	                		this.setAudio(cmp.getValue());
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('speedTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    changecomplete: function(cmp, val) {
	                    	this.setApiParam('speed', val);
	                		if (this.bubbles) {this.bubbles.frameRate(val)}
	                    },
	                    scope: this
					}
				},{
	                xtype: 'checkbox',
	                boxLabel: this.localize('sound'),
	                listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(this.getApiParam("audio")===true ||  this.getApiParam("audio")=="true");
	                		this.setAudio(cmp.getValue());
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('soundTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    change: function(cmp, val) {
	                    	this.setApiParam('audio', val);
	                    	this.setAudio(val);
	                    },
	                    scope: this
	                }
	            },{xtype: 'tbfill'}, {
	    			xtype: 'tbtext',
	    			html: this.localize('adaptation') //https://www.m-i-b.com.ar/letters/en/
	    		}]
    		}]
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
		this.on('boxready', function() {
			this.loadBubbles();
		})

    	this.on('loadedCorpus', function(src, corpus) {
    		this.corpusLoaded = true;
			if (this.bubbles) {
				this.loadDocument();
			} else {
				this.loadBubbles();
			}
    	}, this);
    	
    	this.on("resize", function() {
    		if (this.bubbles) {
    			this.bubbles.size(this.body.getWidth(),this.body.getHeight());
    		}
    	});
    	
    	this.on("documentselected", function(src, doc) {
    		this.setApiParam('docIndex', this.getCorpus().getDocument(doc).getIndex());
    		this.loadDocument();
    	})
    },
    
    setAudio: function(val) {
    	if (this.gainNode) {this.gainNode.gain.value=val ? 1 : 0;}
    	this.callParent(arguments)
    },

    handleCurrentTerm: function(term) {
    	if (this.oscillator) {this.oscillator.frequency.value = this.terms[term] ? parseInt((this.terms[term]-this.minFreq) * 2000 / (this.maxFreq-this.minFreq)) : 0;}
    },
    
    handleDocFinished: function() {
    	if (this.gainNode) {this.gainNode.gain.value = 0;}
    	var index = parseInt(this.getApiParam('docIndex'));
    	if (index+1<this.getCorpus().getDocumentsCount()) {
    		this.setApiParam('docIndex', index+1);
    		this.loadDocument();
    	}
    },
    
    loadDocument: function() {
    	var me = this, doc = this.getCorpus().getDocument(parseInt(this.getApiParam('docIndex')));
    	// if we're not in a tab panel, set the document title as part of the header
    	if (!this.up("tabpanel")) {
        	this.setTitle(this.localize('title') + " <span class='subtitle'>"+doc.getFullLabel()+"</span>");
    	}

    	doc.loadDocumentTerms(Ext.apply(this.getApiParams(["stopList"]), {
    		limit: 100
    	})).then(function(documentTerms) {
    		me.terms = {};
    		documentTerms.each(function(documentTerm) {
    			me.terms[documentTerm.getTerm()] = documentTerm.getRawFreq();
    		})
    		var values = Object.keys(me.terms).map(function(k){return me.terms[k]});
    		me.minFreq = Ext.Array.min(values);
    		me.maxFreq = Ext.Array.max(values);
    		me.getCorpus().loadTokens({whitelist: Object.keys(me.terms), noOthers: true, limit: 0, docIndex: me.getApiParam('docIndex')}).then(function(tokens) {
    			var words = [];
        		tokens.each(function(token) {
    				words.push(token.getTerm().toLowerCase());
        		})
        		me.bubbles.setLines([doc.getTitle(),words.join(" ")]);
        		me.bubbles.loop();
        		me.oscillator.frequency.value = 150;
        		me.gainNode.gain.value = me.getAudio() ? 1 : 0;
    		})
    	})
    },

	loadBubbles: function() {
		if (this.bubbles === undefined && this.processingLoaded && this.bubblesAppCode !== undefined && this.getTargetEl() !== undefined) {
			var canvas = this.getTargetEl().dom.querySelector('canvas');
			this.bubbles = new Processing(canvas, this.bubblesAppCode);
			this.bubbles.size(this.getTargetEl().getWidth(),this.getTargetEl().getHeight());
			this.bubbles.frameRate(this.getApiParam('speed'));
			this.bubbles.bindJavascript(this);
			this.bubbles.noLoop();
			
			this.bubblesAppCode = undefined;

			if (this.corpusLoaded) {
				this.loadDocument();
			}
		}
	},
    
    initComponent: function() {
    	// make sure to load script
		Ext.Loader.loadScript({
			url: this.getBaseUrl()+"resources/processingjs/processing.min.js",
			onLoad: function() {
				this.processingLoaded = true;
				this.loadBubbles();
			},
			scope: this
		});

		Ext.Ajax.request({
			url: this.getBaseUrl()+'resources/bubbles/bubbles.pjs',
			success: function(data) {
				this.bubblesAppCode = data.responseText;
				this.loadBubbles();
			},
			scope: this
		})
		
		var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
		
		this.oscillator = audioCtx.createOscillator();
		this.gainNode = audioCtx.createGain();
		this.oscillator.connect(this.gainNode);
		this.gainNode.connect(audioCtx.destination);
		this.oscillator.frequency.value = 0;
		this.oscillator.start();
		this.gainNode.gain.value = 0;

    	this.callParent(arguments);
    }
});
// assuming Bubblelines library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Bubblelines', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.bubblelines',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property bins How many "bins" to separate a document into.
    		 * @type Integer
    		 * @private
    		 */
    		bins: 50,
        	/**
        	 * @property query A string to search for in a document.
        	 * @type String
    		 * @private
        	 */
    		query: null,
    		
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		/**
    		 * @property docId The document ID to restrict results to.
    		 * @type String
    		 * @private
    		 */
    		docId: undefined,
    		/**
    		 * @property docIndex The document index to restrict results to.
    		 * @type Integer
    		 * @private
    		 */
    		docIndex: undefined,
    		/**
    		 * @property maxDocs The maximum number of documents to show.
    		 * @type Integer
    		 * @private
    		 */
    		maxDocs: 50
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
		bubblelines: undefined,
		termStore: undefined,
		docTermStore: undefined,
		selectedDocs: undefined,
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'},{xtype: 'colorpaletteoption'}]
	},
	
	termTpl: new Ext.XTemplate(
		'<tpl for=".">',
			'<div class="term" style="color: rgb({color});float: left;padding: 3px;margin: 2px;">{term}</div>',
		'</tpl>'
	),
    
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		this.setDocTermStore(corpus.getDocumentTerms({
    			proxy: {
	    			extraParams: {
						withDistributions: 'raw',
						withPositions: true
					}
    			},
				listeners: {
	   		    	 load: function(store, records, successful, options) {
	   		    		records.forEach(function(record) {
	   		    			var termData = this.processTerms(record);
	   		    			var docId = record.get('docId');
	   		    			var term = record.get('term');
	   		    			var termObj = {};
	   		    			termObj[term] = termData;
	   		    			this.getBubblelines().addTermsToDoc(termObj, docId);
	   		    		}, this);
	   		    		this.getBubblelines().doBubblelinesLayout();
	   				},
	   				scope: this
	   		     }
    		}));
    		
    		if (this.isVisible() && this.getBubblelines()) {
    			this.initLoad();
    		}
    	}, this);
    	
        this.on('activate', function() { // load after tab activate (if we're in a tab panel)
        	if (this.getCorpus()) {
				Ext.Function.defer(this.initLoad, 100, this);
			}
    	}, this);
        
        this.on('query', function(src, query) {
    		if (query !== undefined && query != '') {
    			this.getDocTermsFromQuery(query);
    		}
    	}, this);
        
        this.on('documentsSelected', function(src, docIds) {
        	this.setApiParam('docId', docIds);
        	this.getBubblelines().cache.each(function(d) {
        		d.hidden = docIds.indexOf(d.id) === -1;
        	});
        	this.getBubblelines().drawGraph();
        }, this);
    	
    	this.on('termsClicked', function(src, terms) {
    		if (src !== this) {
	    		var queryTerms = [];
	    		terms.forEach(function(term) {
        			if (Ext.isString(term)) {queryTerms.push(term);}
        			else if (term.term) {queryTerms.push(term.term);}
        			else if (term.getTerm) {queryTerms.push(term.getTerm());}
        		});
	    		this.getDocTermsFromQuery(queryTerms);
    		}
		}, this);
    	
    	this.on('documentTermsClicked', function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.getDocTermsFromQuery(queryTerms);
    	}, this);
    	
    	this.down('#granularity').setValue(parseInt(this.getApiParam('bins')));
    },
    
    initComponent: function() {
    	this.setTermStore(Ext.create('Ext.data.ArrayStore', {
            fields: ['term', 'color'],
            listeners: {
            	load: function(store, records, successful, options) {
            		var termsView = this.down('#termsView');
            		for (var i = 0; i < records.length; i++) {
            			var r = records[i];
            			termsView.select(r, true);
            		}
            	},
            	scope: this
            }
        }));
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                },{
	            	text: this.localize('clearTerms'),
					glyph: 'xf014@FontAwesome',
	            	handler: function() {
	            		this.down('#termsView').getSelectionModel().deselectAll(true);
	            		this.getTermStore().removeAll();
	            		this.setApiParams({query: null});
	            		this.getBubblelines().removeAllTerms();
	            		this.getBubblelines().drawGraph();
	            	},
	            	scope: this                			
        		},{
	            	xtype: 'documentselectorbutton'
        		},{
	            	xtype: 'slider',
	            	itemId: 'granularity',
	            	fieldLabel: this.localize('granularity'),
	            	labelAlign: 'right',
	            	labelWidth: 70,
	            	width: 150,
	            	increment: 10,
	            	minValue: 10,
	            	maxValue: 300,
	            	listeners: {
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({bins: newvalue});
	            			this.getBubblelines().bubbleSpacing = newvalue;
	            			this.reloadTermsData();
	            		},
	            		scope: this
	            	}
	            },{
	            	xtype: 'checkbox',
	            	boxLabel: this.localize('separateLines'),
	            	boxLabelAlign: 'before',
	            	checked: false,
	            	handler: function(checkbox, checked) {
	            		this.getBubblelines().SEPARATE_LINES_FOR_TERMS = checked;
	            		this.getBubblelines().lastClickedBubbles = {};
	            		this.getBubblelines().setCanvasHeight();
	    				this.getBubblelines().drawGraph();
	            	},
	            	scope: this
	            	
	            }]
    		}],
            border: false,
            layout: 'fit',
            items: {
            	layout: {
            		type: 'vbox',
            		align: 'stretch'
            	},
            	defaults: {border: false},
	            items: [{
	            	height: 30,
	            	itemId: 'termsView',
	            	xtype: 'dataview',
	            	store: this.getTermStore(),
	            	tpl: this.termTpl,
	            	itemSelector: 'div.term',
	            	overItemCls: 'over',
	            	selectedItemCls: 'selected',
	            	selectionModel: {
	            		mode: 'SIMPLE'
	            	},
//	            	cls: 'selected', // default selected
	            	focusCls: '',
	            	listeners: {
	            		beforeitemclick: function(dv, record, item, index, event, opts) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			dv.fireEvent('itemcontextmenu', dv, record, item, index, event, opts);
	            			return false;
	            		},
	            		beforecontainerclick: function() {
	            			// cancel deselect all
	            			event.preventDefault();
	            			event.stopPropagation();
	            			return false;
	            		},
	            		selectionchange: function(selModel, selections) {
	            			var dv = this.down('#termsView');
	            			var terms = [];
	            			
	            			dv.getStore().each(function(r) {
	            				if (selections.indexOf(r) !== -1) {
	            					terms.push(r.get('term'));
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('unselected').addCls('selected');
	            				} else {
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('selected').addCls('unselected');
	            				}
	            			});
	            			
	            			for (var index in this.getBubblelines().lastClickedBubbles) {
	            				var lcTerms = this.getBubblelines().lastClickedBubbles[index];
	            				for (var term in lcTerms) {
	            					if (terms.indexOf(term) == -1) {
	            						delete this.getBubblelines().lastClickedBubbles[index][term];
	            					}
	            				}
	            				
	            			}
	            			this.getBubblelines().termsFilter = terms;
	            			this.getBubblelines().setCanvasHeight();
	            			this.getBubblelines().drawGraph();
	            		},
	            		itemcontextmenu: function(dv, record, el, index, event) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			var isSelected = dv.isSelected(el);
	            			var menu = new Ext.menu.Menu({
	            				floating: true,
	            				items: [{
	            					text: isSelected ? this.localize('hideTerm') : this.localize('showTerm'),
	            					handler: function() {
	            						if (isSelected) {
	            							dv.deselect(index);
	            						} else {
	            							dv.select(index, true);
	            						}
	            					},
	            					scope: this
	            				},{
	            					text: this.localize('removeTerm'),
	            					handler: function() {
	            						dv.deselect(index);
	            						var term = this.getTermStore().getAt(index).get('term');
	            						this.getTermStore().removeAt(index);
	            						dv.refresh();
	            						
	            						this.getBubblelines().removeTerm(term);
	            						this.getBubblelines().setCanvasHeight();
	            						this.getBubblelines().drawGraph();
	            					},
	            					scope: this
	            				}]
	            			});
	            			menu.showAt(event.getXY());
	            		},
	            		scope: this
	            	}
	            },{
	            	flex: 1,
	            	xtype: 'container',
	            	autoEl: 'div',
	            	itemId: 'canvasParent',
	            	layout: 'fit',
	            	overflowY: 'auto',
	            	overflowX: 'hidden'
	            }],
	            listeners: {
	            	render: function(component) {
	            		var canvasParent = this.down('#canvasParent');
	                	this.setBubblelines(new Bubblelines({
	                		container: canvasParent,
	                		clickHandler: this.bubbleClickHandler.bind(this)
	                	}));
	                	this.getBubblelines().bubbleSpacing = parseInt(this.getApiParam('bins'));
	            	},
            		afterlayout: function(container) {
            			if (this.getBubblelines().initialized === false) {
            				this.getBubblelines().initializeCanvas();
            			}
            		},
	        		resize: function(cnt, width, height) {
	        			this.getBubblelines().doBubblelinesLayout();
	        		},
            		scope: this
            	}
            }
		});
    	
    	this.callParent(arguments);
    },
    
    initLoad: function() {
    	// get doc info
    	var docIds = [];
		this.getCorpus().getDocuments().each(function(doc, index, total) {
			var inLimit = index < this.getApiParam('maxDocs');
			this.getBubblelines().addDocToCache({
				id: doc.getId(),
				index: doc.getIndex(),
				title: doc.getShortTitle(),
				totalTokens: doc.get('tokensCount-lexical'),
				terms: {},
				hidden: !inLimit
			});
			if (inLimit) {
				docIds.push(doc.getId());
			}
		}, this);
		this.setApiParam('docId', docIds);
		
		// get top terms in corpus
		this.getCorpus().getCorpusTerms({autoload: false}).load({
			callback: function(records, operation, success) {
		    	var query = [];
		    	records.forEach(function(record, index) {
					query.push(record.get('term'));
				}, this);
		    	this.getDocTermsFromQuery(query);
		    },
		    scope: this,
		    params: {
		    	limit: this.getApiParam('query') ? undefined : 5,
		    	stopList: this.getApiParams('stopList'),
		    	query: this.getApiParam('query')
		    }
		});
    },
    
    /**
     * Get the results for the query(s) for each of the corpus documents.
     * @param query {String|Array}
     */
    getDocTermsFromQuery: function(query) {
    	if (query) {this.setApiParam('query', query);} // make sure it's set for subsequent calls
    	if (this.getCorpus() && this.isVisible()) {
			this.getDocTermStore().load({params: this.getApiParams()});
    	}
	},
    
	reloadTermsData: function() {
		var terms = [];
		for (var term in this.getBubblelines().currentTerms) {
			terms.push(term);
		}
		this.getDocTermsFromQuery(terms);
	},
	
    filterDocuments: function() {
		var docIds = this.getApiParam('docId');
		if (docIds == '') {
			docIds = [];
			this.getCorpus().getDocuments().each(function(item, index) {
				docIds.push(item.getId());
			});
			this.setApiParams({docId: docIds});
		}
		if (typeof docIds == 'string') docIds = [docIds];
		
		if (docIds == null) {
			this.setSelectedDocs(this.getCorpus().getDocuments().clone());
			var count = this.getSelectedDocs().getCount();
			if (count > 10) {
				for (var i = 10; i < count; i++) {
					this.getSelectedDocs().removeAt(10);
				}
			}
			docIds = [];
			this.getSelectedDocs().eachKey(function(docId, doc) {
				docIds.push(docId);
			}, this);
			this.setApiParams({docId: docIds});
		} else {
			this.setSelectedDocs(this.getCorpus().getDocuments().filterBy(function(doc, docId) {
				return docIds.indexOf(docId) != -1;
			}, this));
		}
	},
	
	processTerms: function(termRecord) {
		var termObj;
		var term = termRecord.get('term');
		var rawFreq = termRecord.get('rawFreq');
		var positions = termRecord.get('positions');
		if (rawFreq > 0) {
			var color = this.getApplication().getColorForTerm(term);
			if (this.getTermStore().find('term', term) === -1) {
				this.getTermStore().loadData([[term, color]], true);
				var index = this.getTermStore().find('term', term);
				this.down('#termsView').select(index, true); // manually select since the store's load listener isn't triggered
			}
			var distributions = termRecord.get('distributions');
			termObj = {positions: positions, distributions: distributions, rawFreq: rawFreq, color: color};
		} else {
			termObj = false;
		}
		
		return termObj;
	},
	
	bubbleClickHandler: function(data) {
		this.getApplication().dispatchEvent('termsClicked', this, data);
	}
});
Ext.define('Voyant.panel.Catalogue', {
	extend: 'Ext.panel.Panel',
	requires: ['Voyant.widget.Facet'],
	mixins: ['Voyant.panel.Panel','Voyant.util.Downloadable'],
	
	alias: 'widget.catalogue',
    statics: {
    	i18n: {
    	},
    	api: {
    		config: undefined,
    		stopList: 'auto',
    		facet: ['facet.title','facet.author','facet.language'],
    		title: undefined,
    		splash: undefined,
    		reader: "reader"
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	facets: {},
    	matchingDocIds: [],
    	customResultsHtml: undefined
    },
    
    constructor: function(config) {
    	config = config || {};
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
		Ext.apply(this, {
			title: this.localize('title'),
			layout: {
				type: 'hbox',
				align: 'stretch'
			},
			items: [{
				layout: {
					type: 'vbox',
					align: 'stretch'
				},
				itemId: 'facets',
				minWidth: 175,
				width: 250,
				defaults: {
					width: 250,
					minHeight: 150,
					flex: 1,
					xtype: 'facet',
					animCollapse: false,
					collapseFirst: false,
					includeTools: {
						close: {
							type: 'close',
							tooltip: this.localize('closeFacetTip'),
							callback: function(facetCmp) {
								delete this.facets[facetCmp.facet]; // remove from facets map
								facetCmp.destroy(); // remove this facet
								this.updateResults();
								this.adjustFacetHeights();
							},
							scope: this
						},
						add: {
							type: 'plus',
							tooltip: this.localize('plusFacetTip'),
							callback: function() {
								this.addFacet();
							},
							scope: this
						}
					}
				},
				items: []
			},{xtype: 'splitter'},{
				html: config.customResultsHtml || '',
				itemId: 'results',
				flex: 1,
				minWidth: 250,
				scrollable: true,
				margin: 5,
				getCorpus: function() { // for query search field
					return this.findParentByType('panel').getCorpus();
				},
				listeners: {
					query: function(src, query) {
						this.findParentByType('panel').updateResults(Ext.isString(query) ? [query] : query)
					}
				},
				dockedItems: [{
					dock: 'bottom',
					xtype: 'toolbar',
					overflowHandler: 'scroller',
					items: [{
						itemId: 'sendToVoyant',
						text: this.localize('sendToVoyantButton'),
						disabled: true,
						handler: function() {
							this.mask(this.localize("exportInProgress"));
							var catalogue = this;
							Ext.Ajax.request({
								url: this.getApplication().getTromboneUrl(),
								params: {
									corpus: this.getCorpus().getId(),
									tool: 'corpus.CorpusManager',
									keepDocuments: true,
									docId: this.getMatchingDocIds()
								},
								success: function(response, opts) {
									catalogue.unmask();
									var json = Ext.JSON.decode(response.responseText);
									var url = catalogue.getBaseUrl()+"?corpus="+json.corpus.id;
									catalogue.openUrl(url);
								},
								failure: function(response, opts) {
									catalogue.unmask();
									catalogue.showResponseError("Unable to export corpus: "+catalogue.getCorpus().getId(), response);
								}
							})

						},
						scope: this
					},{
						itemId: 'export',
						text: this.localize('downloadButton'),
						disabled: true,
						handler: function() {
							this.mask(this.localize("exportInProgress"));
							var catalogue = this;
							Ext.Ajax.request({
								url: this.getApplication().getTromboneUrl(),
								params: {
									corpus: this.getCorpus().getId(),
									tool: 'corpus.CorpusManager',
									keepDocuments: true,
									docId: this.getMatchingDocIds()
								},
								success: function(response, opts) {
									catalogue.unmask();
									var json = Ext.JSON.decode(response.responseText);
									catalogue.downloadFromCorpusId(json.corpus.id);
								},
								failure: function(response, opts) {
									catalogue.unmask();
									catalogue.showResponseError("Unable to export corpus: "+catalogue.getCorpus().getId(), response);
								}
							})

						},
						scope: this
					},{
						xtype: 'querysearchfield',
						width: 200,
						flex: 1
					},{
						itemId: 'status',
						xtype: 'tbtext'
					}]
				}]
			},{xtype: 'splitter'},{
				xtype: this.getApiParam("reader"),
				flex: 1,
				minWidth: 250,
				header: false
			}]
		});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		this.queryById('status').update(new Ext.XTemplate(this.localize('noMatches')).apply([corpus.getDocumentsCount()]))
    		if (!this.getCustomResultsHtml()) {
    			if (this.getApiParam("splash")) {
        			this.setCustomResultsHtml(this.getApiParam("splash"));
        			this.updateResults();
        			return;
    			}
    			this.setCustomResultsHtml(new Ext.XTemplate(this.localize('noMatches')).apply([corpus.getDocumentsCount()]));
    			this.updateResults();
    	    	Ext.Ajax.request({
    	    	    url: this.getTromboneUrl(),
    	    	    params: {
    	        		tool: 'resource.StoredResource',
    	        		verifyResourceId: 'customhtml-'+corpus.getAliasOrId()
    	    	    },
    	    	    success: function(response, req) {
    	    	    	var json = Ext.util.JSON.decode(response.responseText);
    	    	    	if (json && json.storedResource && json.storedResource.id) {
    	        	    	Ext.Ajax.request({
    	        	    	    url: this.getTromboneUrl(),
    	        	    	    params: {
    	        	        		tool: 'resource.StoredResource',
    	        	        		retrieveResourceId: 'customhtml-'+corpus.getAliasOrId()
    	        	    	    },
    	        	    	    success: function(response, req) {
    	        	    	    	var json = Ext.util.JSON.decode(response.responseText);
    	        	    	    	if (json && json.storedResource && json.storedResource.resource) {
    	        	    	    		this.setCustomResultsHtml(json.storedResource.resource);
    	        	    	    		this.updateResults()
    	        	    	    	}
    	        	    	    },
    	        	    	    scope: this
    	        	    	})
    	    	    	}
    	    	    },
    	    	    scope: this
    	    	})

    		}
    	});
    	
    	this.on('afterrender', function(panel) {
    		var facetsCmp = this.queryById('facets');
			this.addFacet({
				facet: 'lexical',
    			includeTools: {add: {
        			type: 'plus',
            		tooltip: this.localize('plusFacetTip'),
            		callback: function() {
            			this.addFacet();
            		},
            		scope: this
        		}},
				store: new Voyant.data.store.CorpusTerms({
					parentPanel: this,
    				proxy: {
    					extraParams: {
    	    				stopList: this.getApiParam("stopList")
    					}
    				}
				})
			}, facetsCmp)
    		
    		var facets = this.getApiParam('facet');
    		if (Ext.isString(facets)) {facets = facets.split(",")}
    		facets.forEach(function(facet) {
    			this.addFacet({facet: facet}, facetsCmp);
    		}, this);
    		
        	var title = this.getApiParam("title");
        	if (title) {this.setTitle(title)}
    	});
    },
    
    addFacet: function(config, facetsCmp) {
    	if (!config) {
    		// select first, then add
    		return this.selectFacet(function(facet) {
    			this.addFacet({facet: facet})
    		})
    	}
		facetsCmp = facetsCmp || this.queryById('facets');
    	var facet = config.facet,
    		itemTpl = '<span style="font-size: smaller;">(<span class="info-tip" data-qtip="'+this.localize('matchingDocuments')+'">{inDocumentsCount}</span>)</span> {term}'+'<span style="font-size: smaller;"> (<span class="info-tip" data-qtip="'+this.localize('rawFreqs')+'">{rawFreq}</span>)</span>'

		var title = this.localize(facet+"Title");
		if (title=="["+facet+"Title]") {
			title = facet.replace(/^facet\./,"").replace(/^extra./,"");
		}
		
		Ext.applyIf(config, {
			title: title,
			collapsible: true,
			facet: facet,
			columns: [{
				renderer: function(value, metaData, record) {
					return '<span style="font-size: smaller;">(<span class="info-tip" data-qtip="'+this.localize('matchingDocuments')+'">'+record.getInDocumentsCount()+"</span>) </span>"+
						(record.getLabel ? record.getLabel() : record.getTerm()+'<span style="font-size: smaller;"> (<span class="info-tip" data-qtip="'+this.localize('rawFreqs')+'">'+record.getRawFreq()+"</span>)</span>")
				},
				flex: 1
			}],
			bbar: [{
				xtype: 'querysearchfield',
				width: '100%',
				tokenType: facet.replace("facet.", ""),
				itemTpl: itemTpl
			}],
			corpus: this.getCorpus()
		});
		
		var facetCmp = facetsCmp.add(config);

		facetCmp.getStore().on('load', function() {
			this.adjustFacetHeights();
		}, this);
		
		facetCmp.getSelectionModel().on('selectionchange', function(model, selected) {
			var labels = [];
			selected.forEach(function(model) {
				labels.push({facet: facetCmp.facet, label: model.getLabel ? model.getLabel() : model.getTerm()})
			})
			this.getFacets()[facet] = labels;
			this.updateResults();
		}, this);
		facetCmp.on('query', function(model, selected) {
			this.getFacets()[facetCmp.facet] = [];
			this.updateResults();
		}, this);

    	return facetCmp;
    },
    
	adjustFacetHeights: function() {
		var facetsCmp = this.queryById('facets');
		var counts = {};
		var maxCount = -1;
		var facets = facetsCmp.query('facet');
		facets.forEach(function(facet) {
			var count = facet.getStore().count();
			if (count > maxCount) {
				maxCount = count;
			}
			counts[facet.getId()] = count;
		});

		var mapVal = function(value, istart, istop, ostart, ostop) {
			return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
		};

		facets.forEach(function(facet) {
			var flexAmt = counts[facet.getId()] / maxCount;
			flexAmt = mapVal(flexAmt, 0, 1, 0.3, 1);
			facet.setFlex(flexAmt);
		}, this);
		facetsCmp.updateLayout();
	},

    updateResults: function(queries) {
    	var facets = this.getFacets();
    	if (!queries) {
	    	var queries = [];
	    	for (facet in facets) {
	    		facets[facet].forEach(function(label) {
	        		queries.push(label.facet+":"+label.label);
	    		})
	    	}
	    	if (queries) {
		    	return this.updateResults(queries)
	    	}
    	}
		var results = this.queryById("results").getTargetEl();
		var catalogue = this;
		results.update(this.getCustomResultsHtml() ? this.getCustomResultsHtml() : new Ext.XTemplate(this.localize('noMatches')).apply([this.getCorpus().getDocumentsCount()]));
		this.queryById('status').update(new Ext.XTemplate(this.localize('noMatches')).apply([this.getCorpus().getDocumentsCount()]))
		this.queryById('sendToVoyant').setDisabled(true);
		this.queryById('export').setDisabled(true);
    	if (queries && queries.length>0) {
    		this.mask(this.localize("loading"));
    		var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
    		documentQueryMatches.load({
    			params: {query: queries, includeDocIds: true},
    			callback: function(records, operation, success) {
    				this.unmask();
    				if (records && records.length>0) {
    					this.queryById('status').setHtml(records.length)
    					var list = "<ul>";
    					var matchingDocIds = [];
    					records.forEach(function(record) {
    						record.getDocIds().forEach(function(docId) {
    							matchingDocIds.push(docId);
    							var doc = documentQueryMatches.getCorpus().getDocument(docId);
    							var item = "<li id='"+results.getId()+'_'+docId+"' class='cataloguedoc'>";
    							item += "<a href='#' class='cataloguedoctitle' data='"+docId+"'>"+doc.getTitle()+"</a>";
    							for (facet in facets) {
    								if (facets[facet].length==0) {continue;}
    								var labelItems = "";
    								if (facet!='facet.title') {
    									var suffix = facet.replace(/^.+?\./,"");
    									var label = doc.get(suffix);
    									if (label) {
    										var isArray = Ext.isArray(label);
    										if (isArray) {
    											labelItems+="<li>"+suffix+"<ul>"
    										} else {
    											label = [label];
    										}
    										label.forEach(function(l) {
    											var isMatch = false;
    											facets[facet].forEach(function(f) {
    												if (f.label==l) {isMatch=true}
    												else if (f.facet.indexOf('facet')==-1) {
    													f.label.split(/\W+/).forEach(function(part) {
    														if (part.trim().length>0 && l.toLowerCase().indexOf(part.toLowerCase())>-1) {
    															isMatch=true;
    														}
    													})
    												}
    											})
    											labelItems+="<li>"+(isArray ? '' : suffix.replace('extra.','')+": ")+(isMatch ? '<span class="keyword">'+l+'</span>' : l)+"</li>"
    										})
    										if (isArray) {
    											labelItems+="</ul></li>";
    										}
    									}
    								}
    								if (labelItems) {
    									item+="<ul>"+labelItems+"</ul>";
    								}
    							}
    							item += "</li>";
    							list += item;
    						})
    					})
    					list += "</ul>";
    					results.update(list);
    					var me = this;
    					var lnks = results.query(".cataloguedoctitle");
    					lnks.forEach(function(lnk) {
    						Ext.get(lnk).on("click", function(e,el) {
    							this.dispatchEvent("documentSelected", me, el.getAttribute("data"));
    						}, me)
    					});
    					if (lnks.length==1) {
    						this.dispatchEvent("documentSelected", me, lnks[0].getAttribute("data"));
    					}
    					this.queryById('status').update(new Ext.XTemplate(this.localize('queryMatches')).apply([matchingDocIds.length,this.getCorpus().getDocumentsCount()]))
    					this.setMatchingDocIds(Ext.Array.clone(matchingDocIds));
    					if (matchingDocIds.length>0) {
    						this.queryById('export').setDisabled(false);
    						this.queryById('sendToVoyant').setDisabled(false);
    					}
    					
    					// now try to load some snippets, if need be
    					if (facets['lexical']) {
    						var firstDocIds = matchingDocIds.splice(0,5);
    						this.loadSnippets(firstDocIds, results.first().first());
    						if (matchingDocIds && matchingDocIds.length>0) {
        						this.loadSnippets(matchingDocIds); // load the rest
    						}
    					}
    				}
    			},
    			scope: this
    		})    		
    	}
    },
    
    loadSnippets: function(docIds, elToMask) {
		var results = this.queryById("results").getTargetEl();
    	var facets = this.getFacets();
    	if (facets['lexical']) {
    		var queries = facets['lexical'].map(function(label) {return label.facet+":"+label.label});
    		var contexts = this.getCorpus().getContexts({buffered: false});
    		if (elToMask) {
    			elToMask.mask(this.localize("loadingSnippets"));
    		}
    		contexts.load({
    			method: 'POST',
    			params: {
                	stripTags: "all",
    				query: queries,
    				docId: docIds,
    				perDocLimit: 3,
    				limit: 100,
    				accurateTotalNotNeeded: true
    			},
    			scope: this,
    			callback: function(records, operation, success) {
    				if (elToMask) {
    					elToMask.unmask();
    				}
    				if (success && Ext.isArray(records) && records.length>0) {
    					var snippets = {};
    					records.forEach(function(record) {
    						if (!snippets[record.getDocIndex()]) {snippets[record.getDocIndex()]=[]}
    						snippets[record.getDocIndex()].push(record);
    					})
    					for (docIndex in snippets) {
    						var id = this.getCorpus().getDocument(docIndex).getId();
    						var html = '<li style="list-style-type: none; font-size: smaller;">'+snippets[docIndex].map(function(snippet) {
    							return snippet.getHighlightedContext();
    						}).join(" … ")+'</li>'
    						var docItem = results.down("#"+results.getId()+"_"+id);
							if (docItem) {
								if (docItem.query("ul")) {
									html="<ul>"+html+"</ul>";
								}
								docItem.insertHtml('beforeEnd', html)
							} else {
								console.log('Catalogue: no docItem', results);
							}
    					}
    				}
    			}
        	})        		
    	}
	
    },
    
    selectFacet: function(callback) {
    	if (!this.facetsSelectionStore) {
    		var keys = {};
    		this.getCorpus().getDocuments().each(function(doc) {
    			for (var key in doc.getData()) {
    				if (key !== "corpus" && key.indexOf("parent") !== 0 && key.indexOf("-lexical") === -1) {
        				keys[key] = true
    				}
    			}
    		});
    		keys = Object.keys(keys);
			var priority = ['title', 'location', 'publisher', 'pubDate', 'pubPlace', 'language', 'keyword', 'author', 'collection'];
    		keys.sort(function(a, b) {
				return priority.indexOf(b) - priority.indexOf(a);
			});
    		this.facetsSelectionStore = Ext.create('Ext.data.ArrayStore', {
    		    fields: ['text'],
    		    data: keys.map(function(key) {return [key]})
    		});
    	}
    	
    	var existingFacets = {};
    	this.queryById('facets').items.each(function(cmp) {
    		existingFacets[cmp.facet]=true;
    	});

		if (this.facetsSelectionStore.isFiltered) this.facetsSelectionStore.clearFilter();
    	this.facetsSelectionStore.filterBy(function(record) {
    		return !("facet."+record.get('text') in existingFacets);
    	});
    	
		Ext.create('Ext.window.Window', {
			title: this.localize("selectFacet"),
			modal: true,
			items: {
				xtype: 'form',
				width: 300,
				items: {
					xtype: 'combo',
					store: this.facetsSelectionStore,
					forceSelection: true,
					width: 300
				},
				buttons: [{
	            	text: this.localize("cancel"),
		            ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize("select"),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var facet = btn.up('window').down('combo').getValue();
	        			if (!facet) {
	        				return this.showError(this.localize('selectValidFacet'));
	        			} else {
	        				callback.call(this, "facet."+facet);
		        			btn.up('window').close();
	        			}
	        		},
	        		scope: this
	            }]
			},
			bodyPadding: 5
		}).show()
    }
    
});

// assuming Cirrus library is loaded by containing page (via voyant.jsp)
/**
 * Cirrus tool, a wordcloud-like visuaization.
 * 
 * 	// simple cirrus
 * 	loadCorpus("austen").tool("cirrus");
 *
 * 	// define stopwords list and styling
 * 	loadCorpus("austen").tool("cirrus", {
 * 		stopList: 'auto',
 * 		style: 'width: 500px; height: 400px'
 * 	});
 */
Ext.define('Voyant.panel.Cirrus', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.cirrus',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
    		 * @default auto
    		 * 
    		 * By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
    		 *  
    		 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
    		 */
    		stopList: 'auto',
    		categories: undefined,
    		whiteList: undefined, // specify a list of words to use
    		
    		/**
    		 * @cfg {Number} limit Specify the number of terms to load (which is separate from the number of {@link #visible} terms to show) at a time).
    		 * @default 500
    		 */
    		limit: 500,
    		
    		/**
    		 * @cfg {Number} visible Specify the number of terms that are visible at a time.
    		 * @default 50
    		 */
    		visible: 50,
    		terms: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		
    		inlineData: undefined, // format should match CorpusTerm model, only term and rawFreq required

    		fontFamily: '"Palatino Linotype", "Book Antiqua", Palatino, serif',
    		cirrusForceFlash: false,
    		background: '0xffffff',
    		fade: true,
    		smoothness: 2,
    		diagonals: 'none' // all, bigrams, none
    	},
		glyph: 'xf06e@FontAwesome'
    },
    
    config: {
    	/**
    	 * @private
    	 */
    	mode: undefined,
    	/**
    	 * @private
    	 */
    	options: [
    		{xtype: 'stoplistoption'},
    		{
	    		xtype: 'listeditor',
	    		name: 'whiteList'
    	    },
    	    {xtype: 'categoriesoption'},
//    	    {
//    	    	// TODO this field does nothing
//    	        xtype: 'numberfield',
//    	        name: 'label',
//    	        fieldLabel: 'Max words',
//    	        labelAlign: 'right',
//    	        value: 500,
//    	        minValue: 50,
//    	        step: 50,
//    	        listeners: {
//        	        afterrender: function(field) {
//        	        	var win = field.up("window");
//        	        	if (win && win.panel) {field.setFieldLabel(win.panel.localize("maxTerms"))}
//        	        }
//    	        }
//    	    },
    	    {xtype: 'fontfamilyoption'},
    	    {xtype: 'colorpaletteoption'}

    	],
    	/**
    	 * @private
    	 */
    	records: undefined,
    	/**
    	 * @private
    	 */
    	terms: undefined,
    	/**
    	 * @private
    	 */
    	cirrusId: undefined,
    	/**
    	 * @private
    	 */
    	visLayout: undefined, // cloud layout algorithm
    	/**
    	 * @private
    	 */
    	vis: undefined, // actual vis
    	/**
    	 * @private
    	 */
    	tip: undefined,
    	/**
    	 * @private
    	 */
    	sizeAdjustment: 100, // amount to multiply a word's relative size by
    	/**
    	 * @private
    	 */
    	minFontSize: 12,
    	/**
    	 * @private
    	 */
    	largestWordSize: 0,
    	/**
    	 * @private
    	 */
    	smallestWordSize: 1000000
    },
    
    MODE_CORPUS: 'corpus',
    MODE_DOCUMENT: 'mode_document',
    
    layout: 'fit',
    
	/**
	 * @private
	 */
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.getApplication().getCategoriesManager().addFeature('orientation', function() { return ~~(Math.random() * 2) * 90; });
    	
    	this.setCirrusId(Ext.id(null, 'cirrus_'));
    },
    
    initComponent: function (config) {
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			xtype: 'corpusdocumentselector',
        			singleSelect: true
        		},{
        			fieldLabel: this.localize('visibleTerms'),
        			labelWidth: 40,
        			width: 120,
        			xtype: 'slider',
	            	increment: 25,
	            	minValue: 25,
	            	maxValue: 500,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.maxValue = this.getApiParam("limit")
	            			slider.increment = parseInt(slider.maxValue/50)
	            			slider.setValue(this.getApiParam("visible"))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({visible: newvalue});
	            			this.loadFromTermsRecords();
	            		},
	            		scope: this
	            	}
                }]
    		}]
    	});

    	this.callParent(arguments);
    	
    	
    },
    
    listeners: {
    	boxready: function() {
			this.initVisLayout(); // force in case we've changed fontFamily from options

			var dataString = this.getApiParam('inlineData');
        	if (dataString !== undefined) {
        		if (dataString.charAt(0)=="[") {
            		var jsonData = Ext.decode(dataString, true);
        		} else {
        			if (dataString.indexOf(":")>-1) {
        				jsonData = [];
        				dataString.split(",").forEach(function(term) {
        					parts = term.split(":");
        					jsonData.push({
        						text: parts[0],
        						rawFreq: parseInt(parts[1])
        					})
        				})
        			} else {
        				var terms = {}
        				jsonData = [];
        				dataString.split(",").forEach(function(term) {
        					if (term in terms) {
        						terms[term]++;
        					} else {
        						terms[term] = 1;
        					}
        				});
        				for (term in terms) {
        					jsonData.push({
        						text: term,
        						rawFreq: terms[term]
        					})
        				}
        			}
        		}
        		if (jsonData !== null && jsonData.length>0) {
        			this.setApiParam('inlineData', jsonData);
	        	    this.setTerms(jsonData);
	        	    this.buildFromTerms();
        		}
        	}
    	},
    	resize: function(panel, width, height) {
    		if (this.getVisLayout() && this.getCorpus()) {
    			this.setAdjustedSizes();
    			
    			var el = this.getLayout().getRenderTarget();
    	    	width = el.getWidth();
    			height = el.getHeight();
    			
    			el.down('svg').set({width: width, height: height});
    			if (this.getTerms()) {
        			this.getVisLayout().size([width, height]).stop().words(this.getTerms()).start();
    			}
    		}
    	},
    	
    	loadedCorpus: function(src, corpus) {
			this.getApplication().getCategoriesManager().addFeature('font', this.getApiParam('fontFamily')); // make sure the default for font is set from the api
    		this.initVisLayout(); // force in case we've changed fontFamily from options
    		if (this.getApiParam("docIndex")) {
    			this.fireEvent("documentSelected", this, corpus.getDocument(this.getApiParam("docIndex")));
    		} else if (this.getApiParam("docId")) {
    			this.fireEvent("documentSelected", this, corpus.getDocument(this.getApiParam("docId")));
    		} else {
        		this.loadFromCorpus(corpus);
			}
    	},
    	
    	corpusSelected: function(src, corpus) {
    		this.loadFromCorpus(corpus);
    		
    	},
    	
    	documentSelected: function(src, document) {
    		if (document) {
        		var corpus = this.getCorpus();
        		var document = corpus.getDocument(document);
        		this.setApiParam('docId', document.getId());
        		var documentTerms = document.getDocumentTerms({autoload: false, corpus: corpus, pageSize: this.getApiParam("maxVisible"), parentPanel: this});
        		this.loadFromDocumentTerms(documentTerms);
    		}
    	},
    	
    	ensureCorpusView: function(src, corpus) {
    		if (this.getMode() != this.MODE_CORPUS) {this.loadFromCorpus(corpus);}
    	}
    },
    
    loadFromCorpus: function(corpus) {
    	var jsonData = this.getApiParam('inlineData');
    	if (jsonData === undefined) {
			this.setApiParams({docId: undefined, docIndex: undefined});
			this.loadFromCorpusTerms(corpus.getCorpusTerms({autoload: false, pageSize: this.getApiParam("maxVisible"), parentPanel: this}));
    	} else {
    		// if (jsonData !== undefined) {
    		// 	var records = [];
    		// 	for (var i = 0; i < jsonData.length; i++) {
			// 		var wordData = jsonData[i];
			// 		wordData.term = wordData.text; // inlineData/CorpusTerm format mismatch
    		// 		var record = Ext.create('Voyant.data.model.CorpusTerm', wordData);
    		// 		records.push(record);
    		// 	}
    		// 	this.setRecords(records);
    		// 	this.setMode(this.MODE_CORPUS);
    		// 	this.loadFromTermsRecords();
    		// }
    	}
    },
    
    loadFromDocumentTerms: function(documentTerms) {
    	documentTerms.load({
		    callback: function(records, operation, success) {
		    	this.setMode(this.MODE_DOCUMENT);
		    	this.setRecords(operation.getRecords()); // not sure why operation.records is different from records
		    	this.loadFromTermsRecords();
		    },
		    scope: this,
		    params: this.getApiParams()
    	});
    },
    
    loadFromCorpusTerms: function(corpusTerms) {
		corpusTerms.load({
		    callback: function(records, operation, success) {
		    	this.setMode(this.MODE_CORPUS);
		    	this.setRecords(operation.getRecords()); // not sure why operation.records is different from records
				this.loadFromTermsRecords();
		    },
		    scope: this,
		    params: this.getApiParams()
    	});
    },
    
    loadFromTermsRecords: function() {
    	var records = this.getRecords();
    	var visible = this.getApiParam("visible");
    	if (visible>records.length) {visible=records.length;}
    	var terms = [];
    	for (var i=0; i<visible; i++) {
    		if (records[i].get('rawFreq')>0) {
        		terms.push({text: records[i].get('term').replace(/"/g,''), rawFreq: records[i].get('rawFreq')});
    		}
    	}
    	this.setTerms(terms);
    	this.buildFromTerms();
    },
    
    initVisLayout: function(forceLayout) {
    	if (forceLayout || this.getVisLayout() == undefined) {
    		var cirrusForceFlash = this.getApiParam('cirrusForceFlash');
    		if (cirrusForceFlash == 'true' || cirrusForceFlash === true) {
    			this.setApiParam('cirrusForceFlash', true);
    			var id = this.getCirrusId();
    			var appVars = {
    				id: id
    			};
    			var keys = ['background','fade','smoothness','diagonals'];
    			for (var i = 0; i < keys.length; i++) {
    				appVars[keys[i]] = this.getApiParam(keys[i]);
    			}
    			
    			var swfscript = '<script type="text/javascript" src="'+this.getApplication().getBaseUrl()+'resources/swfobject/swfobject.js'+'"></script>';
    			var cirrusLinks = '<script type="text/javascript">'+
				'cirrusClickHandler'+id+' = function(word, value) {\n'+
				'\tif (window.console && console.info) console.info(word, value);\n'+
				'\tvar cirrusTool = Ext.getCmp("'+this.id+'");\n'+
				'\tcirrusTool.dispatchEvent("termsClicked", cirrusTool, [word]);\n'+
				'}\n'+
				'cirrusLoaded'+id+' = function() {\n'+
				'\tif (window.console && console.info) console.info("cirrus flash loaded");\n'+
				'}\n'+
				'cirrusPNGHandler'+id+' = function(base64String) {\n'+
				'\tvar cirrusTool = Ext.getCmp("'+this.id+'");\n'+
				'\tcirrusTool.cirrusPNGHandler(base64String);\n'+
				'}'+
				'</script>';
    			
    			this.update(swfscript+cirrusLinks, true, function() {
    				function loadFlash(component) {
    					if (typeof swfobject !== 'undefined') {
    						var el = component.getLayout().getRenderTarget();
    						var width = el.getWidth();
    						var height = el.getHeight();
    		    			
	        				var cirrusFlash = component.getApplication().getBaseUrl()+'resources/cirrus/flash/Cirrus.swf';
	        				component.add({
	        					xtype: 'flash',
	        					id: appVars.id,
	        					url: cirrusFlash,
	        					width: width,
	        					height: height,
	        					flashVars: appVars,
	        					flashParams: {
									menu: 'false',
									scale: 'showall',
									allowScriptAccess: 'always',
									bgcolor: '#222222',
									wmode: 'opaque'
	        		            }
	        				});
	        				
	        				component.cirrusFlashApp = Ext.get(appVars.id).first().dom;
    					} else {
    						setTimeout(loadFlash, 50, component);
    					}
        			}
    				loadFlash(this);
    				
    			}, this);
    		} else {
    			var el = this.getLayout().getRenderTarget();
    			el.update(""); // make sure to clear existing contents (especially for re-layout)
    	    	var width = el.getWidth();
				var height = el.getHeight();
				this.setVisLayout(
					d3.layoutCloud()
						.size([width, height])
						.overflow(true)
						.padding(1)
						.rotate(function(d) {
							var orientation = this.getApplication().getCategoriesManager().getFeatureForTerm('orientation', d.text);
							if (orientation === undefined) {
								orientation = ~~(Math.random() * 2) * 90;
							}
							return orientation;
						}.bind(this))
						.spiral('archimedean')
						.font(function(d) { return this.getApplication().getCategoriesManager().getFeatureForTerm('font', d.text); }.bind(this))
						.fontSize(function(d) {return d.fontSize; }.bind(this))
						.text(function(d) { return d.text; })
						.on('end', this.draw.bind(this))
				);
				
				var svg = d3.select(el.dom).append('svg').attr('id',this.getCirrusId()).attr('class', 'cirrusGraph').attr('width', width).attr('height', height);
				this.setVis(svg.append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')'));
				
				if (this.getTip() === undefined) {
					this.setTip(Ext.create('Ext.tip.Tip', {}));
				}
    		}
    	}
    },
    
    buildFromTerms: function() {
		var terms = this.getTerms();
    	if (this.rendered && terms) {
    		if (this.getApiParam('cirrusForceFlash') === true) {
    			if (this.cirrusFlashApp !== undefined && this.cirrusFlashApp.clearAll !== undefined) {
	    			var words = [];
	    			for (var i = 0; i < terms.length; i++) {
	    				var t = terms[i];
	    				if (!t.text && t.term) {t.text=t.term;}
	    				words.push({word: t.text, size: t.rawFreq, label: t.rawFreq});
	    			}
	    			this.cirrusFlashApp.clearAll();
	    			this.cirrusFlashApp.addWords(words);
	    			this.cirrusFlashApp.arrangeWords();
    			} else {
    				Ext.defer(this.buildFromTerms, 50, this);
    			}
    		} else {
	    		var minSize = 1000;
	    		var maxSize = -1;
	    		for (var i = 0; i < terms.length; i++) {
	    			var size = terms[i].rawFreq;
	    			if (size < minSize) minSize = size;
	    			if (size > maxSize) maxSize = size;
	    		}
	    		this.setSmallestWordSize(minSize);
	    		this.setLargestWordSize(maxSize);
	    		
	    		// set the relative sizes for each word (0.0 to 1.0), then adjust based on available area
	    		this.setRelativeSizes();
	    		this.setAdjustedSizes();

	//    		var fontSizer = d3.scalePow().range([10, 100]).domain([minSize, maxSize]);

	    		this.getVisLayout().words(terms).start();
    		}
    	} else {
    		Ext.defer(this.buildFromTerms, 50, this);
    	}
    },
    
    draw: function(words, bounds) {
    	var panel = this;
    	var el = this.getLayout().getRenderTarget();
    	var width = this.getVisLayout().size()[0];
    	var height = this.getVisLayout().size()[1];
    	
    	var scale = bounds ? Math.min(
			width / Math.abs(bounds[1].x - width / 2),
			width / Math.abs(bounds[0].x - width / 2),
			height / Math.abs(bounds[1].y - height / 2),
			height / Math.abs(bounds[0].y - height / 2)
    	) / 2 : 1;
    	
		var t = d3.transition().duration(1000);
			
		var nodes = this.getVis().selectAll('text').data(words, function(d) {return d.text;});
		
		nodes.exit().transition(t)
			.style('font-size', '1px')
			.remove();

		var nodesEnter = nodes.enter().append('text')
			.text(function(d) { return d.text; })
			.attr('text-anchor', 'middle')
			.attr('data-freq', function(d) { return d.rawFreq; })
			.attr('transform', function(d) { return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')'; })
			.style('font-family', function(d) { return panel.getApplication().getCategoriesManager().getFeatureForTerm('font', d.text); })
			.style('fill', function(d) { return panel.getApplication().getColorForTerm(d.text, true); })
			.style('font-size', '1px')
			.on('click', function(obj) {panel.dispatchEvent('termsClicked', panel, [obj.text]);})
			.on('mouseover', function(obj) {
				this.getTip().show();
			}.bind(this))
			.on('mousemove', function(obj) {
				var tip = this.getTip();
				tip.update(obj.text+': '+obj.rawFreq);
				var container = Ext.get(this.getCirrusId()).dom;
				var coords = d3.mouse(container);
				coords[1] += 30;
				tip.setPosition(coords);
			}.bind(this))
			.on('mouseout', function(obj) {
				this.getTip().hide();
			}.bind(this));
		
		var nodesUpdate = nodes.merge(nodesEnter);
		
		nodesUpdate.transition(t)
			.style('font-family', function(d) { return panel.getApplication().getCategoriesManager().getFeatureForTerm('font', d.text); })
			.style('fill', function(d) { return panel.getApplication().getColorForTerm(d.text, true); })
			.attr('transform', function(d) { return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')'; })
			.style('font-size', function(d) { return d.fontSize + 'px'; });
		
		this.getVis().transition(t).attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')scale(' + scale + ')');
    },
    
    map: function(value, istart, istop, ostart, ostop) {
		return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));
	},
	
	calculateSizeAdjustment: function() {
		var terms = this.getTerms();
        if (terms !== undefined) {
			var el = this.getLayout().getRenderTarget();
			
	        var stageArea = el.getWidth() * el.getHeight();
	        if (stageArea < 100000) this.setMinFontSize(8);
	        else this.setMinFontSize(12);
        
	        var pixelsPerWord = stageArea / terms.length;
	        var totalWordsSize = 0;
	        for (var i = 0; i < terms.length; i++) {
	            var word = terms[i];
	            var wordArea = this.calculateWordArea(word);
	            totalWordsSize += wordArea;
	        }

	        this.setSizeAdjustment(stageArea / totalWordsSize);
        }
    },
    
    calculateWordArea: function(word) {
        var baseSize = Math.log(word.relativeSize * 10) * Math.LOG10E; // take the relativeSize (0.1 to 1.0), multiply by 10, then get the base-10 log of it
        var height = (baseSize + word.relativeSize) / 2; // find the average between relativeSize and the log
        var width = 0; //(baseSize / 1.5) * word.text.length;
        for (var i = 0; i < word.text.length; i++ ) {
            var letter = word.text.charAt(i);
            if (letter == 'f' || letter == 'i' || letter == 'j' || letter == 'l' || letter == 'r' || letter == 't') width += baseSize / 3;
            else if (letter == 'm' || letter == 'w') width += baseSize / (4 / 3);
            else width += baseSize / 1.9;
        }
        var wordArea = height * width;
        return wordArea;
    },
    
    setAdjustedSizes: function() {
    	this.calculateSizeAdjustment();
    	var terms = this.getTerms();
    	if (terms !== undefined) {
			for (var i = 0; i < terms.length; i++) {
				var term = terms[i];
				var adjustedSize = this.findNewRelativeSize(term);
				term.fontSize = adjustedSize > this.getMinFontSize() ? adjustedSize : this.getMinFontSize();
			}
    	}
    },
    
    setRelativeSizes: function() {
    	var terms = this.getTerms();
    	if (terms !== undefined) {
	    	for (var i = 0; i < terms.length; i++) {
	            var word = terms[i];
	            word.relativeSize = this.map(word.rawFreq, this.getSmallestWordSize(), this.getLargestWordSize(), 0.1, 1);
	        }
    	}
    },
    
    findNewRelativeSize: function(word) {
    	var areaMultiplier = this.getSizeAdjustment();
        var area = this.calculateWordArea(word) * areaMultiplier;
        // given the area = (x+6)*(2*x/3*y), solve for x
        var newRelativeSize = (Math.sqrt(6) * Math.sqrt(6 * Math.pow(word.text.length, 2) + area * word.text.length) - 6 * word.text.length) / (2 * word.text.length);
        return newRelativeSize;
    }
});
Ext.define('Voyant.panel.CollocatesGraph', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.collocatesgraph',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		mode: undefined,
    		limit: 5,
    		stopList: 'auto',
    		terms: undefined,
    		context: 5,
    		centralize: undefined
    	},
		glyph: 'xf1e0@FontAwesome'
    },
    
    config: {
    	options: [{xtype: 'stoplistoption'},{
    		xtype: 'categoriesoption'
    	}],
    	
    	nodeData: undefined,
    	linkData: undefined,
    	
    	visId: undefined,
    	vis: undefined,
    	visLayout: undefined,
    	nodes: undefined,
    	links: undefined,
    	zoom: undefined,
    	
    	dragging: false,
    	
    	contextMenu: undefined,
    	
    	currentNode: undefined,
    	
    	networkMode: undefined,
    	
    	graphStyle: {
    		keywordNode: {
    			normal: {
    				fill: '#c6dbef',
    				stroke: '#6baed6'
    			},
    			highlight: {
    				fill: '#9ecae1',
    				stroke: '#3182bd'
    			}
    		},
    		contextNode: {
    			normal: {
    				fill: '#fdd0a2',
    				stroke: '#fdae6b'
    			},
    			highlight: {
    				fill: '#fd9a53',
    				stroke: '#e6550d'
    			}
    		},
    		link: {
    			normal: {
    				stroke: '#000000',
    				strokeOpacity: 0.1
    			},
    			highlight: {
    				stroke: '#000000',
    				strokeOpacity: 0.5
    			}
    		}
    	},
    	
    	graphPhysics: {
    		defaultMode: {
	    		damping: 0.4, // 0 = no damping, 1 = full damping
	    		centralGravity: 0.1, // 0 = no grav, 1 = high grav
	    		nodeGravity: -50,  // negative = repel, positive = attract
				springLength: 100,
				springStrength: 0.25, // 0 = not strong, >1 = probably too strong
				collisionScale: 1.25 // 1 = default, 0 = no collision 
    		},
    		centralizedMode: {
    			damping: 0.4, // 0 = no damping, 1 = full damping
    			centralGravity: 0.1, // 0 = no grav, 1 = high grav
	    		nodeGravity: -1,  // negative = repel, positive = attract
				springLength: 200,
				springStrength: 1, // 0 = not strong, >1 = probably too strong
				collisionScale: 1 // 1 = default, 0 = no collision 
    		}
    	}
    },

    DEFAULT_MODE: 0,
    CENTRALIZED_MODE: 1,
    
    constructor: function(config) {
    	this.setNodeData([]);
    	this.setLinkData([]);
    	
    	this.setVisId(Ext.id(null, 'links_'));

    	this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;
        Ext.apply(me, {
    		title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                   xtype: 'querysearchfield'
                },{
                	text: me.localize('clearTerms'),
					glyph: 'xf014@FontAwesome',
                	handler: this.resetGraph,
                	scope: me
                },this.localize('context'),{
                	xtype: 'slider',
                	itemId: 'contextSlider',
                	minValue: 3,
                	value: 5,
                	maxValue: 30,
                	increment: 2,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getApiParam('context'));
                		},
                		changecomplete: function(slider, newValue) {
                			this.setApiParam('context', slider.getValue());
                			if (this.getNetworkMode() === this.DEFAULT_MODE) {
                    			var terms = this.getNodeData().map(function(node) { return node.term; });
                				if (terms.length > 0) {
                					this.setNodeData([]);
                					this.setLinkData([]);
                					this.refresh();
                					
                					this.loadFromQuery(terms);
                				}
                			}
                		},
                		scope: me
                	}
                }]
            }]
        });
        
        this.setContextMenu(Ext.create('Ext.menu.Menu', {
			renderTo: Ext.getBody(),
			items: [{
				xtype: 'box',
				itemId: 'label',
				margin: '5px 0px 5px 5px',
				html: ''
			},{
		        xtype: 'menuseparator'
			},{
				xtype: 'menucheckitem',
				text: 'Fixed',
				itemId: 'fixed',
				listeners: {
					checkchange: function(c, checked, e) {
						var node = this.getCurrentNode();
						if (node !== undefined) {
							var data = {
								fixed: checked
							};
							if (checked) {
								data.fx = node.x;
								data.fy = node.y;
							} else {
								data.fx = null;
								data.fy = null;
							}
							this.updateDataForNode(node.id, data);
						}
					},
					scope: this
				}
			},{
				xtype: 'button',
				text: 'Fetch Collocates',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
						if (this.getNetworkMode() === this.CENTRALIZED_MODE) {
							this.resetGraph();
							this.setNetworkMode(this.DEFAULT_MODE);
							this.setApiParam('centralize', undefined);
							node.start = 0;
							node.limit = this.getApiParam('limit');
						}
		    			this.fetchCollocatesForNode(node);
		    		}
				},
				scope: this
			},{
				xtype: 'button',
				text: 'Centralize',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
		    			this.doCentralize(node.term);
		    		}
					this.getContextMenu().hide();
				},
				scope: this
			},{
				xtype: 'button',
				text: 'Remove',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
						this.removeNode(node.id);
					}
					b.up('menu').hide();
				},
				scope: this
			}]
		}));
        
        this.on('loadedCorpus', function(src, corpus) {
			if (this.isVisible()) {
				this.initLoad();
			}
        }, this);
        
        this.on('activate', function() { // load after tab activate (if we're in a tab panel)
			if (this.getCorpus()) {
			    if (this.getNodeData().length === 0) { // only initLoad if there isn't already data
			        Ext.Function.defer(this.initLoad, 100, this);
			    }
			}
    	}, this);
        
        this.on('query', function(src, query) {this.loadFromQuery(query);}, this);
        
        this.on('resize', function(panel, width, height) {
        	var vis = Ext.get(this.getVisId());
        	if (vis) {
        		var el = this.body;//this.getLayout().getRenderTarget();
            	var elHeight = el.getHeight();
            	var elWidth = el.getWidth();
            	
        		vis.el.dom.setAttribute('width', elWidth);
        		vis.el.dom.setAttribute('height', elHeight);
        		this.getVisLayout()
        			.force('x', d3.forceX(elWidth/2))
	    			.force('y', d3.forceY(elHeight/2));
//        			.alpha(0.5).restart(); // restarting physics messes up zoomToFit
        		
        		Ext.Function.defer(this.zoomToFit, 100, this);
 //       		this.zoomToFit();
        	}
		}, this);

		this.on('beforedestroy', function(panel) {
			if (this.getVisLayout()) {
				this.getVisLayout().stop(); // make sure force simulation isn't running when removed
			}
		}, this);
        
        me.callParent(arguments);

    },
    
    initLoad: function() {
		this.initGraph();
		this.setNetworkMode(this.DEFAULT_MODE);
		
		if (this.getApiParam('centralize')) {
			this.setNetworkMode(this.CENTRALIZED_MODE);
			var term = this.getApiParam('centralize');
			this.doCentralize(term);
		} else {
			var limit = 3;
			var query = this.getApiParam('query');
			if (query !== undefined) {
				if (query.indexOf('^@') === 0) {
					// it's a category so increase limit so that we get most/all of the terms
					limit = 20;
				} else {
					limit = Ext.isArray(query) ? query.length : query.split(',').length;
				}
			}
			this.getCorpus().getCorpusTerms({autoLoad: false}).load({
				params: {
					limit: limit,
					query: query,
					stopList: this.getApiParam('stopList'),
					categories: this.getApiParam("categories")
				},
			    callback: function(records, operation, success) {
			    	if (success) {
			    		this.loadFromCorpusTermRecords(records);
			    	}
			    },
			    scope: this
	    	});
		}
    },
    
    loadFromQuery: function(query) {
    	if (Ext.isArray(query) && query.length==0) {
    		this.setApiParam("query", undefined);
    		this.resetGraph();
    		return;
    	}
    	this.setApiParams({
    		mode: 'corpus',
    		query: query
    	});
    	var params = this.getApiParams();
    	params.noCache=true;
    	(Ext.isString(query) ? [query] : query).forEach(function(q) {
        	this.getCorpus().getCorpusCollocates({autoLoad: false}).load({
        		params: Ext.apply(Ext.clone(params), {query: q}),
        		callback: function(records, operations, success) {
        			if (success) {
        				this.loadFromCorpusCollocateRecords(records);
        			}
        		},
        		scope: this
        	});
    	}, this);
    },
    
    loadFromCorpusTermRecords: function(corpusTerms) {
    	if (Ext.isArray(corpusTerms) && corpusTerms.length>0) {
    		var terms = [];
    		corpusTerms.forEach(function(corpusTerm) {
    			terms.push(corpusTerm.getTerm());
    		});
    		this.loadFromQuery(terms);
    	}
    },
    
    loadFromCorpusCollocateRecords: function(records, keywordId) {
    	if (Ext.isArray(records)) {
    		var start = this.getApiParam('limit');
    		
    		var el = this.getLayout().getRenderTarget();
    		var cX = el.getWidth()/2;
    		var cY = el.getHeight()/2;
    		
    		var existingKeys = {};
    		this.getNodeData().forEach(function(item) {
    			existingKeys[item.id] = true;
    		}, this);
    		
    		var newNodes = [];
    		var newLinks = [];
    		
    		records.forEach(function(corpusCollocate, index) {
    			var term = corpusCollocate.getTerm();
    			var contextTerm = corpusCollocate.getContextTerm();
    			var termFreq = corpusCollocate.getKeywordRawFreq();
    			var contextFreq = corpusCollocate.getContextTermRawFreq();
    			
    			var termValue = termFreq;
    			var contextValue = contextFreq;
    			if (this.getNetworkMode() === this.CENTRALIZED_MODE) {
    				termValue = 0;
    				contextValue = Math.log(contextFreq);
    			}
    			
    			var termEntry = undefined;
    			var contextTermEntry = undefined;
    			
    			if (index == 0) { // only process keyword once
    				if (keywordId === undefined) keywordId = this.idGet(term);
	    			if (existingKeys[keywordId] !== undefined) {
	    				this.updateDataForNode(keywordId, {
	    					title: term+' ('+termFreq+')',
	    					type: 'keyword',
	    					value: termValue
	    				});
	    			} else {
	    				existingKeys[keywordId] = true;
	    				
	    				termEntry = {
		    				id: keywordId,
	    					term: term,
	    					title: term+' ('+termFreq+')',
	    					type: 'keyword',
	    					value: termValue,
	    					start: start,
	    					fixed: false,
	    					x: cX,
	    					y: cY
						};
	    				newNodes.push(termEntry);
	    			}
				}
    			
    			if (term != contextTerm) {
	    			var contextId = this.idGet(contextTerm);
	    			if (existingKeys[contextId] !== undefined) {
	    			} else {
	    				existingKeys[contextId] = true;
	    				
	    				contextTermEntry = {
    	    				id: contextId,
    	    				term: contextTerm,
        					title: contextTerm+' ('+contextFreq+')',
        					type: 'context',
        					value: contextValue,
        					start: 0,
        					fixed: false,
	    					x: cX,
	    					y: cY
    					};
	    				newNodes.push(contextTermEntry);
	    			}
	    			
	    			var existingLink = null;
	    			var linkData = this.getLinkData();
	    			for (var i = 0; i < linkData.length; i++) {
	    				var link = linkData[i];
	    				if ((link.source.id == keywordId && link.target.id == contextId) || (link.source.id == contextId && link.target.id == keywordId)) {
	    					existingLink = link;
	    					break;
	    				}
	    			}

	    			var linkValue = corpusCollocate.getContextTermRawFreq();
	    			if (existingLink === null) {
	    				newLinks.push({source: keywordId, target: contextId, value: linkValue, id: keywordId+'-'+contextId});
	    			} else if (existingLink.value < linkValue) {
//	    				existingLink.value = linkValue;
	    			}
    			}
    		}, this);
    		
    		this.setNodeData(this.getNodeData().concat(newNodes));
    		this.setLinkData(this.getLinkData().concat(newLinks));
    		
    		this.refresh();		
    	}
    },
    
    idGet: function(term) {
    	return 'links_'+term.replace(/\W/g, '_');
    },
    
    updateDataForNode: function(nodeId, dataObj) {
    	var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				Ext.apply(data[i], dataObj);
				break;
			}
		}
    },
    
    removeNode: function(nodeId, removeOrphans) {
    	var data = this.getNodeData();
		for (var i = 0; i < data.length; i++) {
			if (data[i].id === nodeId) {
				data.splice(i, 1);
				break;
			}
		}
		
		data = this.getLinkData();
		for (var i = data.length-1; i >= 0; i--) {
			if (data[i].source.id === nodeId || data[i].target.id === nodeId) {
				data.splice(i, 1);
			}
		}
		
		
		this.setApiParam("query", Ext.Array.remove(Ext.Array.from(this.getApiParam("query")), nodeId));
		
		if (removeOrphans) {
			// TODO
		}
		
		this.refresh();
    },
    
    doCentralize: function(term) {
    	this.setApiParam("centralize",term);
    	this.resetGraph();
    	
    	this.setNetworkMode(this.CENTRALIZED_MODE);
    	
    	var data = {
			id: this.idGet(term),
			term: term,
			title: term+' ('+1+')',
			type: 'keyword',
			value: 1000,
			start: 0
		};
		this.setNodeData([data]);
		this.refresh();
		
		var centralizeLimit = 150;
		var limit = this.getApiParam('limit');
		this.setApiParam('limit', centralizeLimit);
		this.fetchCollocatesForNode(data);
		this.setApiParam('limit', limit);
    },
    
    // called by setNetworkMode
    applyNetworkMode: function(mode) {
    	if (this.getVisLayout()) {
	    	if (mode === this.DEFAULT_MODE) {
	    		var physics = this.getGraphPhysics().defaultMode;
	    		this.getVisLayout()
	    			.velocityDecay(physics.damping)
		    		.force('link', d3.forceLink().id(function(d) { return d.id; }).distance(physics.springLength).strength(physics.springStrength))
					.force('charge', d3.forceManyBody().strength(physics.nodeGravity))
					.force('collide', d3.forceCollide(function(d) { return Math.sqrt(d.bbox.width * d.bbox.height) * physics.collisionScale; }));
	    		this.getVisLayout().force('x').strength(physics.centralGravity);
	    		this.getVisLayout().force('y').strength(physics.centralGravity);
	    	} else {
	    		var physics = this.getGraphPhysics().centralizedMode;
	    		this.getVisLayout()
	    			.velocityDecay(physics.damping)
		    		.force('link', d3.forceLink().id(function(d) { return d.id; }).distance(physics.springLength).strength(physics.springStrength))
					.force('charge', d3.forceManyBody().strength(function(d) {
						if (d.type === 'keyword') {
							return -10000;
						} else {
							return 0;
						}
					}))
					.force('collide', d3.forceCollide(function(d) {
						if (d.type === 'keyword') {
							return d.value;
						} else {
							return Math.sqrt(d.bbox.width * d.bbox.height) * physics.collisionScale;
						}
					}));
	    		this.getVisLayout().force('x').strength(physics.centralGravity);
	    		this.getVisLayout().force('y').strength(physics.centralGravity);
	    	}
    	}
    	
    	return mode; // need to return mode for it to actually be set
    },
    
    initGraph: function() {
    	var el = this.getLayout().getRenderTarget();
    	el.update('');
    	var width = el.getWidth();
    	var height = el.getHeight();
    	
    	this.setVisLayout(d3.forceSimulation()
    		.force('x', d3.forceX(width/2))
    		.force('y', d3.forceY(height/2))
			.on('tick', function() {
	    		this.getLinks()
	    			.attr('x1', function(d) { return d.source.x; })
	    			.attr('y1', function(d) { return d.source.y; })
	    			.attr('x2', function(d) { return d.target.x; })
	    			.attr('y2', function(d) { return d.target.y; });
	//    		this.getLinks().attr('d', function(d) {
	//				return 'M' + d[0].x + ',' + d[0].y
	//						+ 'S' + d[1].x + ',' + d[1].y
	//						+ ' ' + d[2].x + ',' + d[2].y;
	//			});
	    		this.getNodes().attr('transform', function(d) {
	    			var x = d.x;
	    			var y = d.y;
	    			if (this.getNetworkMode() === this.DEFAULT_MODE || d.type !== 'keyword') {
		    			x -= d.bbox.width*0.5;
		    			y -= d.bbox.height*0.5;
	    			} else {
	    				
	    			}
	    			return 'translate('+x+','+y+')';
	    		}.bind(this));
	    		
	    		if (!this.getDragging() && this.getVisLayout().alpha() < 0.075) {
	    			this.getVisLayout().alpha(-1); // trigger end event
	    		}
	    	}.bind(this))
	    	.on('end', function() {
        		Ext.Function.defer(this.zoomToFit, 100, this);
	    	}.bind(this))
		);
    	
    	var svg = d3.select(el.dom).append('svg').attr('id',this.getVisId()).attr('class', 'linksGraph').attr('width', width).attr('height', height);
    	var g = svg.append('g');
    	
    	var zoom = d3.zoom()
    		.scaleExtent([1/4, 4])
    		.on('zoom', function() {
				g.attr('transform', d3.event.transform);
			});
    	this.setZoom(zoom);
		svg.call(zoom);
		
		svg.on('click', function() {
    		this.getContextMenu().hide();
    	}.bind(this));
    	
    	this.setLinks(g.append('g').attr('class', 'links').selectAll('.link'));
    	this.setNodes(g.append('g').attr('class', 'nodes').selectAll('.node'));
		this.setVis(g);
    },
    
    resetGraph: function() {
		this.setNodeData([]);
    	this.setLinkData([]);
		this.setNetworkMode(this.DEFAULT_MODE); // ? there was another version of this function without this
		this.refresh();
    },
    
    refresh: function() {
    	var me = this;
    	
    	var nodeData = this.getNodeData();
    	var linkData = this.getLinkData();
    	
//    	var nodeMap = d3.map(nodeData, function(d) { return d.id; });
//    	var bilinks = [];
//    	linkData.forEach(function(link) {
//    		var s = link.source = nodeMap.get(link.source);
//    		var t = link.target = nodeMap.get(link.target);
//    		var i = {};
//    		nodeData.push(i);
//    		linkData.push({source: s, target: i}, {source: i, target: t});
//    		bilinks.push([s,i,t]);
//    	});
    	
    	var link = this.getLinks().data(linkData, function(d) { return d.id; });
    	link.exit().remove();
		var linkEnter = link.enter().append('line')
			.attr('class', 'link')
			.attr('id', function(d) { return d.id; })
			.on('mouseover', me.linkMouseOver.bind(me))
			.on('mouseout', me.linkMouseOut.bind(me))
			.on('click', function(data) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.dispatchEvent('termsClicked', this, ['"'+data.source.term+' '+data.target.term+'"~'+this.getApiParam('context')]);
			}.bind(me))
//			.style('fill', 'none')
			.style('cursor', 'pointer')
			.style('stroke-width', function(d) {
				if (me.getNetworkMode() === me.DEFAULT_MODE) {
					return Math.max(1, Math.min(15, Math.sqrt(d.value)));
				} else {
					return 1;
				}
			});
			
		this.setLinks(linkEnter.merge(link));

    	var node = this.getNodes().data(nodeData, function(d) { return d.id; });
    	node.exit().remove();
    	var nodeEnter = node.enter().append('g')
			.attr('class', function(d) { return 'node '+d.type; })
			.attr('id', function(d) { return d.id; })
			.on('mouseover', me.nodeMouseOver.bind(me))
			.on('mouseout', me.nodeMouseOut.bind(me))
			.on('click', function(data) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.dispatchEvent('termsClicked', this, [data.term]);
			}.bind(me))
			.on('dblclick', function(data) {
				d3.event.stopImmediatePropagation();
				d3.event.preventDefault();
				this.fetchCollocatesForNode(data);
			}.bind(me))
			.on('contextmenu', function(d, i) {
				d3.event.preventDefault();
//				me.getTip().hide();
				var menu = me.getContextMenu();
				menu.queryById('label').setHtml(d.term);
    			menu.queryById('fixed').setChecked(d.fixed);
				menu.showAt(d3.event.pageX+10, d3.event.pageY-50);
			})
			.call(d3.drag()
				.on('start', function(d) {
					me.setDragging(true);
					if (!d3.event.active) me.getVisLayout().alpha(0.3).restart();
					d.fx = d.x;
					d.fy = d.y;
					d.fixed = true;
				})
				.on('drag', function(d) {
					me.getVisLayout().alpha(0.3); // don't let simulation end while the user is dragging
					d.fx = d3.event.x;
					d.fy = d3.event.y;
					if (me.isMasked()) {
			    		if (!me.isOffCanvas(d3.event.x, d3.event.y)) {
			    			me.unmask();
			    		}
			    	} else if (me.isOffCanvas(d3.event.x, d3.event.y)) {
			    		me.mask(me.localize('releaseToRemove'));
			    	}
				})
				.on('end', function(d) {
					me.setDragging(false);
//					if (!d3.event.active) me.getVisLayout().alpha(0);
					if (d.fixed != true) {
						d.fx = null;
						d.fy = null;
					}
					if (me.isOffCanvas(d3.event.x, d3.event.y)) {
	    	    		me.unmask();
	    	    		me.mask(me.localize('cleaning'));
	    	    		me.removeNode(d.id);
	    	    		me.unmask();
	    	    	}
				})
			);
    	
    	nodeEnter.append('title');
    	
    	if (this.getNetworkMode() === this.DEFAULT_MODE) {
    		nodeEnter.append('rect')
				.style('stroke-width', 1)
				.style('stroke-opacity', 1);
    	} else {
    		nodeEnter.filter(function(d) { return d.type === 'keyword'; }).append('circle')
    			.style('stroke-width', 1)
    			.style('stroke-opacity', 1);
    	}
    	
    	nodeEnter.append('text')
			.attr('font-family', function(d) { return me.getApplication().getCategoriesManager().getFeatureForTerm('font', d.term); })
			.text(function(d) { return d.term; })
			.style('cursor', 'pointer')
			.style('user-select', 'none')
			.attr('dominant-baseline', 'middle');

		var allNodes = nodeEnter.merge(node);
		allNodes.selectAll('title').text(function(d) { return d.title; });
		allNodes.selectAll('text')
			.attr('font-size', function(d) { return Math.max(10, Math.sqrt(d.value)); })
			.each(function(d) { d.bbox = this.getBBox(); }) // set bounding box for later use

    	this.setNodes(allNodes);
    	
    	if (this.getNetworkMode() === this.DEFAULT_MODE) {
	    	this.getVis().selectAll('rect')
	    		.attr('width', function(d) { return d.bbox.width+16; })
				.attr('height', function(d) { return d.bbox.height+8; })
				.attr('rx', function(d) { return Math.max(2, d.bbox.height * 0.2); })
				.attr('ry', function(d) { return Math.max(2, d.bbox.height * 0.2); })
				.call(this.applyNodeStyle.bind(this));
	    	this.getVis().selectAll('text')
		    	.attr('dx', 8)
				.attr('dy', function(d) { return d.bbox.height*0.5+4; });
    	} else {
    		this.getVis().selectAll('circle')
    			.attr('r', function(d) { return Math.min(150, d.bbox.width); })
    			.call(this.applyNodeStyle.bind(this));
    		this.getVis().selectAll('text')
		    	.attr('dx', function(d) {
		    		if (d.type === 'keyword') {
		    			return -d.bbox.width*0.5;
			    	} else {
			    		return 8;
			    	}
	    		})
				.attr('dy', function(d) {
					if (d.type === 'keyword') {
						return 0;
					} else {
						return d.bbox.height*0.5+4;
					}
				});
    	}
    	this.getVis().selectAll('line').call(this.applyLinkStyle.bind(this));
    	
    	
    	this.getVisLayout().nodes(nodeData);
    	this.getVisLayout().force('link').links(linkData);
    	this.getVisLayout().alpha(1).restart();
    },
    
    isOffCanvas: function(x, y) {
    	var vis = Ext.get(this.getVisId());
    	return x < 0 || y < 0 || x > vis.getWidth() || y > vis.getHeight();
    },
    
    zoomToFit: function(paddingPercent, transitionDuration) {
    	var bounds = this.getVis().node().getBBox();
    	var width = bounds.width;
    	var height = bounds.height;
    	var midX = bounds.x + width/2;
    	var midY = bounds.y + height/2;
    	var svg = this.getVis().node().parentElement;
    	var svgRect = svg.getBoundingClientRect();
    	var fullWidth = svgRect.width;
    	var fullHeight = svgRect.height;
    	var scale = (paddingPercent || 0.8) / Math.max(width/fullWidth, height/fullHeight);
    	var translate = [fullWidth/2 - scale*midX, fullHeight/2 - scale*midY];
    	if (width<1) {return} // FIXME: something strange with spyral
     	
    	d3.select(svg)
    		.transition()
    		.duration(transitionDuration || 500)
    		.call(this.getZoom().transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
    },
 
    applyNodeStyle: function(sel, nodeState) {
		var state = nodeState === undefined ? 'normal' : nodeState;
    	sel.style('fill', function(d) { var type = d.type+'Node'; return this.getGraphStyle()[type][state].fill; }.bind(this));
    	sel.style('stroke', function(d) { var type = d.type+'Node'; return this.getGraphStyle()[type][state].stroke; }.bind(this));
    },
    
    applyLinkStyle: function(sel, linkState) {
    	var state = linkState === undefined ? 'normal' : linkState;
    	sel.style('stroke', function(d) { return this.getGraphStyle().link[state].stroke; }.bind(this));
    	sel.style('stroke-opacity', function(d) { return this.getGraphStyle().link[state].strokeOpacity; }.bind(this));
    },
    
    linkMouseOver: function(d) {
    	this.getVis().selectAll('line').call(this.applyLinkStyle.bind(this));
    	this.getVis().select('#'+d.id).call(this.applyLinkStyle.bind(this), 'highlight');
    },
    
    linkMouseOut: function(d) {
    	this.getVis().selectAll('line').call(this.applyLinkStyle.bind(this));
    },
    
    nodeMouseOver: function(d) {
    	this.setCurrentNode(d);
		
		this.getVis().selectAll('rect').call(this.applyNodeStyle.bind(this));
		
		this.getLinks().each(function(link) {
			var id;
			if (link.source.id == d.id) {
				id = link.target.id;
			} else if (link.target.id == d.id) {
				id = link.source.id;
			}
			if (id !== undefined) {
				this.getVis().select('#'+id+' rect').call(this.applyNodeStyle.bind(this), 'highlight');
				this.getVis().select('#'+link.id).call(this.applyLinkStyle.bind(this), 'highlight');
			}
		}.bind(this));
		
		this.getVis().select('#'+d.id+' rect')
			.style('stroke-width', 3)
			.call(this.applyNodeStyle.bind(this), 'highlight');
    },
    
    nodeMouseOut: function(d) {
    	if (!this.getContextMenu().isVisible()) {
			this.setCurrentNode(undefined);
		}
		
		this.getVis().selectAll('rect')
			.style('stroke-width', 1)
			.call(this.applyNodeStyle.bind(this));
		
		this.getVis().selectAll('line')
			.call(this.applyLinkStyle.bind(this));
    },
    
    fetchCollocatesForNode: function(d) {
    	var limit = this.getApiParam('limit');
    	var query = this.getApiParam("query");
    	
    	var query = Ext.Array.from(this.getApiParam("query"));
    	Ext.Array.include(query, d.term)
		this.setApiParam("query", query);

    	var corpusCollocates = this.getCorpus().getCorpusCollocates({autoLoad: false});
    	corpusCollocates.load({
    		params: Ext.apply(this.getApiParams(), {query: d.term, start: d.start, limit: limit}),
    		callback: function(records, operation, success) {
    			if (success) {
    				this.updateDataForNode(d.id, {
    					start: d.start+limit
    				});
    	    		
    	    		this.loadFromCorpusCollocateRecords(records, d.id);
    			}
    		},
    		scope: this
    	});
    }
    
});
Ext.define('Voyant.panel.Contexts', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Voyant.data.store.Contexts'],
	alias: 'widget.contexts',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		stopList: 'auto',
    		context: 5,
    		expand: 50,
			termColors: 'categories'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'},{xtype: 'termcolorsoption'}]
    },
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;

        Ext.apply(me, { 
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : Ext.create("Voyant.data.store.ContextsBuffered", {
            	parentPanel: this,
            	proxy: {
            		extraParams: {
                    	stripTags: "all"            			
            		}
            	}
//            	sortOnLoad: true,
//            	sorters: {
//                    property: 'position',
//                    direction: 'ASC'
//            	}
            }),
    		selModel: {
    			type: 'rowmodel',
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		this.getApplication().dispatchEvent('termLocationClicked', this, selections);
                    	},
                    	scope: this
                    }
                }
            },
            plugins: [{ // the expander slider assumes there's only one plugin, needs to be updated if changed
                ptype: 'rowexpander',
                rowBodyTpl : new Ext.XTemplate('')
            }],
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }, this.localize('context'), {
                	xtype: 'slider',
                	minValue: 5,
                	value: 5,
                	maxValue: 50,
                	increment: 5,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(me.getApiParam('context'));
                		},
                		changecomplete: function(slider, newValue) {
                			me.setApiParam("context", slider.getValue());
           		        	me.getStore().clearAndLoad({params: me.getApiParams()});
                		}
                	}
                }, this.localize('expand'), {
                	xtype: 'slider',
                	minValue: 5,
                	value: 5,
                	maxValue: 500,
                	increment: 10,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(me.getApiParam('expand'));
                		},
                		changecomplete: function(slider, newValue) {
                			me.setApiParam('expand', newValue);
                			var view = me.getView();
                			var recordsExpanded = me.plugins[0].recordsExpanded;
                			var store = view.getStore();
                			for (var id in recordsExpanded) {
                				var record = store.getByInternalId(id);
            					var row = view.getRow(record);
            					var expandRow = row.parentNode.childNodes[1];
                				if (recordsExpanded[id]) {
                					view.fireEvent("expandbody", row, record, expandRow, {force: true});
                				} else {
                					Ext.fly(expandRow).down('.x-grid-rowbody').setHtml('');
                				}
                			}
                		}
                	}
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }],
    		columns: [{
    			text: this.localize("document"),
    			tooltip: this.localize("documentTip"),
                width: 'autoSize',
        		dataIndex: 'docIndex',
                sortable: true,
                renderer: function (value, metaData, record, rowIndex, colIndex, store) {
                	return store.getCorpus().getDocument(value).getTitle();
                }
            },{
    			text: this.localize("left"),
    			tooltip: this.localize("leftTip"),
    			align: 'right',
        		dataIndex: 'left',
                sortable: true,
                flex: 1
            },{
    			text: this.localize("term"),
    			tooltip: this.localize("termTip"),
        		dataIndex: 'term',
                sortable: true,
                width: 'autoSize',
				xtype: 'coloredtermfield'
            },{
    			text: this.localize("right"),
    			tooltip: this.localize("rightTip"),
        		dataIndex: 'right',
                sortable: true,
                flex: 1
            },{
    			text: this.localize("position"),
    			tooltip: this.localize("positionTip"),
        		dataIndex: 'position',
                sortable: true,
                hidden: true,
                flex: 1
            }],
            listeners: {
            	scope: this,
				corpusSelected: function() {
					if (this.getStore().getCorpus()) {
						this.setApiParams({docId: undefined, docIndex: undefined})
						this.getStore().clearAndLoad()
					}
				},
				
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined})
					this.getStore().clearAndLoad()
				},

            	documentSegmentTermClicked: {
	           		 fn: function(src, documentSegmentTerm) {
	           			 if (!documentSegmentTerm.term) {return;}
	           			 params = {query: documentSegmentTerm.term};
	           			 if (documentSegmentTerm.docId) {
	           				 params.docId = documentSegmentTerm.docId;
	           			 }
	           			 else {
	           				 // default to first document
	           				 params.docIndex = documentSegmentTerm.docIndex ?  documentSegmentTerm.docIndex : 0;
	           			 }
	           			 this.setApiParams(params);
	       	        	if (this.isVisible()) {
	       		        	this.getStore().clearAndLoad()
	       	        	}
	           		 },
	           		 scope: this
            	},
	           	 documentIndexTermsClicked: {
	           		 fn: function(src, documentIndexTerms) {
	           			// this isn't quite right, since we want every term associated with a docIndex, but for now it will do
	           			var queriesHash = {};
	           			var queries = [];
	           			var docIndexHash = {};
	           			var docIndex = [];
	           			documentIndexTerms.forEach(function(item) {
	           				if (!queriesHash[item.term]) {
	           					queries.push(item.term);
	           					queriesHash[item.term]=true;
	           				}
	           				if (!docIndexHash[item.docIndex]) {
	           					docIndex.push(item.docIndex);
	           					docIndexHash[item.docIndex]=true;
	           				}
	           			});
	       	        	this.setApiParams({
	       	        		docId: undefined,
	       	        		docIndex: docIndex,
	       	        		query: queries
	       	        	});
	       	        	if (this.isVisible()) {
	       		        	this.getStore().clearAndLoad({params: this.getApiParams()});
	       	        	}
	           		 },
	           		 scope: this
	           	 },
                 afterrender: function(me) {
                	 me.getView().on('expandbody', function( rowNode, record, expandRow, eOpts ) {
                		 if (expandRow.textContent==="" || (eOpts && eOpts.force)) {
                	            var store = Ext.create("Voyant.data.store.Contexts", {
                	            	stripTags: "all",
                	            	corpus: me.getStore().getCorpus()
                	            });
                	            var data = record.getData();
                	            store.load({
                	            	params: {
                    	            	query: data.query,
                    	            	docIndex: data.docIndex,
                    	            	position: data.position,
                    	            	limit: 1,
                    	            	context: me.getApiParam('expand')
                	            	},
                	                callback: function(records, operation, success) {
                	                	if (success && records.length==1) {
                	                		data = records[0].getData();
                	                		Ext.fly(operation.expandRow).down('.x-grid-rowbody').setHtml(data.left + " <span class='word keyword'>" + data.middle + "</span> " + data.right);
                	                	}
                	                },
                	                expandRow: expandRow
                	            });
                	            
                		 }
                	 });
                 }

            }
        });
        
        me.on("loadedCorpus", function(src, corpus) {
        	if (this.hasCorpusAccess(corpus)==false) {
        		this.mask(this.localize('limitedAccess'), 'mask-no-spinner');
        	}
        	else {
        		var corpusTerms = corpus.getCorpusTerms({autoLoad: false});
        		corpusTerms.load({
        		    callback: function(records, operation, success) {
        		    	if (success && records.length>0) {
        		    		this.setApiParam("query", [records[0].getTerm()]);
        		    		this.getStore().clearAndLoad({params: this.getApiParams()});
        		    	}
        		    },
        		    scope: me,
        		    params: {
        				limit: 1,
        				query: this.getApiParam("query"),
        				stopList: this.getApiParam("stopList"),
        				forTool: 'contexts'
        			}
            	});
        	}
        });
        
        me.on("query", function(src, query) {
        	this.setApiParam('query', query);
        	this.getStore().clearAndLoad({params: this.getApiParams()});
        }, me);
        
        me.on("documentTermsClicked", function(src, documentTerms) {
        	var documentIndexTerms = [];
        	documentTerms.forEach(function(documentTerm) {
        		documentIndexTerms.push({
        			term: documentTerm.getTerm(),
        			docIndex: documentTerm.getDocIndex()
        		});
        	});
        	this.fireEvent("documentIndexTermsClicked", this, documentIndexTerms);
        });
        
        me.on("termsClicked", function(src, terms) {
        	var documentIndexTerms = [];
        	if (Ext.isString(terms)) {terms = [terms];}
        	terms.forEach(function(term) {
        		if (term.docIndex !== undefined) {
            		documentIndexTerms.push({
            			term: term.term,
            			docIndex: term.docIndex
            		});
        		}
        	});
        	if (documentIndexTerms.length > 0) {
        		this.fireEvent("documentIndexTermsClicked", this, documentIndexTerms);
        	}
        });

    	me.callParent(arguments);
     }
     
});
Ext.define('Voyant.panel.CorpusCollocates', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.corpuscollocates',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		context: 5,
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
			termColors: 'categories'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'},{xtype: 'termcolorsoption'}]
    },
    constructor: function(config) {
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.isVisible()) {
    			this.loadFromApis();
    		}
    	});
    	
    	if (config.embedded) {
//    		var cls = Ext.getClass(config.embedded).getName();
//    		if (cls=="Voyant.data.store.DocumentTerms" || cls=="Voyant.data.model.Document") {
//    			this.fireEvent('loadedCorpus', this, config.embedded.getCorpus())
//    		}
    	}
    	else if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus)
    	}
    	
    	this.on("corpusTermsClicked", function(src, terms) {
    		if (this.getStore().getCorpus()) { // make sure we have a corpus
        		var query = [];
        		terms.forEach(function(term) {
        			query.push(term.get("term"));
        		})
        		this.setApiParams({
        			query: query,
        			docId: undefined,
        			docIndex: undefined
        		});
        		if (this.isVisible()) {
            		this.loadFromApis();
        		}
    		}
    	});
    	
    	this.on("documentsClicked", function(src, documents) {
    		var docIds = [];
    		documents.forEach(function(doc) {docIds.push(doc.get('id'))});
    		this.setApiParams({
    			docId: docIds,
    			docid: undefined,
    			query: undefined
    		})
    		if (this.isVisible()) {
        		this.loadFromApis();
    		}
    	});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {this.loadFromApis()}
    	}, this)
    	
    	this.on("query", function(src, query) {
			if (query.length === 0) query = undefined;
    		this.setApiParam("query", query);
    		this.getStore().getProxy().setExtraParam("query", query);
    		this.loadFromApis();
    	}, this)
    },
    
    loadFromApis: function() {
    	if (this.getStore().getCorpus()) {
    		if (this.getApiParam('query')) {
    			this.getStore().clearAndLoad({params: this.getApiParams()});
    		}
    		else {
				var corpusTerms = this.getStore().getCorpus().getCorpusTerms({
					leadingBufferZone: 0,
					autoLoad: false
				});
        		corpusTerms.load({
        		    callback: function(records, operation, success) {
        		    	if (success) {
        		    		var terms = [];
        		    		records.forEach(function(term) {
        		    			terms.push(term.getTerm());
        		    		})
        		    		this.getStore().getProxy().setExtraParam("query", terms);
        		    		this.setApiParam('query', terms);
        		    		this.loadFromApis();
        		    	}
        		    },
        		    scope: this,
        		    params: {
        				limit: 10,
        				stopList: this.getApiParam("stopList")
        			}
            	});

    		}
    	}
    },
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.CorpusCollocatesBuffered", {parentPanel: this});
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
							if (selections.length > 0) {
								var terms = [];
								var context = this.getApiParam("context")
								selections.forEach(function(selection) {
									terms.push('"'+selection.getKeyword()+" "+selection.getContextTerm()+'"~'+context)
								})
								this.getApplication().dispatchEvent('termsClicked', this, terms);
							}
                    	},
                    	scope: this
                    }
                }
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }, this.localize('context'), {
                	xtype: 'slider',
                	minValue: 1,
                	value: 5,
                	maxValue: 30,
                	increment: 2,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(me.getApiParam('context'))
                		},
                		changecomplete: function(slider, newValue) {
                			me.setApiParam("context", slider.getValue());
							me.loadFromApis();
                		}
                	}
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }],
    		columns: [{
    			text: this.localize("term"),
        		dataIndex: 'term',
            	tooltip: this.localize("termTip"),
                sortable: true,
                flex: 1,
				xtype: 'coloredtermfield',
				useCategoriesMenu: true
            },{
    			text: this.localize("rawFreq"),
        		dataIndex: 'rawFreq',
            	tooltip: this.localize("termRawFreqTip"),
                sortable: true,
                width: 'autoSize',
                hidden: true
            },{
            	text: this.localize("contextTerm"),
            	dataIndex: 'contextTerm',
            	tooltip: this.localize("contextTermTip"),
            	flex: 1,
            	sortable: true,
				xtype: 'coloredtermfield'
            },{
            	text: this.localize("contextTermRawFreq"),
            	tooltip: this.localize("contextTermRawFreqTip"),
            	dataIndex: 'contextTermRawFreq',
            	width: 'autoSize',
            	sortable: true
            }/*,{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize('trendTip'),
                width: 120,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline'
                }
            }*/],
            
            listeners: {
				scope: this,
            	termsClicked: function(src, terms) {
					if (this.getStore().getCorpus()) { // make sure we have a corpus
						var queryTerms = [];
						terms.forEach(function(term) {
							if (Ext.isString(term)) {queryTerms.push(term);}
							else if (term.term) {queryTerms.push(term.term);}
							else if (term.getTerm) {queryTerms.push(term.getTerm());}
						});
						if (queryTerms.length > 0) {
							this.setApiParams({
								docIndex: undefined,
								docId: undefined,
								query: queryTerms
							});
							if (this.isVisible()) {
								this.loadFromApis();
							}
						}
					}
				},

				corpusSelected: function() {
					if (this.getStore().getCorpus()) {
						this.setApiParams({docId: undefined, docIndex: undefined})
						this.loadFromApis();
					}
				},
				
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined});
					this.loadFromApis();
				}
            }
        });

        me.callParent(arguments);
        
        me.getStore().getProxy().setExtraParam("withDistributions", true);
        
    }
    
})
Ext.define('Voyant.widget.CorpusTermSummary', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.panel.Panel'],
    alias: 'widget.corpustermsummary',
    statics: {
        i18n: {
        },
        api: {
            stopList: 'auto',
            query: undefined,
            limit: 5
        }
    },
    config: {
        corpus: undefined,
        record: undefined, // Voyant.data.model.CorpusTerm
        collocatesStore: undefined,
        correlationsStore: undefined,
        phrasesStore: undefined,
        documentTermsStore: undefined
    },
    cls: 'corpus-term-summary',

    constructor: function(config) {
        if (config.record === undefined) {
            console.warn('CorpusTermSummary: no config.record!');
            return false;
        }
        
        Ext.apply(this, {
            items: {
                itemId: 'main',
                minHeight: 200,
                scrollable: true,
                margin: 5
            },
            dockedItems: {
                dock: 'bottom',
                xtype: 'toolbar',
                items: {
                    fieldLabel: this.localize('items'),
                    labelWidth: 40,
                    width: 120,
                    xtype: 'slider',
                    increment: 5,
                    minValue: 5,
                    maxValue: 59,
                    listeners: {
                        boxready: function(slider) {
                            slider.setValue(this.getApiParam('limit'));
                        },
                        changecomplete: function(slider, newvalue) {
                            this.setApiParam('limit', newvalue);
                            this.loadStuff();
                        },
                        scope: this
                    }
                }
            },
            listeners: {
                boxready: function() {
                    this.body.on('click', function(e) {
                        var target = e.getTarget(null, null, true);
                        if (target && target.dom.tagName == 'A') {
                            if (target.hasCls('corpus-type')) {
                                this.dispatchEvent('termsClicked', this, [target.getHtml()]);
                            }
                        }
                    }, this, {stopPropagation: true});
                    
                    this.getDockedItems().forEach(function(i) {
                       i.getEl().on('click', null, this, {stopPropagation: true}); // stop owner container from receiving clicks
                    });
                    
                    this.loadStuff();
                },
                scope: this
            }
        });
        
        Ext.applyIf(config, {
            title: this.localize('title')+config.record.getTerm()
        });

        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        
        var corpus = this.getRecord().store.getCorpus();
        this.setCorpus(corpus);

        this.setApiParam('query', this.getRecord().getTerm());
        
        this.setCollocatesStore(Ext.create('Voyant.data.store.CorpusCollocates', { corpus: corpus }));
        this.setCorrelationsStore(Ext.create('Voyant.data.store.TermCorrelations', { corpus: corpus }));
        this.setPhrasesStore(Ext.create('Voyant.data.store.CorpusNgrams', { corpus: corpus }));
        this.setDocumentTermsStore(Ext.create('Voyant.data.store.DocumentTerms', { corpus: corpus }));
        
    },

    loadStuff: function() {
        this.getComponent('main').removeAll();
        
        var docIndexes = [];
        for (var i = 0; i < this.getCorpus().getDocumentsCount(); i++) {
            docIndexes[i] = i;
        }
        this.getComponent('main').add({
            xtype: 'container',
            cls: 'section',
            layout: 'hbox',
            align: 'bottom',
            items: [{
                xtype: 'container',
                html: '<div class="header">'+this.localize('distribution')+'</div>'
            },{
                itemId: 'distLine',
                xtype: 'sparklineline',
                values: [],
                height: 20,
                width: 200
            }],
            listeners: {
                afterrender: function(container) {
                    container.mask(this.localize('loading'));
                    // TODO make distribution bins reflective of doc sizes
                    this.getDocumentTermsStore().load({
                        params: {
                            query: this.getApiParam('query'),
                            docIndex: docIndexes,
                            withDistributions: true,
                            bins: parseInt(this.getApiParam('limit'))*2
                        },
                        callback: function(records, op, success) {
                            if (success && records && records.length>0) {
                                var arrays = records.map(function(r) { return r.getDistributions(); });
                                var values = arrays.reduce(function(a,b) { return a.concat(b); });
                                this.down('#distLine').setValues(values);
                                container.unmask();
                            }
                        },
                        scope: this
                    });
                },
                scope: this
            }
        });
        
        this.addSection(
            this.localize('collocates'), this.getCollocatesStore(), this.getApiParams(),
            '<tpl for="." between="; "><a href="#" onclick="return false" class="corpus-type keyword" voyant:recordId="{term}">{term}</a><span style="font-size: smaller"> ({val})</span></tpl>',
            function(r) {
                return {term: r.getContextTerm(), val: r.getContextTermRawFreq()}
            }
        );
        
        this.addSection(
            this.localize('correlations'), this.getCorrelationsStore(), this.getApiParams(),
            '<tpl for="." between="; "><a href="#" onclick="return false" class="corpus-type keyword" voyant:recordId="{term}">{term}</a><span style="font-size: smaller"> ({val})</span></tpl>',
            function(r) {
                return {term: r.get('sourceTerm'), val: r.get('source').rawFreq}
            }
        );
        
        this.addSection(
            this.localize('phrases'), this.getPhrasesStore(), Ext.apply({minLength: 3, sort: 'length'}, this.getApiParams()),
            '<tpl for="."><div>&ldquo;{phrase}&rdquo;</div></tpl>',
            function(r) {
                return {phrase: r.getTerm()}
            }
        );
    },
    
    addSection: function(title, store, params, template, mapping) {
        return this.getComponent('main').add({
            xtype: 'container',
            html: '<div class="header">'+title+'</div>',
            cls: 'section',
            listeners: {
                afterrender: function(container) {
                    container.mask(this.localize('loading'));
                    store.load({
                        params: params,
                        callback: function(records, op, success) {
							container.unmask();
                            if (success && records && records.length>0) {
                                Ext.dom.Helper.append(container.getTargetEl().first().first(),
                                    new Ext.XTemplate('<div class="contents">'+template+'</div>').apply(records.map(mapping))
                                );
                            }
                        }
                    });
                },
                scope: this
            }
        });
    }
});

Ext.define('Voyant.panel.Correlations', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.correlations',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		stopList: 'auto',
    		minInDocumentsCountRatio: 100,
			termColors: 'categories'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'}, {xtype: 'categoriesoption'}, {xtype: 'termcolorsoption'}]
    },
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        var me = this;

        Ext.apply(me, { 
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
    		store: Ext.create("Voyant.data.store.TermCorrelationsBuffered", {
            	parentPanel: this,
				leadingBufferZone: 100 // since these calls are expensive reduce buffer to 1 page
	        }),

    		columns: [{
    			text: this.localize("source"),
    			tooltip: this.localize("sourceTip"),
        		dataIndex: 'sourceTerm',
        		sortable: false,
				xtype: 'coloredtermfield'
    		},{
                xtype: 'widgetcolumn',
                tooltip: this.localize("trendTip"),
                width: 100,
                dataIndex: 'source-distributions',
                widget: {
                    xtype: 'sparklineline'
                },
                text: '←'
            },{
                xtype: 'widgetcolumn',
                tooltip: this.localize("trendTip"),
                width: 100,
                dataIndex: 'target-distributions',
                widget: {
                    xtype: 'sparklineline'
                },
                text: '→',
                align: 'right'
            },{
    			text: this.localize("target"),
    			tooltip: this.localize("targetTip"),
        		dataIndex: 'targetTerm',
        		sortable: false,
				xtype: 'coloredtermfield'
    		},{
    			text: this.localize("correlation"),
    			tooltip: this.localize("correlationTip"),
        		dataIndex: 'correlation'
    		},{
    			text: this.localize("significance"),
    			tooltip: this.localize("significanceTip"),
        		dataIndex: 'significance'
    		}],
    		

            listeners: {
            	scope: this,
				corpusSelected: function() {
					this.setApiParams({docIndex: undefined, docId: undefined});
	        		this.getStore().getProxy().setExtraParam('tool', 'corpus.CorpusTermCorrelations');
	        		this.getStore().load();
				},
				
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined})
	        		this.getStore().getProxy().setExtraParam('tool', 'corpus.DocumentTermCorrelations');
	        		this.getStore().load();
				}

            },
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                },{
                    xtype: 'totalpropertystatus'
                }, {
                	xtype: 'tbspacer'
                }, {
                	xtype: 'tbtext',
                	itemId: 'minInDocumentsCountRatioLabel',
                	text: me.localize('minInDocumentsCountRatioLabel')
                }, {
        			xtype: 'slider',
	            	increment: 5,
	            	minValue: 0,
	            	maxValue: 100,
	            	width: 75,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam("minInDocumentsCountRatio"))
	            			slider.up('toolbar').getComponent("minInDocumentsCountRatioLabel").setText(new Ext.XTemplate(me.localize("minInDocumentsCountRatioLabel")).apply([this.getApiParam("minInDocumentsCountRatio")]));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({minInDocumentsCountRatio: newvalue});
	            			slider.up('toolbar').getComponent("minInDocumentsCountRatioLabel").setText(new Ext.XTemplate(me.localize("minInDocumentsCountRatioLabel")).apply([newvalue]));
	            			this.getStore().load();
	            		},
	            		scope: this
	            	}
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }]
        });
        
        me.on("loadedCorpus", function(src, corpus) {
        	if (corpus.getDocumentsCount()==1) { // switch to documents mode
        		this.getStore().getProxy().setExtraParam('tool', 'corpus.DocumentTermCorrelations');
        	}
        	if (this.isVisible()) {
        		this.getStore().load();
        	}
        });
        
    	me.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {this.getStore().load();}
    	}, this)

    	me.on("query", function(src, query) {
        	this.setApiParam("query", query);
        	this.getStore().load();
        }, me);
        
        me.callParent(arguments);
     }
     
});
Ext.define('Voyant.panel.CorpusCreator', {
	extend: 'Ext.form.Panel',
	requires: ['Ext.form.field.File'],
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.corpuscreator',
	isConsumptive: true,
    statics: {
    	i18n: {
			corpusSortInitialOrder: 'initial order',
			dtocIndexDoc: 'DToC Index Document'
    	},
    	api: {
    		inputFormat: undefined,
    		language: undefined,
    		xmlDocumentsXpath: undefined,
    		xmlGroupByXpath: undefined,
    		xmlContentXpath: undefined,
    		xmlTitleXpath: undefined,
    		xmlAuthorXpath: undefined,
    		xmlPubDateXpath: undefined,
    		xmlPublisherXpath: undefined,
    		xmlPubPlaceXpath: undefined,
    		xmlKeywordXpath: undefined,
    		xmlCollectionXpath: undefined,
    		xmlExtraMetadataXpath: undefined,
    		htmlGroupByQuery: undefined,
    		htmlDocumentsQuery: undefined,
    		htmlContentQuery: undefined,
    		htmlTitleQuery: undefined,
    		htmlAuthorQuery: undefined,
    		htmlPubDateQuery: undefined,
    		htmlPublisherQuery: undefined,
    		htmlPubPlaceQuery: undefined,
    		htmlKeywordsQuery: undefined,
    		htmlCollectionQuery: undefined,
    		htmlExtraMetadataQuery: undefined,
    		//jsonGroupByPointer: undefined,
    		jsonDocumentsPointer: undefined,
    		jsonContentPointer: undefined,
    		jsonTitlePointer: undefined,
    		jsonAuthorPointer: undefined,
    		jsonPubDatePointer: undefined,
    		jsonPublisherPointer: undefined,
    		jsonPubPlacePointer: undefined,
    		jsonKeywordsPointer: undefined,
    		jsonCollectionPointer: undefined,
    		jsonExtraMetadataPointer: undefined,
    		tokenization: undefined,
    		adminPassword: undefined,
    		accessPassword: undefined,
    		noPasswordAccess: undefined,
    		tableDocuments: undefined,
    		tableContent: undefined,
    		tableTitle: undefined,
    		tableAuthor: undefined,
			tablePubDate: undefined,
			tablePublisher: undefined,
			tablePubPlace: undefined,
			tableKeywords: undefined,
			tableCollection: undefined,
			tableExtraMetadata: undefined,
    		title: undefined,
    		subTitle: undefined,
    		inputRemoveFrom: undefined,
    		inputRemoveFromAfter: undefined,
    		inputRemoveUntil: undefined,
    		inputRemoveUntilAfter: undefined,
    		sort: undefined,
			dtocIndexDoc: -1
    	}
    },
    
    constructor: function(config) {
        this.callParent(arguments);
        config = config || {};
        var me = this;
    	this.mixins['Voyant.panel.Panel'].constructor.call(this, 
    			Ext.apply(config, {
    				includeTools: {
    					gear: true,
    					help: true,
    					language: this.getLanguageToolMenu()
    				}
    			})
    	);
    	
    },
    
    initComponent: function() {
        var me = this;

        Ext.apply(me, {
    		title: this.localize('title'),
    		width: 800,
    		frame: true,
    		padding: 10,
    		style: {
    		    borderColor: '#aaa',
    		    borderStyle: 'solid'
    		},
    		frameHeader: true,
    		layout: {
    			type: 'vbox',
    			align: 'stretch'
    		},
	    	dockedItems: [{
	    		xtype: 'toolbar',
                overflowHandler: 'scroller',
                dock: 'bottom',
    	    	buttonAlign: 'right',
	    		items: [{
	    			text: me.localize('Open'),
                    glyph: 'xf115@FontAwesome', // not visible
	    			tooltip: me.localize('SelectExisting'),
	    			hidden: this.getCorpus()!=undefined,
	    			handler: function() {
	    				Ext.create('Ext.window.Window', {
	    				    title: me.localize('Open'),
	    				    layout: 'fit',
	    				    modal: true,
	    				    items: {
	    				        xtype: 'form',
	    				        submitEmptyText: false,
	    				        items: {
	    				        	xtype: 'corpusselector',
									margin: 10
	    				        },
	    				        buttons: [
	    				        	{
	    				        		text: me.localize('Open'),
	    			                    glyph: 'xf00c@FontAwesome',
	    				        		handler: function(btn) {
	    				        			var form = btn.up('form').getForm();
	    				        			var corpus = btn.up('form').getForm().getValues().corpus;
	    				        			if (corpus!='') {
	    				        				me.loadCorpus({corpus: corpus});
		    				        			btn.up('window').close();
	    				        			}
	    				        			else {
	    				    	        		Ext.Msg.show({
	    				    	        		    title: me.localize('SelectExisting'),
	    				    	        		    message: me.localize('PleaseSelectExisting'),
	    				    	        		    buttons: Ext.Msg.OK,
	    				    	        		    icon: Ext.Msg.ERROR
	    				    	        		});
	    				        			}
	    				        		},
	    				        		flex: 1
	    				            },{
	    				        		text: me.localize('cancel'),
	    			                    glyph: 'xf00d@FontAwesome',
	    				        		flex: 1,
	    				        		handler: function(btn) {
	    				        			btn.up('window').close();
	    				        		}
	    				        	}
	    				        ]
	    				    }
	    				}).show();
	    			}
	    		},{
    	        	xtype: 'fileuploadfield',
                    glyph: 'xf093@FontAwesome',
    	        	name: 'upload',
        	    	buttonOnly: true,
        	    	hideLabel: true,
		            ui: 'default-toolbar',
        	    	buttonText: me.localize('Upload'),
        	    	listeners: {
        	    		render: function(filefield) {
        	    			filefield.fileInputEl.dom.setAttribute('multiple', true);
        		        	Ext.tip.QuickTipManager.register({
       		                 target: filefield.getEl(),
       		                 text: me.localize('UploadLocal')
       		             	});
        	            },
        	            beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
        	            change: function(filefield, value) {
        	            	if (value) {
            	            	var form = filefield.up('form').getForm();
            	            	if (form.isValid()) {
            	            		var files = filefield.fileInputEl.dom.files;
            	            		var badFilesRe = /\.(png|gif|jpe?g|mp[234a]|mpeg|exe|wmv|avi|ppt|mpg|tif|wav|mov|psd|wma|ai|bmp|pps|aif|pub|dwg|indd|swf|asf|mbd|dmg|flv)$/i;
            	            		var goodFilesRe = /\.(txt|pdf|html?|xml|docx?|rtf|pages|epub|odt|zip|jar|tar|gz|ar|cpio|bzip2|bz2|gzip|xlsx?)$/i;
            	            		var badFiles = [];
            	            		var unknownFiles = [];
            	            		for (var i = 0, len = files.length; i<len; i++) {
            	            			var filename = files[i].name;
            	            			if (badFilesRe.test(filename)) {
            	            				badFiles.push(filename.split("/").pop());
            	            			}
            	            			else if (!goodFilesRe.test(filename)) {
            	            				unknownFiles.push(filename.split("/").pop());
            	            			}
            	            		}
            	            		if (badFiles.length>0 || unknownFiles.length>0) {
            	            			var file = filefield;
            	            			Ext.Msg.show({
            	            				title: me.localize("fileTypesWarning"),
            	            				icon: Ext.MessageBox.ERROR,
            	            				message: me.localize('fileTypesMessage')+'<ul>' +
            	            					(badFiles.length > 0 ? ('<li>'+me.localize("badFiles") + badFiles.slice(0, 5).join(", ") + (badFiles.length>5 ? '…' : '') + '</li>') : '') +
            	            					(unknownFiles.length>0 ? ('<li>' +me.localize("unknownFiles") + unknownFiles.slice(0, 5).join(", ") + (unknownFiles.length>5 ? '…' : '') +'</li>') : '')+
            	            					'</ul>'+me.localize('sureContinue'),
            	            				buttons: Ext.Msg.YESNO,
            	            				fn: function(btn) {
            	            			        if (btn === 'yes') {
            	            			        	me.loadForm(form);
            	            			        }
            	            			        else {
            	            			        	file.reset(); // make sure we can trigger a change next time
            	            			        	file.fileInputEl.dom.setAttribute('multiple', true);
            	            			        }
            	            			    },
            	            				scope: form
            	            			});
            	            		}
            	            		else {
            	            			me.loadForm(form);
            	            		}
            	            	}
        	            	}
        	            }
        	    	}
	    		},'->', {
	    	    	xtype: 'button',
	    	    	scale: 'large',
        			glyph: 'xf00d@FontAwesome',
	    	    	text: this.localize('cancel'),
	    	    	hidden: this.getCorpus()==undefined,
	    	    	handler: function(btn) {
	    	        	var win = this.up("window");
	    	        	if (win && win.isFloating()) {
	    	        		win.close();
	    	        	}
	    	    	}
	    	    }, {
	    	    	xtype: 'button',
	    	    	scale: 'large',
                    glyph: 'xf00c@FontAwesome',
	    	    	text: this.localize('reveal'),
	    	    	ui: 'default',
	    	    	width: 200,
	    	    	handler: function(btn) {
	    	        	var input = btn.up('form').down('#input').getValue();
	    	        	if (input !== '') {
	    	        		var api = me.getApiParams();
	    	            	delete api.view;
	    	            	delete api.stopList;
	    	        		if (api.inputFormat && input.trim().indexOf("<")!==0) {
	    	        			Ext.Msg.confirm(me.localize('error'), me.localize('errorNotXmlContinue'), function(buttonId) {
	    	        				if (buttonId=='yes') {
				    	        		me.loadCorpus(Ext.apply(api, {input: input}));
	    	        				}
	    	        			}, me);
	    	        		}
	    	        		else {
		    	        		me.loadCorpus(Ext.apply(api, {input: input}));
	    	        		}
	    	        	}
	    	        	else {
	    	        		Ext.Msg.show({
	    	        		    title: me.localize('noTextProvided'),
	    	        		    message: me.localize('pleaseProvideText'),
	    	        		    buttons: Ext.Msg.OK,
	    	        		    icon: Ext.Msg.ERROR
	    	        		});
	    	        	}
	    	    	}
	    	    }]
	    	}],
	    	items: [{
	    		html: this.getInitialConfig().addTextLabel,
	    		hidden: this.getInitialConfig().addTextLabel==undefined
	    	},{
//	    		layout: 'fit',
	    		height: 100,
    	    	xtype: 'textareafield',
    	    	itemId: 'input',
    	    	emptyText: this.localize('emptyInput')
	    	}]
        });
        
        me.on("boxready", function(panel) {
        	var app = this.getApplication();
        	if (app.getAllowInput && app.getAllowInput()=="false") {
				panel.getDockedItems().forEach(function(docked) {
					panel.removeDocked(docked);
				})
        		panel.removeAll();
				panel.add({
					xtype: 'container',
					html: "<p>"+panel.localize('noAllowInputMessage')+"</p>"
				});
        	}
        });

        me.callParent(arguments);
        
    },
    
    loadForm: function(form) {
    	var params = {tool: this.getCorpus() ? 'corpus.CorpusMetadata' : 'corpus.CorpusCreator'};
    	if (this.getCorpus()) {
    		Ext.apply(params, {
    			corpus: this.getCorpus().getId(),
    			addDocuments: true
    		})
    	};
    	var apiParams = this.getApiParams();
    	delete apiParams.view;
    	delete apiParams.stopList;
    	Ext.apply(params, apiParams);
    	var view = this.getApplication().getViewport();
		view.mask(this.localize('uploadingCorpus'));
		form.submit({
			url: this.getTromboneUrl(),
			params: params,
			failure: function(form, action) { // we always fail because of content-type
            	view.unmask();
				if (action.result && (action.result.corpus || action.result.stepEnabledCorpusCreator)) {
					var corpusParams = {corpus: action.result.corpus ? action.result.corpus.metadata.id : action.result.stepEnabledCorpusCreator.storedId};
					Ext.applyIf(corpusParams, apiParams); // adding title & subTitle here
					this.setCorpus(undefined)
					this.loadCorpus(corpusParams);
				} else {
					
					this.showResponseError("Unable to load corpus.", action.response)
				}
			},
			scope: this
		});
    },
   
    loadCorpus: function(params) {
    	if (this.getCorpus()) {
    		Ext.apply(params, {
    			corpus: this.getCorpus().getId(),
    			addDocuments: true
    		})
    	};
    	
    	var win = this.up("window");
    	if (win && win.isFloating()) {
    		win.close();
    	}
    	
		this.getApplication().loadCorpusFromParams(params);
    },
    
    showOptionsClick: function(panel) {
    	var me = panel;
    	if (me.optionsWin === undefined) {
			var langCodes = ['bo'].concat(Object.keys(Voyant.widget.StopListOption.stoplists).filter(function(code) { return code !== 'mu'; })).sort();
			var langArray = langCodes.map(function(code) { return [code, me._localizeClass(Voyant.widget.StopListOption, code)] });
			langArray.unshift(['', me._localizeClass(Voyant.widget.StopListOption, 'auto')]);
    		me.optionsWin = Ext.create('Ext.window.Window', {
    			title: me.localize('gearWinTitle'),
    			closeAction: 'hide',
//    			width: 500,
    			layout: 'fit',
    			bodyPadding: 10,
    			anchor: '100% 100%',
//    			shrinkWrap: 3,
    			items: [{
    				xtype: 'form',
    				defaultType: 'textfield',
        			maxHeight: me.getApplication().getViewport().getHeight()-120,
        			scrollable: true,
    				fieldDefaults: {
    					labelAlign: 'right',
    					labelWidth: 110,
    					width: 350
    				},
    				items: [
						{
						    xtype:'combo',
						    fieldLabel: me.localize('inputFormat'),
						    labelWidth: 90, // try to align with fieldset
						    name: 'inputFormat',
						    queryMode:'local',
						    store:[['',me.localize('inputFormatAuto')],['dtoc','DToC: Dynamic Table of Contexts'],['TEI',"TEI: Text Encoding Initative"],['TEI',"TEI Corpus"],['RSS',"Really Simple Syndication: RSS"]],
						    value: '',
						    listeners: {
						    	afterrender: {
						    		fn: function(combo) {
						    			var inputFormat = this.getApiParam('inputFormat');
						    			if (inputFormat) {
						    				combo.setValue(inputFormat);
						    			}
						    		},
						    		scope: me
						    	},
								change: {
									fn: function(combo, newval, oldval) {
										var dtocIndexDocField = combo.up('form').down('[name=dtocIndexDoc]');
										if (newval === 'dtoc') {
											dtocIndexDocField.show();
										} else {
											dtocIndexDocField.hide();
										}
									},
									scope: me
								}
						    }
						},{
							xtype: 'container',
							html: '<p><i>'+new Ext.Template(me.localize('advancedOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-xml'])+'</i></p>',
							width: 375
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-titles' target='voyantdocs'>"+me.localize('corpusOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('corpusTitle'),
									name: 'title'
								},{
									fieldLabel: me.localize('corpusSubTitle'),
									name: 'subTitle'
								},{
									fieldLabel: me.localize("corpusSort"),
									name: 'sort',
								    xtype:'combo',
								    queryMode:'local',
								    store:[['',me.localize('corpusSortAuto')],['TITLEASC',me.localize('corpusSortTitle')],['AUTHORASC',me.localize('corpusSortAuthor')],['PUBDATEASC',me.localize('corpusSortPubDate')],['NOCHANGE', me.localize('corpusSortInitialOrder')]],
								    value: '',
								    listeners: {
								    	afterrender: {
								    		fn: function(combo) {
								    			var inputFormat = this.getApiParam('sort');
								    			if (inputFormat) {
								    				combo.setValue(inputFormat);
								    			}
								    		},
								    		scope: me
								    	}
								    }
								},{
									fieldLabel: me.localize('dtocIndexDoc'),
									name: 'dtocIndexDoc',
									xtype: 'numberfield',
									value: -1,
									minValue: -1,
									maxValue: 99,
									width: 180,
									hidden: true
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-text' target='voyantdocs'>"+me.localize('textOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("textOptionsText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('inputRemoveUntil'),
									name: 'inputRemoveUntil'
								},{
									fieldLabel: me.localize('inputRemoveUntilAfter'),
									name: 'inputRemoveUntilAfter'
								},{
									fieldLabel: me.localize('inputRemoveFrom'),
									name: 'inputRemoveFrom'
								},{
									fieldLabel: me.localize('inputRemoveFromAfter'),
									name: 'inputRemoveFromAfter'
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-xml' target='voyantdocs'>"+me.localize('xmlOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("xmlOptionsText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('xpathContent'),
									name: 'xmlContentXpath'
								},{
									fieldLabel: me.localize('xpathTitle'),
									name: 'xmlTitleXpath'
								},{
									fieldLabel: me.localize('xpathAuthor'),
									name: 'xmlAuthorXpath'
								},{
									fieldLabel: me.localize('xpathDocuments'),
									name: 'xmlDocumentsXpath'
								},{
									fieldLabel: me.localize('xpathGroupBy'),
									name: 'xmlGroupByXpath'
								},{
									xtype: 'fieldset',
			                        title: me.localize('xmlAdditionalOptions'),
			                        collapsible: true,
			                        collapsed: true,
			                        defaultType: 'textfield',
			                        items: [{
										fieldLabel: me.localize('xpathPubDate'),
										name: 'xmlPubDateXpath'
									},{
										fieldLabel: me.localize('xpathPublisher'),
										name: 'xmlPublisherXpath'
									},{
										fieldLabel: me.localize('xpathPubPlace'),
										name: 'xmlPubPlaceXpath'
									},{
										fieldLabel: me.localize('xpathKeywords'),
										name: 'xmlKeywordXpath'
									},{
										fieldLabel: me.localize('xpathCollection'),
										name: 'xmlCollectionXpath'
									},{
										xtype: 'textareafield',
										grow: true,
										fieldLabel: me.localize('xpathExtra'),
										name: 'xmlExtraMetadataXpath'
									}]
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-html' target='voyantdocs'>"+me.localize('htmlOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+new Ext.Template(me.localize('htmlOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-html'])+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('xpathContent'),
									name: 'htmlContentQuery'
								},{
									fieldLabel: me.localize('xpathTitle'),
									name: 'htmlTitleQuery'
								},{
									fieldLabel: me.localize('xpathAuthor'),
									name: 'htmlAuthorQuery'
								},{
									fieldLabel: me.localize('xpathDocuments'),
									name: 'htmlDocumentsQuery'
								},{
									fieldLabel: me.localize('xpathGroupBy'),
									name: 'htmlGroupByQuery'
								},{
									xtype: 'fieldset',
			                        title: me.localize('xmlAdditionalOptions'),
			                        collapsible: true,
			                        collapsed: true,
			                        defaultType: 'textfield',
			                        items: [{
										fieldLabel: me.localize('xpathPubDate'),
										name: 'htmlPubDateQuery'
									},{
										fieldLabel: me.localize('xpathPublisher'),
										name: 'htmlPublisherQuery'
									},{
										fieldLabel: me.localize('xpathPubPlace'),
										name: 'htmlPubPlaceQuery'
									},{
										fieldLabel: me.localize('xpathKeywords'),
										name: 'htmlKeywordsQuery'
									},{
										fieldLabel: me.localize('xpathCollection'),
										name: 'htmlCollectionQuery'
									},{
										xtype: 'textareafield',
										grow: true,
										fieldLabel: me.localize('xpathExtra'),
										name: 'htmlExtraMetadataQuery'
									}]
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-json' target='voyantdocs'>"+me.localize('jsonOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+new Ext.Template(me.localize('jsonOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-json'])+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('xpathContent'),
									name: 'jsonContentPointer'
								},{
									fieldLabel: me.localize('xpathTitle'),
									name: 'jsonTitlePointer'
								},{
									fieldLabel: me.localize('xpathAuthor'),
									name: 'jsonAuthorPointer'
								},{
									fieldLabel: me.localize('xpathDocuments'),
									name: 'jsonDocumentsPointer'
								},/*{ 
									// groupBy is tricky because documents are combined in ways that may conflict 
									// with the other extraction options (especially since Pointer expects absolute
		 							// addresses from root). So for now we'll skip.
									fieldLabel: me.localize('xpathGroupBy'),
									name: 'jsonGroupByPointer'
								},*/{
									xtype: 'fieldset',
			                        title: me.localize('xmlAdditionalOptions'),
			                        collapsible: true,
			                        collapsed: true,
			                        defaultType: 'textfield',
			                        items: [{
										fieldLabel: me.localize('xpathPubDate'),
										name: 'jsonPubDatePointer'
									},{
										fieldLabel: me.localize('xpathPublisher'),
										name: 'jsonPublisherPointer'
									},{
										fieldLabel: me.localize('xpathPubPlace'),
										name: 'jsonPubPlacePointer'
									},{
										fieldLabel: me.localize('xpathKeywords'),
										name: 'jsonKeywordsPointer'
									},{
										fieldLabel: me.localize('xpathCollection'),
										name: 'jsonCollectionPointer'
									},{
										xtype: 'textareafield',
										grow: true,
										fieldLabel: me.localize('xpathExtra'),
										name: 'jsonExtraMetadataPointer'
									}]
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-tables' target='voyantdocs'>"+me.localize('tableOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [{
	    							xtype: 'container',
	    							html: '<p><i>'+new Ext.Template(me.localize('tableOptionsText')).applyTemplate([me.getBaseUrl()+'docs/#!/guide/corpuscreator-section-tables'])+'</i></p>',
	    							width: 375
	                        	},{
								    xtype:'combo',
									fieldLabel: me.localize('tableDocuments'),
								    name: 'tableDocuments',
								    queryMode:'local',
								    store:[['',me.localize('tableDocumentsTable')],['rows',me.localize('tableDocumentsRows')],['columns',me.localize("tableDocumentsColumns")]],
								    forceSelection:true,
								    value: ''
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("tableNoHeadersRowText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize("tableNoHeadersRow"),
									xtype: 'checkboxfield',
									name: 'tableNoHeadersRow',
									inputValue: "true"
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("tableContentText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('tableContent'),
									validator: function(val) {return me.validatePositiveNumbersCsv.call(me, val)},
									name: 'tableContent'
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("tableMetadataText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('tableAuthor'),
									validator: function(val) {return me.validatePositiveNumbersCsv.call(me, val)},
									name: 'tableAuthor'
								},{
									fieldLabel: me.localize('tableTitle'),
									validator: function(val) {return me.validatePositiveNumbersCsv.call(me, val)},
									name: 'tableTitle'
								},{
									xtype: 'fieldset',
			                        title: me.localize('xmlAdditionalOptions'),
			                        collapsible: true,
			                        collapsed: true,
			                        defaultType: 'textfield',
			                        items: [{
										fieldLabel: me.localize('xpathPubDate'),
										name: 'tablePubDate'
									},{
										fieldLabel: me.localize('xpathPublisher'),
										name: 'tablePublisher'
									},{
										fieldLabel: me.localize('xpathPubPlace'),
										name: 'tablePubPlace'
									},{
										fieldLabel: me.localize('xpathKeywords'),
										name: 'tableKeywords'
									},{
										fieldLabel: me.localize('xpathCollection'),
										name: 'tableCollection'
									},{
										xtype: 'textareafield',
										grow: true,
										fieldLabel: me.localize('xpathExtra'),
										name: 'tableExtraMetadata'
									}]
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-processing' target='voyantdocs'>"+me.localize('processingOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        items: [
								{
								    xtype:'combo',
								    fieldLabel: me.localize("language"),
								    name: 'language',
								    queryMode:'local',
								    store: langArray,
								    forceSelection:true,
								    value: ''
								},{
								    xtype:'combo',
								    fieldLabel: me.localize('tokenization'),
								    name: 'tokenization',
								    queryMode:'local',
								    store:[['',me.localize('tokenizationAuto')],['wordBoundaries',me.localize("tokenizationWordBoundaries")],['whitespace',me.localize("tokenizationWhitespace")]],
								    forceSelection:true,
								    value: ''
								}
							]
						},{
	        				xtype: 'fieldset',
	                        title: "<a href='"+me.getBaseUrl()+"docs/#!/guide/corpuscreator-section-access-management' target='voyantdocs'>"+me.localize('accessOptions')+"</a>",
	                        collapsible: true,
	                        collapsed: true,
	                        defaultType: 'textfield',
	                        items: [
	                            {
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("accessOptionsText")+'</i></p>',
	    							width: 375
	                            },{
									fieldLabel: me.localize('adminPassword'),
									name: 'adminPassword'
								},{
									fieldLabel: me.localize('accessPassword'),
									name: 'accessPassword'
								},{
	    							xtype: 'container',
	    							html: '<p><i>'+me.localize("accessModeWithoutPasswordText")+'</i></p>',
	    							width: 375
	                            },{
								    xtype:'combo',
									fieldLabel: me.localize('accessModeWithoutPassword'),
								    name: 'noPasswordAccess',
								    queryMode:'local',
								    store:[['',me.localize('accessModeNonConsumptive')],['none',me.localize("accessModeNone")]],
								    forceSelection:true,
								    value: ''
								}
							]
						}
						
					]
    			}],
    			buttons: [{
    				text: me.localize('ok'),
    				handler: function(button, event) {
    					var win = button.findParentByType('window');
    					var form = win.down('form');
    					if (form.isValid()) {
        					var params = form.getValues();
        					me.setApiParams(params);
        					win.hide();
    					}
    					else {
    						me.showError({
    							message: me.localize("invalidForm")
    						})
    					}
    				}
    			},{
    				text: me.localize('cancel'),
    				handler: function(button, event) {
    					button.findParentByType('window').hide();
    				}
    			}]
    		});
    	}
    	me.optionsWin.showAt((me.getApplication().getViewport().getWidth()/2)-200,10);
    },
    
    validatePositiveNumbersCsv: function(val) {
    	val = val.trim();
    	if (val.length>0) {
        	if (/[^\d,+ ]/.test(val)) {
        		return this.localize("numbersCommasOnly");
        	}
        	if (/\d\s+\d/.test(val)) {
        		return this.localize("numbersNeedCommas");
        	}
        	var numbers = val.split(/\s*[,+]\s*/), number;
        	for (var i=0, len=numbers.length; i<len; i++) {
        		number = numbers[i];
        		if (number.length==0) {
        			return this.localize("numberEmpty")
        		}
        		if (parseInt(number)==0) {
        			return this.localize("numberZero")
        		}
        	}
    	}
    	return true;
	}
    
});
Ext.define('Voyant.panel.DreamScape', {
    extend: 'Ext.Panel',
    xtype: 'dreamscape',
    mixins: ['Voyant.panel.Panel'],
    statics: {
        i18n: {
        },
        api: {
            stopList: 'auto',
            hide: [],
            author: undefined,
            title: undefined,
            keyword: undefined,
            pubDate: undefined,
            citiesMaxCount: 500,
            minPopulation: 10000,
            citiesMinFreq: 1,
            connectionsMaxCount: 2500,
            connectionsMinFreq: 1,
            millisPerAnimation: 2000,
            annotationsId: undefined,
            source: undefined,
            overridesId: undefined,
            filterHasLowerCaseForm: true,
            filterIsPersonName: true,
            preferredCoordinates: undefined
        },
        glyph: 'xf124@FontAwesome'
    },
    config: {
        map: undefined, // OL object, should be set during init
        overlay: undefined, // OL object, should be set during init
        contentEl: undefined, // EXTJS Element, where info is shown
        isOpenLayersLoaded: false,
        isArcLoaded: false,
        animationDelay: 25, // determines the delay between animation calls
        isProj4Loaded: false,
        projection: undefined,
        filterWidgets: new Ext.util.MixedCollection(),
        drawInteraction: undefined,
        drawMode: false,
        //currentAnnotation: undefined,
        baseLayers: {},
        annotations: undefined, // set during init if any values are stored, shouldn't be looked up (getAnnotations) after init
        annotationsLoadedIfAvailable: false, // check api and local storage,
        overrides: {}
    },

    html: '<div class="map"></div><div class="ticker"></div>',

    cls: 'dreamscape',

    constructor: function(config) {
        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        Ext.Loader.loadScript({
            url: this.getBaseUrl()+"resources/openlayers/ol.js",
            onLoad: function() {
                // Utility function to get layer by id
                if (ol.Map.prototype.getLayer === undefined) {
                    ol.Map.prototype.getLayer = function (id) {
                        var layer = undefined;
                        this.getLayers().forEach(function(lyr) {
                            if (id === lyr.get('id')) {
                                layer = lyr;
                            }
                        });
                        return layer;
                    }
                }
                this.setIsOpenLayersLoaded(true);
            },
            scope: this
        });
        Ext.Loader.loadScript({
            url: this.getBaseUrl()+"resources/dreamscape/arc.js",
            onLoad: function() {
                this.setIsArcLoaded(true);
            },
            scope: this
        });
        Ext.Loader.loadScript({
            url: "https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.4.4/proj4.js",
            onLoad: function() {
                this.setIsProj4Loaded(true);
            },
            scope: this
        });
        var annotationsId = this.getApiParam("annotationsId");
        if (annotationsId) {
            var me = this;
            Ext.Ajax.request({
                url: this.getTromboneUrl(),
                params: {
                    tool: 'resource.StoredResource',
                    retrieveResourceId: annotationsId
                },
                scope: this
            }).then(function(response) {
                var data = Ext.JSON.decode(response.responseText);
                if (data.storedResource.resource) {
                    var annotations = Ext.JSON.decode(data.storedResource.resource)
                    if (Ext.isString(annotations)) {
                        annotations = Ext.JSON.decode(annotations);
                        me.setAnnotations(annotations)
                    }
                }
                if (!me.getAnnotations()) {
                    me.showError(me.localize("annotationsLoadFailed"));
                }
                me.setAnnotationsLoadedIfAvailable(true);
            }, function(response) {
                me.showResponseError(me.localize("annotationsLoadFailed"), response);
                me.setAnnotationsLoadedIfAvailable(true);
            });
        } else {
            this.setAnnotationsLoadedIfAvailable(true);
        }
    },
    initComponent: function() {
        var me = this;
        this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
        var hide = this.getApiParam("hide");
        if (Ext.isString(hide)) {
            hide = hide.split(',');
            this.setApiParam('hide');
        }
        var iconBase = this.getApplication().getBaseUrl()+"resources/dreamscape/";
        Ext.apply(this, {
            title: this.localize('title'),
            bodyBorder: true,
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                itemId: 'bottomToolbar',
                overflowHandler: 'scroller',
                items: [
                    {
                        text: this.localize('display'),
                        tooltip: this.localize('displayTip'),
                        glyph: 'xf013@FontAwesome',
                        menu: {
                            defaults: { // these are intended for the radiogroups after the separator (and should be ignored by the menu items above the separator)
                                xtype: 'menucheckitem',
                                checkHandler: function(item, checked) {
                                    var map = this.getMap(), id = item.getItemId();
                                    this.getFilterWidgets().each(function(filter) {
                                        map.getLayer(filter.getId()+"-"+id).setVisible(checked);
                                    })
                                    var hide = Ext.Array.from(this.getApiParam('hide'));
                                    if (checked) {
                                        hide = Ext.Array.remove(hide, id);
                                    } else {
                                        hide.push(id);
                                        hide = Ext.Array.unique(hide);
                                    }
                                    this.setApiParam("hide", hide);
                                    item.getMenu().setDisabled(checked==false);
                                },
                                scope: this,
                                checked: true
                            },
                            items: [{
                                xtype: 'menuitem',
                                text: this.localize('baseLayer'),
                                tooltip: this.localize('baseLayerTip'),
                                glyph: 'xf279@FontAwesome',
                                menu: {
                                    items: [{
                                        xtype: 'radiogroup',
                                        columns: 1,
                                        vertical: true,
                                        defaults: {
                                            cls: 'map-menu-item',
                                            handler: function(item, checked) {
                                                if(checked){
                                                    var panel = this;
                                                    id = item.getItemId();
                                                    var layer = this.getBaseLayers()[id];
                                                    if (layer) {
                                                        layer.setOpacity(1);
                                                        this.getMap().getLayers().setAt(0, layer);
                                                    }
                                                    if(id == 'osm' || id == 'arcGIS') {
                                                        this.getMap().getLayer("overlayLayer").setVisible(false);
                                                    } else {
                                                        this.getMap().getLayer("overlayLayer").setVisible(true);
                                                    }
                                                }
                                            },
                                            listeners: {
                                                afterrender: function(item) {
                                                    Ext.create('Ext.tip.ToolTip', {
                                                        target: item,
                                                        html: '<div class="map-menu-item-tooltip '+item.getItemId()+'"></div>',
                                                        anchor: 'right'
                                                    });
                                                }
                                            },
                                            scope: this
                                        },
                                        items: [
                                            // {
                                            //     boxLabel: this.localize('watercolor'),
                                            //     itemId: 'watercolor',
                                            //     cls: ['map-menu-item','watercolor'],
                                            //     checked: true
                                            // },
                                            {
                                                boxLabel: this.localize('wms4326'),
                                                cls: ['map-menu-item','wms4326'],
                                                itemId: 'wms4326'
                                            },{
                                                boxLabel: this.localize('osm'),
                                                cls: ['map-menu-item','osm'],
                                                itemId: 'osm',
                                                checked: true
                                            },{
                                                boxLabel: this.localize('arcGIS'),
                                                cls: ['map-menu-item','arcGIS'],
                                                itemId: 'arcGIS'
                                            }
                                        ]
                                    }]
                                }
                            },{
                                xtype: 'menuitem',
                                text: this.localize('projection'),
                                tooltip: this.localize('projectionTip'),
                                glyph: 'xf0ac@FontAwesome',
                                menu: {
                                    items: [{
                                        xtype: 'radiogroup',
                                        columns: 1,
                                        vertical: true,
                                        defaults: {
                                            handler: function(item, checked) {
                                                if(checked){
                                                    var panel = this;
                                                    id = item.getItemId();
                                                    var view = undefined
                                                    if (id === "webMercatorProjection") {
                                                        this.setProjection(ol.proj.get('EPSG:3857'));
                                                    } else if (id === "mercatorProjection") {
                                                        this.setProjection(ol.proj.get('EPSG:4326'));
                                                    } else if (id === "gallPetersProjection") {
                                                        proj4.defs('cea',"+proj=cea +lon_0=0 +lat_ts=45 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs");
                                                        var gallPetersProjection = ol.proj.get('cea');
                                                        this.setProjection(gallPetersProjection);
                                                    } else if (id === "sphereMollweideProjection") {
                                                        proj4.defs('ESRI:54009', '+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs');
                                                        var sphereMollweideProjection = ol.proj.get('ESRI:54009');
                                                        sphereMollweideProjection.setExtent([-18e6, -9e6, 18e6, 9e6]);
                                                        this.setProjection(sphereMollweideProjection);
                                                    }
                                                    var newProjExtent = this.getProjection().getExtent();
                                                    // If using Mercator projection, earth with is measured in degrees, otherwise it's in meters
                                                    var earthWidth = this.getProjection() == ol.proj.get("EPSG:4326") ? 360 : 40075016.68557849;
                                                    var newView = new ol.View({
                                                        projection: this.getProjection(),
                                                        center: ol.extent.getCenter(newProjExtent || [0, 0, 0, 0]),
                                                        maxResolution: earthWidth / panel.body.dom.offsetWidth,
                                                        zoom: 0
                                                    });
                                                    var map = this.getMap();
                                                    var layers = map.getLayers();
                                                    layers.forEach(function(layer) {
                                                        if(layer.getSource().getFeatures){
                                                            var features = layer.getSource().getFeatures();
                                                            features.forEach(function(feature){
                                                                var newGeometry = feature.getGeometry().transform(map.getView().getProjection(), panel.getProjection());
                                                                feature.setGeometry(newGeometry);
                                                            })
                                                        }
                                                    });

                                                    map.setView(newView);
                                                }
                                            },
                                            listeners: {
                                                afterrender: function(item) {
                                                    Ext.create('Ext.tip.ToolTip', {
                                                        target: item,
                                                        html: '<div class="map-menu-item-tooltip '+item.getItemId()+'"></div>',
                                                        anchor: 'right'
                                                    });
                                                }
                                            },
                                            scope: this
                                        },
                                        items: [
                                            {
                                                boxLabel: this.localize('webMercatorProjection'),
                                                itemId: 'webMercatorProjection',
                                                cls: ['map-menu-item','webMercatorProjection'],
                                                checked: true
                                            },{
                                                boxLabel: this.localize('mercatorProjection'),
                                                cls: ['map-menu-item','mercatorProjection'],
                                                itemId: 'mercatorProjection'
                                            },{
                                                boxLabel: this.localize('gallPetersProjection'),
                                                cls: ['map-menu-item','gallPetersProjection'],
                                                itemId: 'gallPetersProjection'
                                            },{
                                                boxLabel: this.localize('sphereMollweideProjection'),
                                                cls: ['map-menu-item','sphereMollweideProjection'],
                                                itemId: 'sphereMollweideProjection'
                                            }
                                        ]
                                    }]

                                }
                            },'-',{
                                text: this.localize('cities'),
                                checked: Ext.Array.contains(hide, "cities")==false,
                                itemId: 'cities',
                                menu: {
                                    defaults: {
                                        labelAlign: 'right',
                                        labelWidth: 140
                                    },
                                    items: [{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('citiesMaxCount'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('citiesMaxCount')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('citiesMaxCount', newVal);
                                                    var currentCitiesCount = filter.getGeonames().getCitiesCount();
                                                    if (newVal<oldVal || newVal<=currentCitiesCount) {
                                                        this.filterUpdate(filter);
                                                    } else if (filter.getGeonames().hasMoreCities()) {
                                                        filter.loadGeonames()
                                                    } else {
                                                        cmp.setValue(currentCitiesCount); // will call change
                                                        this.toastInfo(new Ext.XTemplate(this.localize("allNCitiesShown")).apply([currentCitiesCount]))
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    },{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('citiesMinPopulation'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('minPopulation')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.setApiParam('minPopulation', newVal);
                                                this.getFilterWidgets().each(function(filter) {
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    },{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('citiesMinFreq'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('citiesMinFreq')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('citiesMinFreq', newVal);
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    }]
                                }
                            },{
                                text: this.localize('connections'),
                                checked: Ext.Array.contains(hide, "connections")==false,
                                itemId: 'connections',
                                menu: {
                                    defaults: {
                                        labelWidth: 140,
                                        labelAlign: 'right'
                                    },
                                    items: [{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('connectionsMaxCount'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('connectionsMaxCount')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('connectionsMaxCount', newVal);
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    },{
                                        xtype: 'numberfield',
                                        fieldLabel: this.localize('connectionsMinFreq'),
                                        minValue: 1,
                                        value: parseInt(this.getApiParam('connectionsMinFreq')),
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    this.setApiParam('connectionsMinFreq', newVal);
                                                    if (newVal>oldVal) {
                                                        this.filterUpdate(filter);
                                                    } else {
                                                        filter.loadGeonames()
                                                    }
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    }]
                                }

                            },{
                                xtype: 'menucheckitem',
                                checked: Ext.Array.contains(hide, "animation")==false,
                                text: this.localize('animations'),
                                itemId: 'animation',
                                menu: {
                                    defaults: {
                                        labelWidth: 170,
                                        labelAlign: 'right',
                                        width: 280
                                    },
                                    items: [{
                                        xtype: 'sliderfield',
                                        fieldLabel: this.localize('millisPerAnimation'),
                                        value: parseInt(this.getApiParam('millisPerAnimation')),
                                        minValue: this.getAnimationDelay(),
                                        maxValue: 10000,
                                        listeners: {
                                            change: function(cmp, newVal, oldVal) {
                                                this.getFilterWidgets().each(function(filter) {
                                                    filter.setMillisPerAnimation(newVal);
                                                    filter.animate();
                                                }, this);
                                            },
                                            scope: this
                                        }
                                    }]
                                }
                            }]
                        }
                    }, '-', {
                        text: this.localize('add'),
                        itemId: 'addFilter',
                        glyph: 'xf067@FontAwesome',
                        handler: function(cmp) {
                            var colors = this.getApplication().getColorPalette(this.getApiParam('palette'), true),
                                color = colors[0]; // default to first

                            // find an available color
                            for (var i=0, len=colors.length; i<len; i++) {
                                var hasMatch = false;
                                this.getFilterWidgets().each(function(filter) {
                                    if (filter.getColor()==colors[i]) {
                                        hasMatch = true;
                                        return false;
                                    }
                                })
                                if (hasMatch==false) {
                                    color = colors[i];
                                    break;
                                }
                            }
                            var filter = cmp.ownerCt.add({
                                xtype: 'geonamesfilter',
                                corpus: this.getCorpus(),
                                color: color,
                                listeners: {
                                    removeFilterWidget: function(filter) {
                                        var map = this.getMap(), id = filter.getItemId(), filters = this.getFilterWidgets();
                                        ["connections","cities","animation"].forEach(function(layer) {
                                            map.removeLayer(map.getLayer(id+"-"+layer));
                                        })
                                        filters.remove(filter);
                                        if (filters.getCount()==0) { // we always want at least one filter
                                            // simulate adding a filter
                                            this.getDockedComponent('bottomToolbar').getComponent('addFilter').click();
                                        }
                                    },
                                    filterUpdate: this.filterUpdate,
                                    scope: this
                                }
                            })
                            this.getFilterWidgets().add(filter.getId(), filter);

                            var map = this.getMap();

                            var connectionsLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    wrapX: false,
                                    useSpatialIndex: true // needed to call getExtent()
                                }),
                                id: filter.getId()+"-connections",
                                visible: true,
                                opacity: 0.2,
                                style: this.travelStyleFunction.bind(this),
                                updateWhileAnimating: true, // optional, for instant visual feedback
                                updateWhileInteracting: true // optional, for instant visual feedback
                            });
                            map.addLayer(connectionsLayer);

                            var citiesLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    wrapX: false,
                                    useSpatialIndex: true // needed to call getExtent()
                                }),
                                id: filter.getId()+"-cities",
                                opacity: 0.5,
                                style: this.cityStyleFunction.bind(this)
                            });
                            map.addLayer(citiesLayer);

                            var animationLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    wrapX: false,
                                    useSpatialIndex: true // needed to call getExtent()
                                }),
                                id: filter.getId()+"-animation",
                                style:  this.animationStyleFunction.bind(this)
                            });
                            map.addLayer(animationLayer);
                        },
                        scope: this
                    }]
            }]
        });

        this.on("loadedCorpus", function(src, corpus) {
            this.tryInit();
        }, this);

        this.callParent();
    },

    tryInit: function() {
        if (this.getIsOpenLayersLoaded() && this.getIsArcLoaded() && this.getIsProj4Loaded() && this.getAnnotationsLoadedIfAvailable()) {
            var el = this.body.down('.map').setId(Ext.id());
            /*
            var overlayEl = this.body.down('.ol-popup');
            var overlay = new ol.Overlay({
                element: overlayEl.dom,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                }
            });
            this.setOverlay(overlay);
            */
            var panel = this;
            // Add a click handler to hide the popup
            /*
            var closer = overlayEl.down(".ol-popup-closer").dom;
            closer.onclick = function() {
                overlay.setPosition(undefined);
                closer.blur();
                panel.getMap().getLayer("preview").getSource().clear();

//                if(panel.getDrawMode()) {
//                    panel.getDockedComponent('bottomToolbar').getComponent('annotate').click();
//                }
                return false;
            };
            */

            var baseLayers = this.getBaseLayers();
            baseLayers['osm'] = new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.OSM({
                    projection: "EPSG:3857"
                })
            });

            baseLayers['wms4326'] = new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.TileWMS({
                    url: 'https://ahocevar.com/geoserver/wms',
                    crossOrigin: '',
                    params: {
                        'LAYERS': 'ne:NE1_HR_LC_SR_W_DR',
                        'TILED': true
                    },
                    projection: 'EPSG:4326'
                })
            });

            // baseLayers['watercolor'] =  new ol.layer.Tile({
            //     preload: Infinity,
            //     source: new ol.source.Stamen({
            //         //cacheSize: 2048,
            //         layer: 'watercolor',
            //         projection: "EPSG:3857"
            //     })
            // });

            baseLayers['arcGIS'] = new ol.layer.Tile({
                preload: Infinity,
                source: new ol.source.TileArcGISRest({
                    url: "https://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer",
                    projection: "EPSG:3857"
                })
            });

//            this.setContentEl(overlayEl.down('.popup-content'));
            var map = new ol.Map({
                layers: [
                    baseLayers['osm'],

                    // new ol.layer.Tile({
                    //     preload: Infinity,
                    //     source: new ol.source.Stamen({
                    //         cacheize: 2048,
                    //         layer: 'toner-hybrid',
                    //         projection: "EPSG:3857"
                    //     }),
                    //     id: 'overlayLayer'
                    // })
                ],
//                overlays: [overlay],
                target: el.getId(),
                loadTilesWhileInteracting: true,
                view: new ol.View({
                    center: [0, 0],
                    maxResolution: 40075016.68557849 / panel.body.dom.offsetWidth,
                    zoom: 0
                })
            });

            map.on('singleclick', this.handleSingleClick, this);
            // Add a click handler to the map to render the popup
            map.on('singleclicking', function(event) {
                var pixel = event.pixel;
                var features = map.getFeaturesAtPixel(pixel);
                if (features) {
                		for (var i=0; i<features.length; i++) {
                			var feature = features[i];
                			if (feature.get("type")=='city') {
                				this.handleLocationClick(feature);
                			}
                		}
                		var feature = features[0];
                		debugger
                }
                
                if(features) {
                    var foundFeature = false;
                    features.forEach( function(feature) {
                        if( feature.get("type") === "city" && feature.get("selected")) { // city
                            panel.dispatchEvent("termsClicked", panel, [feature.get("forms").join("|")])
                            foundFeature = true;
                        } else if (feature.get("type") === "connection" && feature.get("selected") && !foundFeature) { // connection
                            panel.getFilterWidgets().each(function (filter) {
                                var geonames = filter.getGeonames();
                                if (geonames != null) {
                                    var occurrences = geonames.getAllConnectionOccurrences(feature.get("source"), feature.get("target"));
                                    var infos = "<ul>";
                                    var docIndex = -1;
                                    occurrences.forEach(function(occ) {
                                        if(occ.docIndex != docIndex) {
                                            docIndex = occ.docIndex;
                                            infos += '<h4>' + panel.getCorpus().getDocument(docIndex).getFullLabel() + ':</h4>';
                                        }
                                        infos += '<li>'+ occ.source.left+'<a href="http://www.geonames.org/' + occ.source.id + '" target="_blank" docIndex='+occ.docIndex +' offset='+occ.source.position+
                                            ' location='+occ.source.form + ' cityId=' + occ.source.id + ' coordinates=' + JSON.stringify(sourceCoordinates) + ' class="termLocationLink">' + occ.source.form + '</a> '+occ.source.right + ' [...] ' +
                                            occ.target.left+'<a href="http://www.geonames.org/' + occ.target.id + '" target="_blank" docIndex='+occ.docIndex+' offset='+occ.target.position+
                                            ' location='+occ.target.form+ ' cityId=' + occ.target.id + ' coordinates=' + JSON.stringify(targetCoordinates) + ' class="termLocationLink">' + occ.target.form + '</a> '+occ.target.right + '</li>';
                                    });
                                    var header = feature.get("text");
                                    infos += "</ul>";
                                    panel.getContentEl().setHtml('<h3>' + header + '</h3>' + infos);
                                    panel.getOverlay().setPosition(event.coordinate);
                                    var links = Ext.select('.termLocationLink');

//                                    function contextMenuListener(el) {
//                                        el.addEventListener( "contextmenu", function(e) {
//                                            e.preventDefault();
//                                            panel.openContextMenu(e.layerX, e.layerY, el);
//                                            return false;
//                                        }, false);
//                                    }

                                    links.elements.forEach(function(link) {
//                                        contextMenuListener(link);
                                        link.onmouseover = function(){panel.showTermInCorpus(link.getAttribute("docIndex"), link.getAttribute("offset"), link.getAttribute('location'))};
                                    });
                                }
                            });
                            foundFeature = true
                        } /*else if (feature.get("type") === "annotation" && !foundFeature) { //annotation
                            panel.setCurrentAnnotation(feature);
                            panel.getContentEl().setHtml('<textarea class="annotation-text" rows="5" cols="60">'+(feature.get("text")?feature.get("text"):"")+'</textarea>' +
                                '<button class="saveAnnotation">Save</button><button class="deleteAnnotation">Delete</button>');
                            panel.getOverlay().setPosition(event.coordinate);
                            panel.getContentEl().down('.deleteAnnotation').dom.onclick = function() {panel.deleteAnnotation()};
                            panel.getContentEl().down('.saveAnnotation').dom.onclick = function() {panel.saveAnnotation()};
                            panel.getContentEl().down('.annotation-text').dom.focus();
                        } */
                    }, this);
                }
            });

            // Layer for selected vector
            var selectedLayer = new ol.layer.Vector({
                map: map,
                source: new ol.source.Vector({
                    wrapX: false,
                    useSpatialIndex: false // optional, might improve performance
                }),
                zIndex: 10,
                selected: true,
                style: function(feature) {
                    if(feature.get("type") === "city")
                    {
                        return panel.cityStyleFunction(feature, map.getView().getResolution());
                    } else if(feature.get("type") === "connection") {
                        return panel.travelStyleFunction(feature, map.getView().getResolution());
                    }
                },
                updateWhileAnimating: true, // optional, for instant visual feedback
                updateWhileInteracting: true // optional, for instant visual feedback
            });

            // Layer for edit preview
            var previewLayer = new ol.layer.Vector({
                map: map,
                source: new ol.source.Vector({
                    wrapX: false,
                    useSpatialIndex: false // optional, might improve performance
                }),
                preview: true,
                zIndex: 15,
                id: "preview",
                style: function(feature) {
                    if(feature.get("type") === "city")
                    {
                        return panel.cityStyleFunction(feature, map.getView().getResolution());
                    } else if(feature.get("type") === "connection") {
                        return panel.travelStyleFunction(feature, map.getView().getResolution());
                    }
                },
                updateWhileAnimating: true, // optional, for instant visual feedback
                updateWhileInteracting: true // optional, for instant visual feedback
            });
            map.addLayer(previewLayer);

            // Add handler to update selected vector when mouse is moved
            map.on('pointermove', function(event) {
            	
            	// set cursoe to pointer if we have a feature
            	  var pixel = map.getEventPixel(event.originalEvent);
            	  var hit = map.hasFeatureAtPixel(pixel);
            	  map.getViewport().style.cursor = hit ? 'pointer' : '';
            	  
                if(!panel.getDrawMode()) {
                    selectedLayer.getSource().clear();
                    var coordinate = event.coordinate;
                    var pixel = event.pixel;
                    var features = map.getFeaturesAtPixel(pixel);
                    if(features) {
                        var i = 0;
                        while(features[i].get("selected")){
                            i++;
                            if (i === features.length) break;
                        }
                        if (i < features.length) {
                            var feature = features[i];

                            var baseTextStyle = {
                                font: '12px Calibri,sans-serif',
                                textAlign: 'center',
                                offsetY: -15,
                                fill: new ol.style.Fill({
                                    color: [0,0,0,1]
                                }),
                                stroke: new ol.style.Stroke({
                                    color: [255,255,255,0.5],
                                    width: 4
                                })
                            };

                            baseTextStyle.text = feature.get("text");

                            var textOverlayStyle = new ol.style.Style({
                                text: new ol.style.Text(baseTextStyle),
                                zIndex: 1
                            });

                            if (!(feature.get("type") === "annotation")) {
                                var selectedFeature = new ol.Feature({
                                    text: feature.get("text"),
                                    geometry: feature.getGeometry(),
                                    forms: feature.get("forms"),
                                    selected: true,
                                    coordinates: feature.get("coordinates"),
                                    width: feature.get("width"),
                                    visible: feature.get("visible"),
                                    color: feature.get("color"),
                                    type: feature.get("type"),
                                    confidence: feature.get("confidence"),
                                    source: feature.get("source"),
                                    target: feature.get("target"),
                                    cityId: feature.get("cityId")
                                });
                                selectedLayer.getSource().addFeature(selectedFeature);
                            }
                            var geometry = feature.getGeometry();
                            var point = event.coordinate;
                            var textFeature = new ol.Feature({
                                geometry: new ol.geom.Point(point),
                                selected: true
                            });
                            textFeature.setStyle(textOverlayStyle);
                            selectedLayer.getSource().addFeature(textFeature);

                            // Highlight all connection where selected city is source or target

                            if(feature.get("type") === "city") {
                                var layers = panel.getMap().getLayers();
                                layers.forEach(function (layer) {
                                    var layerId = layer.get("id");
                                    if (layerId && layerId.indexOf("connections") !== -1) {
                                        connections = layer.getSource().getFeatures();
                                        connections.forEach(function (connection) {
                                            if(connection.get("target") === feature.get("cityId") || connection.get("source") === feature.get("cityId")) {
                                                selectedLayer.getSource().addFeature(new ol.Feature({
                                                    geometry: connection.getGeometry(),
                                                    selected: true,
                                                    coordinates: connection.get("coordinates"),
                                                    width: connection.get("width"),
                                                    visible: connection.get("visible"),
                                                    color: connection.get("color"),
                                                    type: connection.get("type")
                                                }));
                                            }
                                        })
                                    }
                                })
                            }
                        }
                    }
                }
            });
            var source = new ol.source.Vector({wrapX: false});

            var annotations = new ol.layer.Vector({
                source: source,
                id: "annotations"
            });

            var annotationsObj = this.getAnnotations();
            if (annotationsObj) {
                var geojson = new ol.format.GeoJSON();
                var features = geojson.readFeatures(annotationsObj);
                source.addFeatures(features);
            }

            map.addLayer(annotations);

            this.setDrawInteraction(
                new ol.interaction.Draw({
                    source: source,
                    type: "Polygon",
                    freehand: true,
                    alias: "draw"
                })
            );
            this.getDrawInteraction().on('drawend', function (evt) {
                evt.feature.set('type', 'annotation');
//                panel.setCurrentAnnotation(evt.feature);
                panel.editAnnotation(evt.feature);
//                panel.getContentEl().setHtml('<textarea class="annotation-text" rows="5" cols="60"></textarea>'+
//                    '<button class="saveAnnotation">Save</button><button class="deleteAnnotation">Cancel</button>');
//                panel.getContentEl().down('.deleteAnnotation').dom.onclick = function() {panel.deleteAnnotation()};
//                panel.getContentEl().down('.saveAnnotation').dom.onclick = function() {panel.saveAnnotation()};
//                panel.getOverlay().setPosition(evt.feature.getGeometry().getLastCoordinate());
//                panel.getContentEl().down('.annotation-text').dom.focus();
            });

            /*
            map.getViewport().addEventListener('contextmenu', function (e) {
                e.preventDefault();
                panel.openContextMenu(e.layerX, e.layerY);
                return false;
            }, false);
            */

            this.setMap(map);

            var zoom = this.getTargetEl().down(".ol-zoom");
            Ext.create('Ext.Button', {
                glyph:'xf075@FontAwesome',
                cls: 'annotate',
                renderTo: this.getTargetEl().down(".ticker").parent(),
                tooltip: this.localize('annotateTip'),
                enableToggle: true,
                toggleHandler: function(cmp, state) {
                    if (state) {
                        this.getMap().addInteraction(this.getDrawInteraction());
                    } else {
                        this.getMap().removeInteraction(this.getDrawInteraction());
                    }
                },
                scope: this
            })

            // simulate adding a filter
            this.getDockedComponent('bottomToolbar').getComponent('addFilter').click();
        } else {
            Ext.defer(this.tryInit, 500, this); // try again in a half second
        }
    },
    
    editAnnotation: function(feature) {
    		var text = feature.get("text"), buttons = [];
    		Ext.Msg.show({
    			title: this.localize("editAnnotation"),
    			message: this.localize("editAnnotationMessage"),
    			buttons: Ext.Msg.OKCANCEL,
            multiline: true,
            value: text,
            scope: this,
            callback: function(btn, val) {
            		if (btn=='ok') {
            			if (val=="") {
            				this.getMap().getLayer("annotations").getSource().removeFeature(feature);
            			} else {
            				feature.set("text", val);
            			}
            	        var geojson  = new ol.format.GeoJSON;
            	        var features = this.getMap().getLayer("annotations").getSource().getFeatures();
            	        var transformedFeatures = [];
            	        var projection = this.getProjection();
            	        features.forEach(function (feature) {
            	            transformedFeature = feature.clone();
            	            transformedFeature.getGeometry().transform(projection?projection:'EPSG:3857', 'EPSG:3857');
            	            transformedFeatures.push(transformedFeature);
            	        })
            	        var json = geojson.writeFeatures(transformedFeatures);
            	        this.storeAnnotations(json);
            		}
            }
    		})

    },

    /*
    deleteAnnotation: function() {
        this.body.down('.ol-popup').down(".ol-popup-closer").dom.click();
        this.getMap().getLayer("annotations").getSource().removeFeature(this.getCurrentAnnotation());
        var geojson  = new ol.format.GeoJSON;
        var features = this.getMap().getLayer("annotations").getSource().getFeatures();
        var transformedFeatures = [];
        var projection = this.getProjection();
        features.forEach(function (feature) {
            transformedFeature = feature.clone();
            transformedFeature.getGeometry().transform(projection?projection:'EPSG:3857', 'EPSG:3857');
            transformedFeatures.push(transformedFeature);
        })
        var json = geojson.writeFeatures(transformedFeatures);
        this.storeAnnotations(json);
//        localStorage['annotations'] = JSON.stringify(json);
    },
    */

    storeAnnotations: function(json) {
        this.mask("storingAnnotations");
        var me = this;
        Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: {
                tool: 'resource.StoredResource',
                storeResource: JSON.stringify(json)
            },
            scope: this
        }).then(function(response) {
            me.unmask();
            var data = Ext.JSON.decode(response.responseText);
            me.setApiParam("annotationsId", data.storedResource.id);
            me.toastInfo(me.localize('annotationsUpdated'));
        }, function(response) {
            me.unmask();
            me.showResponseError(me.localize("annotationsUpdateFailed"), response);
        });
    },

    /*
    saveAnnotation: function() {
        this.getCurrentAnnotation().set("text", this.getContentEl().down('.annotation-text').dom.value);
        this.getOverlay().setPosition(undefined);
//        if(this.getDrawMode()) {
//            this.getDockedComponent('bottomToolbar').getComponent('annotate').click();
//        }
        var geojson  = new ol.format.GeoJSON;
        var features = this.getMap().getLayer("annotations").getSource().getFeatures();
        var transformedFeatures = [];
        var projection = this.getProjection();
        features.forEach(function (feature) {
            transformedFeature = feature.clone();
            transformedFeature.getGeometry().transform(projection?projection:'EPSG:3857', 'EPSG:3857');
            transformedFeatures.push(transformedFeature);
        })
        var json = geojson.writeFeatures(transformedFeatures);
        this.storeAnnotations(json);
//        localStorage['annotations'] = JSON.stringify(json);
    },
    */

    // Style for vector after animation
    travelStyleFunction: function(feature, resolution) {

        var stroke = new ol.style.Stroke({
            color: feature.get('color'),
            width: feature.get('width')
        });

        var styles = [
            new ol.style.Style({
                stroke: stroke
            })];

        // Add arrow at the end of vectors
        var geometry = feature.getGeometry();
        var end = geometry.getLastCoordinate();
        var beforeEnd = geometry.getCoordinateAt(0.9);
        var dx = end[0] - beforeEnd[0];
        var dy = end[1] - beforeEnd[1];
        var rotation = Math.atan2(dy, dx);

        var lineStr1 = new ol.geom.LineString([end, [end[0] - 10 * resolution, end[1] + 10 * resolution]]);
        lineStr1.rotate(rotation, end);
        var lineStr2 = new ol.geom.LineString([end, [end[0] - 10 * resolution, end[1] - 10 * resolution]]);
        lineStr2.rotate(rotation, end);

        styles.push(new ol.style.Style({
            geometry: lineStr1,
            stroke: stroke
        }));
        styles.push(new ol.style.Style({
            geometry: lineStr2,
            stroke: stroke
        }));

        return styles;
    },

    // Style for cities
    cityStyleFunction: function(feature, resolution) {
        if(feature.get("visible")) {
            var diameter = Math.PI * 2 * feature.get("width");
            var confArc = feature.get("confidence") ? diameter * feature.get("confidence") : diameter;
            return (new ol.style.Style({
                image: new ol.style.Circle({
                    radius: feature.get("width"),
                    fill: new ol.style.Fill({
                        color: feature.get("color")
                    }),
                    stroke: new ol.style.Stroke({
                        lineDash: [confArc, diameter - confArc],
                        color: 'rgb(255, 255, 255)',
                        width: 2
                    })
                })
            }));
        } else {
            return false;
        }
    },

    // Style for vector during animation
    animationStyleFunction: function (feature) {
        return [new ol.style.Style({
            stroke: new ol.style.Stroke({
                color: feature.get("color"),
                width: 5
            })
        }), new ol.style.Style({
            geometry: new ol.geom.Circle(feature.getGeometry().getFirstCoordinate()),
            stroke: new ol.style.Stroke({
                color: "white",
                width: 10
            })
        }), new ol.style.Style({
            geometry: new ol.geom.Circle(feature.getGeometry().getLastCoordinate()),
            stroke: new ol.style.Stroke({
                color: "white",
                width: 10
            })
        })];
    },

    showTermInCorpus: function(docIndex, position, location) {
        var term = Ext.create("Voyant.data.model.Context", {
            docIndex: docIndex,
            position: position,
            term: location
        });
        this.getApplication().dispatchEvent('termLocationClicked', this, [term]);
    },
   
    /**
     * Update all filters
     */
    reloadFilters: function() {
        this.getFilterWidgets().each(function(filter) {
        		filter.loadGeonames();
        }, this);
    },

    filterUpdate: function(filter) {
        var panel = this;
        filter.clearAnimation();

        var map = this.getMap(), color = filter.getColor();

        var citiesMaxCount = parseInt(this.getApiParam("citiesMaxCount"));

        // determine max rawFreq for sizing
        var max = 0;
        filter.getGeonames().eachCity(function(city) {if (city.rawFreq>max) {max=city.rawFreq;}}, this, citiesMaxCount);

        // generate cities
        var layerSource = map.getLayer(filter.getId()+"-cities").getSource();

        var hide = Ext.Array.from(this.getApiParam("hide"));

        layerSource.clear();
        var minPopulation = parseInt(this.getApiParam("minPopulation"));
        var citiesMinFreq = parseInt(this.getApiParam("citiesMinFreq"));
        var validCitiesHash = {};

        filter.getGeonames().eachCity(function(city) {

            if ((!minPopulation || city.population>=minPopulation) && (!citiesMinFreq || city.rawFreq>=citiesMinFreq)) {
                validCitiesHash[city.id]=true;
                var coordinates = [parseFloat(city.lng), parseFloat(city.lat)]
                var feature = new ol.Feature({

                    geometry: new ol.geom.Point(coordinates).transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857')),
                    text: city.label + " ("+city.rawFreq+")",
                    description: city.label,
                    color: color,
                    selected: false,
                    width: 3+ (Math.sqrt(city.rawFreq/max)*20),
                    visible: true,
                    coordinates: coordinates,
                    forms: city.forms,
                    cityId: city.id,
                    type: "city",
                    confidence: city.confidence ? city.confidence*100 : undefined
                });
                layerSource.addFeature(feature);
            }
        }, this, citiesMaxCount);

        if (layerSource.getFeatures().length>0) {
            map.getView().fit(layerSource.getExtent());
        }

        map.getLayer(filter.getId()+"-cities").setVisible(Ext.Array.contains(hide, "cities")==false);

        layerSource = map.getLayer(filter.getId()+"-connections").getSource();
        layerSource.clear();

        if (Object.keys(validCitiesHash).length==0) {
            this.toastInfo("No cities available for current criteria.");
        }

        max = 0;
        filter.getGeonames().eachConnection(function(connection) {
            if (connection.rawFreq>max) {max=connection.rawFreq;}
        }, this);

        // we'll go through all collections to see if we have valid cities
        var counter = 0,
            maxConnectionsCount = parseInt(this.getApiParam('connectionsMaxCount')),
            connectionsMinFreq = parseInt(this.getApiParam('connectionsMinFreq'));
        filter.getGeonames().eachConnection(function(connection) {
            if ((!connectionsMinFreq || connection.rawFreq>=connectionsMinFreq) && (!maxConnectionsCount || counter<maxConnectionsCount) && connection.source.id in validCitiesHash && connection.target.id in validCitiesHash && (!minPopulation || (connection.source.population>=minPopulation && connection.target.population>=minPopulation))) {
                var arcGenerator = new arc.GreatCircle(
                    {x: connection.source.lng, y: connection.source.lat},
                    {x: connection.target.lng, y: connection.target.lat});
                var arcLine = arcGenerator.Arc(100, {offset: 100});
                var label = connection.source.label+" -> "+connection.target.label + " ("+connection.rawFreq+")"
                arcLine.geometries.forEach(function(geometry) {
                    var line = new ol.geom.LineString(geometry.coords);
                    line.transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857'));
                    var feature = new ol.Feature({
                        geometry: line,
                        text: label,
                        color: color,
                        width: 3+ (Math.sqrt(connection.rawFreq/max)*10),
                        source: connection.source.id,
                        target: connection.target.id,
                        type: "connection"
                    });
                    layerSource.addFeature(feature);
                }, this);
                counter++;
            }
        }, this);

        map.getLayer(filter.getId()+"-connections").setVisible(Ext.Array.contains(hide, "connections")==false)

        filter.animate();

    },
    
    handleSingleClick: function(event) {
        var features = this.getMap().getFeaturesAtPixel(event.pixel);
        if (features) {
        		for (var i=0; i<features.length; i++) {
        			var feature = features[i];
        			var featureType = feature.get("type")
        			if (featureType=='city') {
        				this.handleLocationClick(event, feature);
        				break;
        			} else if (featureType=="connection") {
        				this.handleConnectionClick(feature, event.pixel[0], event.pixel[1]);
        				break;
        			}else if (featureType=="annotation") {
        				this.editAnnotation(feature);
        				break;
        			}
        		}
        }

    },
    
    handleConnectionClick: function(feature, x, y) {
		Ext.create('Ext.menu.Menu', {
			items: [{
    				text: this.localize("viewConnections"),
    				tooltip: this.localize("viewConnectionsTip"),
    				glyph: 'xf02d@FontAwesome',
    				handler: function() {
    					this.mask("loadingConnections");
    					var me = this;
    		            Ext.Ajax.request({
    		                url: this.getTromboneUrl(),
    		                params: {
    		                    tool: 'corpus.Dreamscape',
    		                    corpus: this.getCorpus().getId(),
    		                    suppressLocations: true,
    		                    suppressConnections: true,
    		                    sourceId: feature.get("source"),
    		                    targetId: feature.get("target"),
    		                    context: 2,
    		                    limit: 25
    		                },
    		                scope: this
    		            }).then(function(response) {
	                		me.unmask();
    		                var data = Ext.JSON.decode(response.responseText);
    		                if (data && data.dreamscape && data.dreamscape.connectionOccurrences) {
    		                		var out = "<table style='font-size:smaller'>";
    		                		data.dreamscape.connectionOccurrences.connectionOccurrences.forEach(function(occurrence) {
    		                			out+="<tr><td style='text-align: right'>"+occurrence.source.left+"</td><td class='keyword' style='text-align: center'>"+
    		                				occurrence.source.term+"</td><td>"+occurrence.source.right+"</td><td>…</td><td style='text-align: right'>"+occurrence.target.left+"</td><td class='keyword' style='text-align: center'>"+
    		                				occurrence.target.term+"</td><td>"+occurrence.target.right+"</td></tr>";
    		                		})
    		                		out += "</table>";
    		                		Ext.Msg.alert(me.localize("occurrences"), out);
    		                }
    		            }, function(response) {
	                		me.unmask();
                			return me.showError(me.localize("occurrencesNotLoaded"))	    		                			
    		            });
    				},
    				scope: this
				}]
		}).showAt(x, y)
    },
    
    
    handleLocationClick: function(event, feature) {
		var currentGeonameId = feature.get("cityId");
		var e = Ext.create('Ext.menu.Menu', {
			items: [{
    				text: this.localize("viewOccurrences"),
    				tooltip: this.localize("viewOccurrencesTip"),
    				glyph: 'xf02d@FontAwesome',
    				handler: function() {
    					this.mask("loadingOccurrences");
    					var me = this;
    		            Ext.Ajax.request({
    		                url: this.getTromboneUrl(),
    		                params: {
    		                    tool: 'corpus.Dreamscape',
    		                    corpus: this.getCorpus().getId(),
    		                    suppressLocations: true,
    		                    suppressConnections: true,
    		                    suppressConnectionOccurrences: true,
    		                    locationId: currentGeonameId,
    		                    limit: 25
    		                },
    		                scope: this
    		            }).then(function(response) {
	                		me.unmask();
    		                var data = Ext.JSON.decode(response.responseText);
    		                if (data && data.dreamscape && data.dreamscape.occurrences) {
    		                		var out = "<table style='font-size:smaller'>";
    		                		data.dreamscape.occurrences.occurrences.forEach(function(occurrence) {
    		                			out+="<tr><td style='text-align: right'>"+occurrence.left+"</td><td class='keyword' style='text-align: center'>"+occurrence.term+"</td><td>"+occurrence.right+"</td></tr>";
    		                		})
    		                		out += "</table>";
    		                		Ext.Msg.alert(me.localize("occurrences"), out);
    		                }
    		            }, function(response) {
	                		me.unmask();
                			return me.showError(me.localize("occurrencesNotLoaded"))	    		                			
    		            });
    				},
    				scope: this
				},{
    				text: this.localize("openInVoyant"),
    				tooltip: this.localize("openInVoyantTip"),
    				glyph: 'xf08e@FontAwesome',
    				handler: function() {
    					this.dispatchEvent('termsClicked', this, feature.get("forms"));
    				},
    				scope: this
				},{
    				text: this.localize("editLocation"),
    				tooltip: this.localize("editLocationTip"),
    				glyph: 'xf124@FontAwesome',
    				handler: function() {
    					this.mask("loadingAlternatives");
    					var me = this;
    		            Ext.Ajax.request({
    		                url: this.getTromboneUrl(),
    		                params: {
    		                    tool: 'util.Geonames',
    		                    query: feature.get("forms")
    		                },
    		                scope: this
    		            }).then(function(response) {
	                		me.unmask();
    		                var data = Ext.JSON.decode(response.responseText);
    		                if (data && data.geonames && data.geonames.locations) {
    		                		var items = []; 		 
    		                		Object.values(data.geonames.locations.locations).forEach(function(location) {
    		                			items.push({
    		                				boxLabel: location.label+" ("+location.population+")",
    		                				name: 'id',
    		                				inputValue: location.id,
    		                				checked: location.id==currentGeonameId
    		                			})
    		                		})
    		                		if (items.length==0) {
    		                			return me.showError(me.localize("editLocationNoLocationsFound"))
    		                		} else if (items.length==1 && items[0].inputValue==currentGeonameId) {
    		                			return me.showError(me.localize("editLocationNoAlternativesFound"))	    		                			
    		                		}
	    		                	Ext.create('Ext.window.Window', {
								title: me.localize("editLocation"),
								modal: true,
								items: {
									xtype: 'form',
									items: [{
								        xtype: 'radiogroup',
								        columns: 1,
								        vertical: true,
								        items: items
								    }],
									listeners: {
										afterrender: function(form) {
										},
										scope: this
									},
									buttons: [{
										text: me.localize("cancel"),
							            ui: 'default-toolbar',
						                glyph: 'xf00d@FontAwesome',
						        			flex: 1,
						        			handler: function(btn) {
						        				btn.up('window').destroy();
						        			}
									},{
										text: me.localize("confirmTitle"),
										glyph: 'xf00c@FontAwesome',
					            			flex: 1,
					            			handler: function(btn) {
					            				var newId = btn.up("form").getValues().id;
					            				if (newId && newId!=currentGeonameId) {
					    							var config = {};
					    							config[currentGeonameId] = newId;
					    							me.appendOverrides(config);
					            				}
						        				btn.up('window').destroy();
					            			}
									}]
								}
							}).show();
    		                }
    		            }, function(response) {
	                		me.unmask();
    		                me.showResponseError(me.localize("editLocationServerError"), response);

    		            });
    				},
    				scope: this
			},{
    				text: this.localize("removeLocation"),
    				tooltip: this.localize("removeLocationTip"),
    				glyph: 'xf00d@FontAwesome',
    				handler: function() {
    					Ext.Msg.confirm(
	    					this.localize("removeLocationConfirmTitle"),
	    					this.localize("removeLocationConfirm"),
	    					function(btn) {
	    						if (btn=="yes") {
	    							var config = {};
	    							config[currentGeonameId] = "";
	    							this.appendOverrides(config);
	    						}
	    					},
	    					this
    					)
    				},
    				scope: this
			}    				

			],
			listeners: {
				focusleave : function(menu) {
					menu.destroy();
				}
			}
		}).showAt(event.pixel[0], event.pixel[1])    		
    },
    
    appendOverrides: function(config, isAll) {
    		// if we have overridesId defined but we haven't loaded all IDs yet
    		if (this.getApiParam("overridesId") && !isAll) {
    			var me = this;
    			Ext.Ajax.request({
                url: this.getTromboneUrl(),
                params: {
                    tool: 'resource.StoredResource',
                    retrieveResourceId: this.getApiParam("overridesId")
                },
                scope: this
            }).then(function(response) {
                var data = Ext.JSON.decode(response.responseText);
                if (data && data.storedResource && data.storedResource.resource) {
                		var newConfig = Ext.decode(data.storedResource.resource);
                		Ext.apply(newConfig, config);
                		// call again, this time specifying that we have all
                		me.appendOverrides(newConfig, true);
                } else {
                    me.showResponseError(me.localize("overidesRetrieveError"), response);
                }
            	
            }, function(response) {
                me.showResponseError(me.localize("overidesRetrieveError"), response);
            });
    		} else {
    			var me = this;
    			Ext.Ajax.request({
                url: this.getTromboneUrl(),
                params: {
                    tool: 'resource.StoredResource',
                    storeResource: Ext.encode(config)
                },
                scope: this
            }).then(function(response) {
                var data = Ext.JSON.decode(response.responseText);
                if (data && data.storedResource && data.storedResource.id) {
                    me.setApiParam("overridesId", data.storedResource.id);
                    me.reloadFilters();
                } else {
                    me.showResponseError(me.localize("overidesRetrieveError"), response);
                }
            }, function(response) {
                me.showResponseError(me.localize("overidesStorageError"), response);
            });
    		}
    }    

});

Ext.define('Voyant.widget.GeonamesFilter', {
    extend: 'Ext.Button',
    xtype: 'geonamesfilter',
    mixins: ['Voyant.util.Localization'],
    statics: {
        i18n: {
            filter: 'Filter',
            authorLabel: 'authors',
            titleLabel: 'titles',
            keywordLabel: 'full text',
            pubDateLabel: "dates",
            loading: "Loading geographical information…",
//            loadedAll: "All available cities and connections have been loaded (see options under the <i>Show</i> menu in the toolbar).",
//            loadedSome: "Loaded {currentCitiesCount} of {totalCitiesCount} available locations and {currentConnectionsCount} of {totalConnectionsCount} available connections (see options under the <b>Show</b> menu in the toolbar).",
//            disclaimer: "Please note that geographical information is generated automatically and may be inaccurate (<a href='{url}' target='_blank'>more information</a>).</p>",
            disclaimer: "This is an experimental tool and the accuracy of the data is variable (<a href='{url}' target='_blank'>see help</a>).",
            noDataForField: "No data seems to be available for this field so it will be disabled.",
            close: "Close"
        }
    },
    config: {
        corpus: undefined, // used by querysearchfields among other things
        geonames: undefined,
        color: "#f00",
        timeout: undefined,
        currentConnectionOccurrence: undefined,
        animationLayer: undefined,
        millisPerAnimation: 2000,
        stepByStepMode: false,
        keepAnimationInFrame: false
    },
    constructor: function(config) {
        config = config || {};
        var geonames = new Voyant.data.util.Geonames({
            corpus: config.corpus
        });
        this.setGeonames(geonames);
        var me = this;
        Ext.applyIf(config,
            {
                tooltip: this.localize('filterTip'),
                style: "background-color: white; color: "+config.color,
                glyph: 'xf0b0@FontAwesome',
                menu: {
                    defaults: {
                        xtype: 'querysearchfield',
                        labelWidth: 60,
                        labelAlign: 'right',
                        width: 250,
                        maxWidth: 250,
                        padding: 2,
                        listeners: { // don't set scope to this so that load keeps the widget scope
                            change: function(cmp, vals) {
                                me.loadGeonames();
                            },
                            load: function(store, records, success, operation) {
                                if (records.length==0 && operation.getParams().query=="") {
                                    Ext.Msg.show({
                                        buttonText: {ok: me.localize('close')},
                                        icon: Ext.MessageBox.INFO,
                                        message: me.localize("noDataForField"),
                                        buttons: Ext.Msg.OK
                                    });
                                    this.disable();
                                }
                            }
                        }

                    },
                    items: [{
                        fieldLabel: this.localize('authorLabel'),
                        tokenType: 'author',
                        itemId: 'author'
                    },{
                        fieldLabel: this.localize('titleLabel'),
                        itemId: 'title',
                        tokenType: 'title'
                    },{
                        fieldLabel: this.localize('keywordLabel')
                    },{
                        xtype: 'multislider',
                        fieldLabel: this.localize('pubDateLabel'),
                        itemId: 'pubDate',
                        tokenType: 'pubDate',
                        values: [0,1],
                        hidden: true,
                        listeners: {
                            afterrender: function(cmp) {
                                this.getCorpus().getCorpusTerms().load({
                                    params: {
                                        tokenType: 'pubDate',
                                        limit: 1,
                                        sort: "TERMASC"
                                    },
                                    callback: function(records) {
                                        if (records.length==0) {
                                            // no pubDate, see if we can parse from titles
                                            var vals = [];
                                            this.getCorpus().each(function(doc) {
                                                var val = parseInt(doc.getTitle());
                                                if (isNaN(val)==false) {
                                                    vals.push(parseInt(doc.getTitle()))
                                                }
                                            }, this);
                                            if (vals.length>1) {
                                                cmp.setMinValue(vals[0]);
                                                cmp.setMaxValue(vals[vals.length-1]);
                                                cmp.tokenType = 'title';
                                                cmp.suspendEvent('changecomplete');
                                                cmp.setValue([vals[0], vals[vals.length-1]]);
                                                cmp.resumeEvent('changecomplete');
                                                cmp.setVisible(true);
                                            }
                                        } else {
                                            cmp.setMinValue(parseInt(records[0].getTerm()))
                                            this.getCorpus().getCorpusTerms().load({
                                                params: {
                                                    tokenType: 'pubDate',
                                                    limit: 1,
                                                    sort: "TERMDESC"
                                                },
                                                callback: function(records) {
                                                    cmp.setMaxValue(parseInt(records[0].getTerm())),
                                                        cmp.setVisible(true);
                                                },
                                                scope: this
                                            });
                                        }
                                    },
                                    scope: this
                                })
                            },
                            changecomplete: function(cmp, newVal) {
                                this.loadGeonames();
                            },
                            scope: this
                        }
                    }, {
                        xtype: 'fieldset',
                        title: "Animation",
                        items: [{
                            xtype: 'container',
                            layout: 'hbox',
                            defaults: {
                                xtype: 'button',
                                text: "",
                                ui: 'default-toolbar'
                            },
                            items: [{
                                glyph: 'xf048@FontAwesome', // step back
                                handler: function() {
                                    this.getAnimationLayer().getSource().clear();
                                    this.clearAnimation();
                                    var currentConnectionOccurrence = this.getCurrentConnectionOccurrence();
                                    currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence ? currentConnectionOccurrence.index-1 : 0);
                                    this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                                    this.animate();
                                },
                                scope: this
                            },{
                                glyph: 'xf04c@FontAwesome', // play
                                handler: function(cmp) {
                                    if (cmp.getGlyph().glyphConfig=="xf04b@FontAwesome") {
                                        this.clearAnimation();
                                        cmp.setGlyph(new Ext.Glyph('xf04c@FontAwesome'));
                                        this.setStepByStepMode(false);
                                        this.animate();
                                    } else {
                                        cmp.setGlyph(new Ext.Glyph('xf04b@FontAwesome'));
//                                         this.clearAnimation();
//                                         this.getAnimationLayer().getSource().clear();
                                        this.setStepByStepMode(true);
                                    }
//                                     this.setCurrentConnectionOccurrence(this.getGeonames().getConnectionOccurrence(0));
                                },
                                scope: this

                            },{
                                glyph: 'xf051@FontAwesome', // step forward
                                handler: function() {
                                    this.getAnimationLayer().getSource().clear();
                                    this.clearAnimation();
                                    var currentConnectionOccurrence = this.getCurrentConnectionOccurrence();
                                    currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence ? currentConnectionOccurrence.index+1 : 0);
                                    this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                                    this.animate();
                                },
                                scope: this
                            }, {
                                xtype: 'tbtext',
                                text: "&nbsp;&nbsp;"
                            }, {
                                glyph: 'xf01e@FontAwesome', // reset
                                handler: function() {
                                    this.getAnimationLayer().getSource().clear();
                                    this.clearAnimation();
                                    this.setCurrentConnectionOccurrence(this.getGeonames().getConnectionOccurrence(0));
                                    this.animate();
                                },
                                scope: this
                            }]
                        }, {
                            xtype: 'checkbox',
                            checked: false,
                            handler: function(item, checked) {
                                me.setKeepAnimationInFrame(checked);
                            },
                            boxLabel: "Keep animation in frame"
                        }]

                    },{
                        xtype: "container",
                        text: "&nbsp;"
                    },{
                        xtype: 'button',
                        text: 'remove',
                        scope:this,
                        //margin: 3,
                        handler: function(cmp) {
                            // assumes coupling with dreamscape
                            this.fireEvent("removeFilterWidget", this);
                            cmp.ownerCt.ownerCmp.destroy();
                        }
                    }]
                }
            });
        this.callParent([config]);
        this.on("afterrender", function(cmp) {
            cmp.getTargetEl().down('.x-btn-glyph').setStyle('color', this.getColor());
            var panel = cmp.up("panel")
            panel.mask(cmp.localize("loading"));
            cmp.loadGeonames().then(function(geonames) {
                panel.unmask();
                if (panel.getFilterWidgets().getCount()==1) {
                    var currentCitiesCount = geonames.getCitiesCount(),
                        totalCitiesCount = geonames.getTotalCitiesCount(),
                        currentConnectionsCount = geonames.getConnectionsCount(),
                        totalConnectionsCount = geonames.getTotalConnectionsCount();
                    message = cmp.localize(currentCitiesCount==totalCitiesCount && currentConnectionsCount==totalConnectionsCount ? "loadedAll" : "loadedSome") +
                        "<br><br>"+cmp.localize("disclaimer");
                    panel.toastInfo({
                        autoCloseDelay: 5000,

                        closable: true,
                        maxWidth: '90%',
                        html: new Ext.Template(cmp.localize("disclaimer")).apply({
                            currentCitiesCount: currentCitiesCount,
                            totalCitiesCount: totalCitiesCount,
                            currentConnectionsCount: currentConnectionsCount,
                            totalConnectionsCount: totalConnectionsCount,
                            url: panel.getBaseUrl()+"docs/#!/guide/dreamscape"
                        })

                    });
                }
            })
        }, this);
    },
    loadGeonames: function(params) {
        var me = this;
        params = params || {};

        // add queries
        var queries  = [];
        this.query('querysearchfield').forEach(function(querysearchfield) {
            var id = querysearchfield.getItemId();
            querysearchfield.getValue().forEach(function(query) {
                queries.push(id+":"+query);
            })
        });
        var pubDateSlider = this.down("multislider");
        if (pubDateSlider && pubDateSlider.isVisible()) {
            var vals = pubDateSlider.getValue();
            queries.push(pubDateSlider.tokenType+":["+vals[0]+"-"+vals[1]+"]")
        }
        if (queries.length>0 && !("query" in params)) {params.query=queries;}

        // add params from tool
        var panel  = this.up('panel');
        if (panel && panel.getApiParams) {
            Ext.applyIf(params, panel.getApiParams(["minPopulation","connectionsMaxCount","connectionsMinFreq","source","overridesId","filterHasLowerCaseForm","filterIsPersonName","preferredCoordinates"]))
        }

        this.mask("…");
        var geonames = this.getGeonames();
        return geonames.load(params).then(function() {
            me.unmask();
            me.fireEvent("filterUpdate", me, geonames);
            return geonames;
        }, function() {
            me.unmask();
        });
    },

    clearAnimation: function() {
        if (this.getTimeout()) {clearTimeout(this.getTimeout());}
    },

    animate: function() {
        var panel = this.up('panel');
        if (!panel) {return;}
        this.clearAnimation();
        var currentConnectionOccurrence = this.getCurrentConnectionOccurrence();
        if (currentConnectionOccurrence) {
            var animationLayer = this.getAnimationLayer();
            if (!animationLayer) {
                animationLayer = this.up('panel').getMap().getLayer(this.getId()+"-animation");
                this.setAnimationLayer(animationLayer);
            }
            if (animationLayer) {
                var features = animationLayer.getSource().getFeatures();
                if (features.length==0) {
                    if (!panel) {return;}
                    var connectionsLayerSource = panel.getMap().getLayer(this.getId()+"-connections").getSource();
                    var connectionsFeatures = connectionsLayerSource.getFeatures();
                    var hasMatch = false;
                    for (var i=0, len=connectionsFeatures.length; i<len; i++) {
                        if (currentConnectionOccurrence.source.id==connectionsFeatures[i].get("source") && currentConnectionOccurrence.target.id==connectionsFeatures[i].get("target")) {
                            hasMatch = connectionsFeatures[i];
                            break;
                        }
                    }
                    if (hasMatch) {
                        // check to see if we need to reposition the map, use displayed feature as basis for extent
                        if(this.getKeepAnimationInFrame()) {
                            var map = panel.getMap();
                            var extent = panel.getMap().getView().calculateExtent(map.getSize());
                            var isVisible = ol.extent.containsExtent(extent, hasMatch.getGeometry().getExtent());
                            if(!isVisible) {
                                newExtent = ol.extent.extend(extent, hasMatch.getGeometry().getExtent());
                                map.getView().fit(newExtent);
                            }
                        }

                        var arcGenerator = new arc.GreatCircle(
                            {x: currentConnectionOccurrence.source.lng, y: currentConnectionOccurrence.source.lat},
                            {x: currentConnectionOccurrence.target.lng, y: currentConnectionOccurrence.target.lat});
                        var arcLine = arcGenerator.Arc(100, {offset: 100});
                        var label = currentConnectionOccurrence.source.label+" -> "+currentConnectionOccurrence.target.label;
                        arcLine.geometries.forEach(function(geometry) {
                            var line = new ol.geom.LineString([]); // can be empty since we generate a line during next animate call
                            line.transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857'));
                            var feature = new ol.Feature({
                                geometry: line,
                                allcoords: geometry.coords ,
                                text: label,
                                color: this.getColor(),
                                width: 5,
                                start: new Date().getTime()
                            });
                            animationLayer.getSource().addFeature(feature);
                        }, this);

                        var ticker = panel.body.down(".ticker");

                        panel.body.down(".ticker").setHtml(
                            currentConnectionOccurrence.source.left+" <span class='keyword'>"+currentConnectionOccurrence.source.term+"</span> "+currentConnectionOccurrence.source.right+" … "+
                            currentConnectionOccurrence.target.left+" <span class='keyword'>"+currentConnectionOccurrence.target.term+"</span> "+currentConnectionOccurrence.target.right
                        );
                        return this.setTimeout(setTimeout(this.animate.bind(this), 1));

                    } else {
                        if (!this.getGeonames()) {return;}
                        currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence.index+1);
                        this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                        animationLayer.getSource().clear();
                        return this.setTimeout(setTimeout(this.animate.bind(this), 1));

                    }
                } else if (features.length>0) {

                    var coords = features[0].getGeometry().getCoordinates(),
                        allcoords = features[0].get("allcoords");
                    if (coords.length<allcoords.length) {
                        var elapsed = new Date().getTime()-features[0].get('start'),
                            len = elapsed*allcoords.length/this.getMillisPerAnimation()
                        line = new ol.geom.LineString(allcoords.slice(0,len));
                        line.transform(ol.proj.get('EPSG:4326'), panel.getProjection()?panel.getProjection():ol.proj.get('EPSG:3857'));
                        features[0].set("geometry", line);
                        return this.setTimeout(setTimeout(this.animate.bind(this), 25));

                    }
                    // if we get here, all features should have been changed
                    currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(currentConnectionOccurrence.index+1);
                    if(!this.getStepByStepMode()) {
                        this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                        animationLayer.getSource().clear();
                        return this.setTimeout(setTimeout(this.animate.bind(this), 1));
                    }
                }
            }
        } else {
            if (!this.getGeonames()) {return;}
            currentConnectionOccurrence = this.getGeonames().getConnectionOccurrence(0);
            if (currentConnectionOccurrence) {
                this.setCurrentConnectionOccurrence(currentConnectionOccurrence);
                return this.setTimeout(setTimeout(this.animate.bind(this), 1));
            }
        }
    }
});

// assuming Knots library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Knots', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.knots',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
        	 * @property query A string to search for in a document.
        	 * @type String
    		 * @private
        	 */
    		query: null,
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		/**
    		 * @property docId The document ID to restrict results to.
    		 * @type String
    		 * @private
    		 */
    		docId: undefined,
    		
    		audio: false
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
		knots: undefined,
		termStore: undefined,
		docTermStore: undefined,
		tokensStore: undefined,
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'},{xtype: 'colorpaletteoption'}],
    	refreshInterval: 100,
    	startAngle: 315,
    	angleIncrement: 15,
    	currentTerm: undefined
	},
	
	termTpl: new Ext.XTemplate(
		'<tpl for=".">',
			'<div class="term" style="color: rgb({color});float: left;padding: 3px;margin: 2px;">{term}</div>',
		'</tpl>'
	),
	
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		var firstDoc = corpus.getDocument(0);
    		var pDoc = this.processDocument(firstDoc);
    		this.getKnots().setCurrentDoc(pDoc);
    		
    		this.setApiParams({docId: firstDoc.getId()});
    		this.getDocTermStore().getProxy().setExtraParam('corpus', corpus.getId());
    		this.getTokensStore().setCorpus(corpus);
    		this.getDocTermStore().load({params: {
		    	limit: 5,
		    	stopList: this.getApiParams('stopList')
		    }});
    	}, this);
    	
        this.on('activate', function() { // load after tab activate (if we're in a tab panel)
			if (this.getCorpus()) {				
				Ext.Function.defer(function() {
					this.getDocTermStore().load({params: {
				    	limit: 5,
				    	stopList: this.getApiParams('stopList')
				    }});
				}, 100, this);
			}
    	}, this);
        
        this.on('query', function(src, query) {
    		if (query !== undefined && query != '') {
    			this.getDocTermsFromQuery(query);
    		}
    	}, this);
        
        this.on('documentSelected', function(src, doc) {
        	
        	var document = this.getCorpus().getDocument(doc)
        	this.setApiParam('docId', document.getId());
        	
        	var terms = this.getKnots().currentDoc.terms;
        	var termsToKeep = [];
        	for (var t in terms) {
        		termsToKeep.push(t);
        	}
        	
//        	this.getTermStore().removeAll();
    		this.setApiParams({query: termsToKeep});
    		
    		var limit = termsToKeep.length;
    		if (limit === 0) {
    			limit = 5;
    		}
        	
        	this.getKnots().setCurrentDoc(this.processDocument(document));
        	
        	this.getDocTermStore().load({params: {
		    	query: termsToKeep,
		    	limit: limit,
		    	stopList: this.getApiParams('stopList')
		    }});
        }, this);
        
        this.on('termsClicked', function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (Ext.isString(term)) {queryTerms.push(term);}
    			else if (term.term) {queryTerms.push(term.term);}
    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
    		});
    		if (queryTerms.length > 0) {
    			this.getDocTermsFromQuery(queryTerms);
    		}
		}, this);
        
		this.on('corpusTermsClicked', function(src, terms) {
			var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.getDocTermsFromQuery(queryTerms);
		}, this);
		
		this.on('documentTermsClicked', function(src, terms) {
			var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.getDocTermsFromQuery(queryTerms);
		}, this);
    },
    
    initComponent: function() {
    	this.setTermStore(Ext.create('Ext.data.ArrayStore', {
	        fields: ['term', 'color']
	    }));
    	
    	this.setDocTermStore(Ext.create("Ext.data.Store", {
			model: "Voyant.data.model.DocumentTerm",
    		autoLoad: false,
    		remoteSort: false,
    		proxy: {
				type: 'ajax',
				url: Voyant.application.getTromboneUrl(),
				extraParams: {
					tool: 'corpus.DocumentTerms',
					withDistributions: 'raw',
					withPositions: true
				},
				reader: {
					type: 'json',
		            rootProperty: 'documentTerms.terms',
		            totalProperty: 'documentTerms.total'
				},
				simpleSortMode: true
   		     },
   		     listeners: {
   		    	 beforeload: function(store) {
   		    		 store.getProxy().setExtraParam('docId', this.getApiParam('docId'));
   		    	 },
   		    	 load: function(store, records, successful, options) {
   		    		var termObj = {};
   		    		if (records && records.length>0) {
   	   		    		records.forEach(function(record) {
   	   		    			var termData = this.processTerms(record);
   	   		    			var docId = record.get('docId');
   	   		    			var term = record.get('term');
   	   		    			termObj[term] = termData;
   	   		    		}, this);
   	   		    		this.getKnots().addTerms(termObj);
   	   		    		this.getKnots().buildGraph();
   		    		}
   		    		else {
   		    			this.toastInfo({
   		    				html: this.localize("noTermsFound"),
   		    				align: 'bl'
   		    			})
   		    		}
   				},
   				scope: this
   		     }
    	}));
    	
    	this.setTokensStore(Ext.create("Voyant.data.store.Tokens", {
        	stripTags: "all",
        	listeners: {
        		beforeload: function(store) {
  		    		 store.getProxy().setExtraParam('docId', this.getApiParam('docId'));
  		    	},
        		load: function(store, records, successful, options) {
        			var context = '';
        			var currTerm = this.getCurrentTerm();
        			records.forEach(function(record) {
        				if (record.getPosition() == currTerm.tokenId) {
        					context += '<strong>'+record.getTerm()+'</strong>';
        				} else {
        					context += record.getTerm();
        				}
        			});
        			
        			Ext.Msg.show({
        				title: this.localize('context'),
        				message: context,
        				buttons: Ext.Msg.OK,
        			    icon: Ext.Msg.INFO
        			});
        		},
   				scope: this
        	}
        }));
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                },{
	            	text: this.localize('clearTerms'),
	            	glyph: 'xf00d@FontAwesome',
	            	handler: function() {
	            		this.down('#termsView').getSelectionModel().deselectAll(true);
	            		this.getTermStore().removeAll();
	            		this.setApiParams({query: null});
	            		this.getKnots().removeAllTerms();
	            		this.getKnots().drawGraph();
	            	},
	            	scope: this
	            },{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					itemId: 'speed',
					fieldLabel: this.localize("speed"),
					labelAlign: 'right',
					labelWidth: 50,
					width: 100,
					increment: 50,
					minValue: 0,
					maxValue: 500,
					value: 500-this.getRefreshInterval(),
					listeners: {
						changecomplete: function(slider, newvalue) {
							this.setRefreshInterval(500-newvalue);
							if (this.getKnots()) {this.getKnots().buildGraph();}
						},
						scope: this
					}
				},{
					xtype: 'slider',
					itemId: 'startAngle',
					fieldLabel: this.localize('startAngle'),
					labelAlign: 'right',
					labelWidth: 35,
					width: 85,
					increment: 15,
					minValue: 0,
					maxValue: 360,
					value: this.getStartAngle(),
					listeners: {
						changecomplete: function(slider, newvalue) {
							this.setStartAngle(newvalue);
							if (this.getKnots()) {this.getKnots().buildGraph();}
						},
						scope: this
					}
				},{
					xtype: 'slider',
					itemId: 'tangles',
					fieldLabel: this.localize('tangles'),
					labelAlign: 'right',
					labelWidth: 30,
					width: 80,
					increment: 5,
					minValue: 5,
					maxValue: 90,
					value: this.getAngleIncrement(),
					listeners: {
						changecomplete: function(slider, newvalue) {
							this.setAngleIncrement(newvalue);
							if (this.getKnots()) {this.getKnots().buildGraph();}
						},
						scope: this
					}
				},{
	                xtype: 'checkbox',
	                boxLabel: this.localize('sound'),
	                listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(this.getApiParam("audio")===true ||  this.getApiParam("audio")=="true")
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('soundTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    change: function(cmp, val) {
	                    	if (this.getKnots()) {
		                    	this.getKnots().setAudio(val);
	                    	}
	                    },
	                    scope: this
	                }
	            }]
    		}],
            border: false,
            layout: 'fit',
            items: {
            	layout: {
            		type: 'vbox',
            		align: 'stretch'
            	},
            	defaults: {border: false},
	            items: [{
	            	height: 30,
	            	itemId: 'termsView',
	            	xtype: 'dataview',
	            	store: this.getTermStore(),
	            	tpl: this.termTpl,
	            	itemSelector: 'div.term',
	            	overItemCls: 'over',
	            	selectedItemCls: 'selected',
	            	selectionModel: {
	            		mode: 'SIMPLE'
	            	},
//	            	cls: 'selected', // default selected
	            	focusCls: '',
	            	listeners: {
	            		beforeitemclick: function(dv, record, item, index, event, opts) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			dv.fireEvent('itemcontextmenu', dv, record, item, index, event, opts);
	            			return false;
	            		},
	            		beforecontainerclick: function() {
	            			// cancel deselect all
	            			event.preventDefault();
	            			event.stopPropagation();
	            			return false;
	            		},
	            		selectionchange: function(selModel, selections) {
	            			var dv = this.down('#termsView');
	            			var terms = [];
	            			
	            			dv.getStore().each(function(r) {
	            				if (selections.indexOf(r) !== -1) {
	            					terms.push(r.get('term'));
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('unselected').addCls('selected');
	            				} else {
	            					Ext.fly(dv.getNodeByRecord(r)).removeCls('selected').addCls('unselected');
	            				}
	            			});
	            			
	            			this.getKnots().termsFilter = terms;
	            			this.getKnots().drawGraph();
	            		},
	            		itemcontextmenu: function(dv, record, el, index, event) {
	            			event.preventDefault();
	            			event.stopPropagation();
	            			var isSelected = dv.isSelected(el);
	            			var menu = new Ext.menu.Menu({
	            				floating: true,
	            				items: [{
	            					text: isSelected ? this.localize('hideTerm') : this.localize('showTerm'),
	            					handler: function() {
	            						if (isSelected) {
	            							dv.deselect(index);
	            						} else {
	            							dv.select(index, true);
	            						}
	            					},
	            					scope: this
	            				},{
	            					text: this.localize('removeTerm'),
	            					handler: function() {
	            						dv.deselect(index);
	            						var term = this.getTermStore().getAt(index).get('term');
	            						this.getTermStore().removeAt(index);
	            						dv.refresh();
	            						
	            						this.getKnots().removeTerm(term);
	            						this.getKnots().drawGraph();
	            					},
	            					scope: this
	            				}]
	            			});
	            			menu.showAt(event.getXY());
	            		},
	            		scope: this
	            	}
	            },{
	            	flex: 1,
	            	xtype: 'container',
	            	autoEl: 'div',
	            	itemId: 'canvasParent',
	            	layout: 'fit',
	            	overflowY: 'auto',
	            	overflowX: 'hidden'
	            }],
	            listeners: {
	            	render: function(component) {
	            		var canvasParent = this.down('#canvasParent');
	                	this.setKnots(new Knots({
	                		container: canvasParent,
	                		clickHandler: this.knotClickHandler.bind(this),
	                		audio: this.getApiParam("audio")===true ||  this.getApiParam("audio")=="true"
	                	}));
	            	},
            		afterlayout: function(container) {
            			if (this.getKnots().initialized === false) {
            				this.getKnots().initializeCanvas();
            			}
            		},
	        		resize: function(cnt, width, height) {
	        			this.getKnots().doLayout();
	        		},
            		scope: this
            	}
            }
		});
    	
    	this.callParent(arguments);
    },
    
    updateRefreshInterval: function(value) {
    	if (this.getKnots()) {
    		if (value < 50) {
    			value = 50;
    			this.getKnots().progressiveDraw = false;
    		} else {
    			this.getKnots().progressiveDraw = true;
    		}
    		this.getKnots().refreshInterval = value;
			this.getKnots().buildGraph(this.getKnots().drawStep);
    	}
    },
    
    updateStartAngle: function(value) {
    	if (this.getKnots()) {
			this.getKnots().startAngle = value;
			this.getKnots().recache();
			this.getKnots().buildGraph();
    	}
    },
    
    updateAngleIncrement: function(value) {
    	if (this.getKnots()) {
	    	this.getKnots().angleIncrement = value;
			this.getKnots().recache();
			this.getKnots().buildGraph();
    	}
    },
    
    loadFromCorpusTerms: function(corpusTerms) {
    	if (this.getKnots()) { // get rid of existing terms
    		this.getKnots().removeAllTerms();
    		this.getTermStore().removeAll(true);
    	}
		corpusTerms.load({
		    callback: function(records, operation, success) {
		    	var query = []; //this.getApiParam('query') || [];
				if (typeof query == 'string') query = [query];
		    	records.forEach(function(record, index) {
					query.push(record.get('term'));
				}, this);
		    	this.getDocTermsFromQuery(query);
		    },
		    scope: this,
		    params: {
		    	limit: 5,
		    	stopList: this.getApiParams('stopList')
		    }
    	});
    },
    
    /**
     * Get the results for the query(s) for each of the corpus documents.
     * @param query {String|Array}
     * @private
     */
    getDocTermsFromQuery: function(query) {
    	if (query) {this.setApiParam("query", query);} // make sure it's set for subsequent calls
    	var corpus = this.getCorpus();
    	if (corpus && this.isVisible()) {
    		this.setApiParams({query: query}); // assumes docId already set
			this.getDocTermStore().load({params: this.getApiParams()});
    	}
	},
    
	reloadTermsData: function() {
		var terms = [];
		for (var term in this.bubblelines.currentTerms) {
			terms.push(term);
		}
		this.getDocTermsFromQuery(terms);
	},
	
    filterDocuments: function() {
		var docIds = this.getApiParam('docId');
		if (docIds == '') {
			docIds = [];
			this.getCorpus().getDocuments().each(function(item, index) {
				docIds.push(item.getId());
			});
			this.setApiParams({docId: docIds});
		}
		if (typeof docIds == 'string') docIds = [docIds];
		
		if (docIds == null) {
			this.selectedDocs = this.getCorpus().getDocuments().clone();
			var count = this.selectedDocs.getCount();
			if (count > 10) {
				for (var i = 10; i < count; i++) {
					this.selectedDocs.removeAt(10);
				}
			}
			docIds = [];
			this.selectedDocs.eachKey(function(docId, doc) {
				docIds.push(docId);
			}, this);
			this.setApiParams({docId: docIds});
		} else {
			this.selectedDocs = this.getCorpus().getDocuments().filterBy(function(doc, docId) {
				return docIds.indexOf(docId) != -1;
			}, this);
		}
	},
	
	// produce format that knots can use
	processDocument: function(doc) {
		var title = doc.getShortTitle();
		title = title.replace('&hellip;', '...');
	
		return {
			id: doc.getId(),
			index: doc.get('index'),
			title: title,
			totalTokens: doc.get('tokensCount-lexical'),
			terms: {},
			lineLength: undefined
		};
	},
	
	processTerms: function(termRecord) {
		var termObj;
		var term = termRecord.get('term');
		var rawFreq = termRecord.get('rawFreq');
		var positions = termRecord.get('positions');
		if (rawFreq > 0) {
			var color = this.getApplication().getColorForTerm(term);
			if (this.getTermStore().find('term', term) === -1) {
				this.getTermStore().loadData([[term, color]], true);
				var index = this.getTermStore().find('term', term);
				this.down('#termsView').select(index, true); // manually select since the store's load listener isn't triggered
			}
			var distributions = termRecord.get('distributions');
			termObj = {term: term, positions: positions, distributions: distributions, rawFreq: rawFreq, color: color};
		} else {
			termObj = false;
		}
		
		return termObj;
	},
	
	knotClickHandler: function(data) {
		this.setCurrentTerm(data);
		var start = data.tokenId - 10;
		if (start < 0) start = 0;
		this.getTokensStore().load({
			start: start,
			limit: 21
		});
		
		data = [data].map(function(item) {return item.term}); // make an array for the event dispatch
		this.getApplication().dispatchEvent('termsClicked', this, data);
	}
});
Ext.define('Voyant.panel.Phrases', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.phrases',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		sort: 'length',
    		dir: 'desc',
    		minLength: 2,
    		maxLength: 50,
    		overlapFilter: 'length'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	/**
    	 * @private
    	 */
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    },
    constructor: function(config) {
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.isVisible()) {
            	if (this.hasCorpusAccess(corpus)==false) {
            		this.mask(this.localize('limitedAccess'), 'mask-no-spinner');
            	} else {
        			this.loadFromApis();
            	}
    		}
    		
    	});
    	
    	if (config.embedded) {
//    		var cls = Ext.getClass(config.embedded).getName();
//    		if (cls=="Voyant.data.store.DocumentTerms" || cls=="Voyant.data.model.Document") {
//    			this.fireEvent('loadedCorpus', this, config.embedded.getCorpus())
//    		}
    	}
    	else if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus)
    	}
    	
    	this.on("corpusTermsClicked", function(src, terms) {
    		if (this.getStore().getCorpus()) { // make sure we have a corpus
        		var query = [];
        		terms.forEach(function(term) {
        			query.push(term.get("term"));
        		})
        		this.setApiParams({
        			query: query,
        			docId: undefined,
        			docIndex: undefined
        		});
        		if (this.isVisible()) {
            		this.getStore().load({params: this.getApiParams()});
        		}
    		}
    	});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {this.loadFromApis()}
    	}, this)
    	
    	this.on("query", function(src, query) {
    		this.setApiParam("query", query);
    		this.getStore().getProxy().setExtraParam("query", query);
    		this.loadFromApis();
    	}, this)
    },
    
    loadFromApis: function() {
    	if (this.getStore().getCorpus()) {
    			this.getStore().load({params: this.getApiParams()});
    	}
    },
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.CorpusNgramsBuffered", {
        	parentPanel: me,
			leadingBufferZone: 100 // since these calls are expensive reduce buffer to 1 page
        });
        
        store.on("beforeload", function(store) {
    		return me.hasCorpusAccess(store.getCorpus());
        });
        me.on("sortchange", function( ct, column, direction, eOpts ) {
        	this.setApiParam('sort', column.dataIndex);
        	this.setApiParam('dir', direction);
        	var api = this.getApiParams(["stopList", "query", "docId", "docIndex", "sort", "dir", "minLength", "maxLength", "overlapFilter"]);
        	var proxy = this.getStore().getProxy();
        	for (var key in api) {proxy.setExtraParam(key, api[key]);}
        }, me)

        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
							if (selections.length > 0) {
								var terms = [];
								selections.forEach(function(selection) {
									terms.push('"'+selection.getTerm()+'"')
								})
								this.getApplication().dispatchEvent('termsClicked', this, terms);
							}
                    	},
                    	scope: this
                    }
                }
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }, '-', {
                	text: me.localize('length'),
                	tooltip: 'test',
                	xtype: 'label'
                }, {
                	xtype: 'slider',
                	minValue: 2,
                	values: [2, 30],
                	maxValue: 30,
                	increment: 1,
                	width: 75,
                	tooltip: this.localize("lengthTip"),
                	listeners: {
                		render: {
                			fn: function(slider) {
                				var values = slider.getValues();
                				slider.setValue(0, parseInt(this.getApiParam("minLength", values[0])))
                				slider.setValue(1, parseInt(this.getApiParam("maxLength", values[1])))
	                		},
	                		scope: me
                		},
                		changecomplete: {
                			fn: function(slider, newValue) {
                				var values = slider.getValues();
                				this.setApiParam("minLength", parseInt(values[0]));
                				this.setApiParam("maxLength", parseInt(values[1]));
                        		this.getStore().load({params: this.getApiParams()});
                    		},
                    		scope: me
                		}
                	}
                }, {
        			xtype: 'corpusdocumentselector'
        		}, '-', {
                    xtype: 'button',
                    text: this.localize('overlap'),
                    tooltip: this.localize('overlapTip'),
                    menu: {
                    	items: [
                           {
                        	   xtype: 'menucheckitem',
                               text: this.localize("overlapNone"),
                               group: 'overlap',
                               inputValue: 'none',
                               checkHandler: function() {
                            	   this.setApiParam('overlapFilter', 'none')
                            	   this.getStore().load({params: this.getApiParams()})
                               },
                               scope: this
                           }, {
                        	   xtype: 'menucheckitem',
                               text: this.localize("overlapLength"),
                               group: 'overlap',
                               inputValue: 'length',
                               checkHandler: function() {
                            	   this.setApiParam('overlapFilter', 'length')
                            	   this.getStore().load({params: this.getApiParams()})
                               },
                               scope: this
                           }, {
                        	   xtype: 'menucheckitem',
                               text: this.localize("overlapFreq"),
                               group: 'overlap',
                               inputValue: 'rawFreq',
                               checkHandler: function() {
                            	   this.setApiParam('overlapFilter', 'rawfreq')
                            	   this.getStore().load({params: this.getApiParams()})
                               },
                               scope: this
                           }
	                   ],
	                   listeners: {
	                	   afterrender: {
	                		   fn: function(menu) {
	                			   var overlapFilter = this.getApiParam('overlapFilter');
	                			   menu.items.each(function(item) {
	                				   if (item.group) {
	                					   item.setChecked(item.inputValue==overlapFilter);
	                				   }
	                			   }, this)
	                		   },
	                		   scope: this
	                	   }
                
	                   }
                    }
                }]
            }],
    		columns: [{
    			text: this.localize("term"),
        		dataIndex: 'term',
            	tooltip: this.localize("termTip"),
                sortable: true,
                flex: 1
            },{
    			text: this.localize("rawFreq"),
        		dataIndex: 'rawFreq',
            	tooltip: this.localize("termRawFreqTip"),
                sortable: true,
                width: 'autoSize'
            },{
            	text: this.localize("length"),
            	dataIndex: 'length',
            	tooltip: this.localize("lengthTip"),
            	sortable: true,
                width: 'autoSize'
            },{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize('trendTip'),
                width: 120,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline'
                }
            }],
            
            listeners: {
				corpusSelected: function() {
					this.setApiParams({docIndex: undefined, docId: undefined});
					this.loadFromApis();
				},
				documentsSelected: function(src, docs) {
					var docIds = [];
					var corpus = this.getStore().getCorpus();
					docs.forEach(function(doc) {
						docIds.push(corpus.getDocument(doc).getId())
					}, this);
					this.setApiParams({docId: docIds, docIndex: undefined})
					this.loadFromApis();
				},
            	termsClicked: {
            		fn: function(src, terms) {
                		if (this.getStore().getCorpus()) { // make sure we have a corpus
                    		var queryTerms = [];
                    		terms.forEach(function(term) {
                    			if (Ext.isString(term)) {queryTerms.push(term);}
                    			else if (term.term) {queryTerms.push(term.term);}
                    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
                    		});
                    		if (queryTerms.length > 0) {
                    			this.setApiParams({
                    				docIndex: undefined,
                    				docId: undefined,
                    				query: queryTerms
                    			});
                        		if (this.isVisible()) {
                            		if (this.isVisible()) {
                                		this.getStore().clearAndLoad({params: this.getApiParams()});
                            		}
                        		}
                    		}
                		}
                	},
                	scope: this
            	}
            }
        });

        me.callParent(arguments);
        
        me.getStore().getProxy().setExtraParam("withDistributions", true);
        
    }
    
})
/**
 * Corpus Terms tool, a grid that shows the terms in the corpus.
 * 
 * <iframe src="../?corpus=austen&view=corpusterms" style="max-width: 500px; height: 300px"></iframe>
 * 
 * The typical use is not to instantiate this class directly, but to embed the tool from a corpus.
 * 
 * 		var austen;
 * 		new Corpus("austen").then(function(corpus) {
 * 			austen = corpus;
 * 			austen.embed('CorpusTerms'); // simply embed
 * 			austen.embed('CorpusTerms', {query: '^lov*'}); // embed with query
 * 		});
 */
Ext.define('Voyant.panel.CorpusTerms', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.corpusterms',
    statics: {
    	i18n: {
    	},
    	api: {
    		
    		/**
    		 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
    		 * 
    		 *  By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
    		 *  
    		 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
    		 */
    		stopList: 'auto',
    		
    		/**
    		 * @cfg {String/String[]} query A query or array of queries (queries can be separated by a comma).
    		 * 
    		 * For query syntax, see the <a href="#!/guide/search">search documentation</a>.
    		 */
    		query: undefined,
    		
    		/**
    		 * @cfg {Number} maxBins The maximum number of bins to use for distributions in Trend.
    		 * 
    		 * By default this is set to 100 (in other words, if there are more than 100 documents in the corpus, they will be forced into 100 bins).
    		 * Higher values are possible but it can cause performance issues and necessitate more data transfer (values for each one of the bins for each one of the terms).
    		 * @cfg
    		 */
    		maxBins: 100,

			/**
			 * @cfg {String} termColors Which term colors to show in the grid.
			 * 
			 * By default this is set to 'categories' which shows the term color only if it's been assigned by a category.
			 * The other alternatives are 'terms' which shows all terms colors, and '' or undefined which shows no term colors.
			 */
			termColors: 'categories',

    		/**
    		 * @cfg {String} comparisonCorpus An existing corpus to be used for comparison purposes.
    		 * 
    		 * None of the columns visible by default use comparisonCorpus so this is an advanced parameter used when the "Comparison" column is shown.
    		 * The comparison column shows the relative frequency of the term in the corpus compared to the relative frequency of the same term in a comparison corpus.
    		 */
    		comparisonCorpus: undefined
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	/**
    	 * @private
    	 */
    	options: [{
    		xtype: 'stoplistoption'
    	},{
			xtype: 'categoriesoption'
		},{
			xtype: 'termcolorsoption'
		},{
    		xtype: 'corpusselector',
    		name: 'comparisonCorpus',
    		fieldLabel: 'comparison corpus'
    	}]
    },

	/**
	 * @private
	 */
    constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.CorpusTermsBuffered", {
        	parentPanel: this,
        	proxy: {
        		extraParams: {
        			withDistributions: 'relative',
        			forTool: 'corpusterms'
        		}
        	}
        });
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                pruneRemoved: false,
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		if (selections && selections.length>0) {
                        		this.getApplication().dispatchEvent('corpusTermsClicked', this, selections);
                    		}
                    	},
                    	scope: this
                    }
                },
                mode: 'SIMPLE'
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                }]
            }],
            
            plugins: [{
                ptype: 'rowexpander',
                rowBodyTpl: new Ext.XTemplate('')
            }],
            viewConfig: {
                listeners: {
                    // TODO widget disappears when scrolled off screen
                    expandbody: function(rowNode, record, expandRow, eOpts) {
                        if (expandRow.textContent==='' || (eOpts && eOpts.force)) {
                            Ext.create('Voyant.widget.CorpusTermSummary', {
                                record: record,
                                header: false,
                                renderTo: expandRow.querySelector('div')
                            });
                        }
                    },
                    scope: this
                }
            },
    		columns: [{
                xtype: 'rownumberer',
                width: 'autoSize',
                sortable: false
            },{
    			text: this.localize("term"),
            	tooltip: this.localize("termTip"),
        		dataIndex: 'term',
        		flex: 1,
                sortable: true,
				xtype: 'coloredtermfield',
				useCategoriesMenu: true
            },{
            	text: this.localize("rawFreq"),
            	tooltip: this.localize("rawFreqTip"),
            	dataIndex: 'rawFreq',
                width: 'autoSize',
            	sortable: true
            },{
            	text: this.localize("relativeFreq"),
            	tooltip: this.localize("relativeFreqTip"),
            	dataIndex: 'relativeFreq',
            	renderer: function(val) {
            		var percent = val*100;
            		return Ext.util.Format.number(val*1000000, "0,000")/* + " (%"+
            			(val*100 <  .1 ? "<0.1" : Ext.util.Format.number(val*100, "0.0"))+")"*/
            	},
                width: 'autoSize',
                hidden: true,
            	sortable: true
            },{
            	text: this.localize("relativePeakedness"),
            	tooltip: this.localize("relativePeakednessTip"),
            	dataIndex: 'relativePeakedness',
            	renderer: Ext.util.Format.numberRenderer("0,000.0"),
                width: 'autoSize',
                hidden: true,
            	sortable: true
            },{
            	text: this.localize("relativeSkewness"),
            	tooltip: this.localize("relativeSkewnessTip"),
            	dataIndex: 'relativeSkewness',
            	renderer: Ext.util.Format.numberRenderer("0,000.0"),
                width: 'autoSize',
                hidden: true,
            	sortable: true
            },{
            	text: this.localize("corpusComparisonDifference"),
            	tooltip: this.localize("corpusComparisonDifferenceTip"),
            	dataIndex: 'comparisonRelativeFreqDifference',
            	renderer: Ext.util.Format.numberRenderer("0,000.00000"),
                width: 'autoSize',
                hidden: !this.getApiParam('comparisonCorpus'),
            	sortable: true,
            	listeners: {
            		show: function(ct, column, eopts) {
            			if (!me.getApiParam('comparisonCorpus')) {
            				me.showError(me.localize('noCorpusComparison'))
            			}
            		}
            	}
            },{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize("trendTip"),
                flex: 1,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline',
                    tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
                    	getDocumentTitle: function(docIndex, relativeFreq) {
                    		return this.panel.store.getCorpus().getDocument(docIndex).getTitle()+"<br>"+this.panel.localize("relativeFreqLabel")+" "+Ext.util.Format.number(relativeFreq*1000000, "0,000")
                    	},
                    	panel: me 
                    })
                }
            }]
        });
        
    	me.on('loadedCorpus', function(src, corpus) {
//    		this.setApiParam('query', undefined);
    		if (corpus.getDocumentsCount()>100) {
    			this.getStore().getProxy().setExtraParam('bins', this.getApiParam('maxBins'));
    		}
    		if (this.isVisible()) {
        		this.getStore().load()
    		}
    	}, me);
    	
    	me.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (me.getStore().getCorpus()) {
    			me.getStore().load({params: this.getApiParams()});
    		}
    	}, me);

    	
    	me.on("query", function(src, query) {
    		this.setApiParam('query', query);
    		this.getStore().removeAll();
    		this.getStore().load();
    	}, me);


        me.callParent(arguments);
        
    }
})

Ext.define('Voyant.panel.DocumentTerms', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Voyant.data.store.DocumentTerms'],
	alias: 'widget.documentterms',
	config: {
		options: [{
    		xtype: 'stoplistoption'
    	},{
			xtype: 'categoriesoption'
		},{
			xtype: 'termcolorsoption'
		}]
    },
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		bins: 10,
			termColors: 'categories'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    constructor: function(config) {
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		var store = this.getStore();
    		store.setCorpus(corpus);
    		if (this.isVisible()) {
        		store.load();
    		}
    	});
    	
    	if (config.embedded) {
    		if (window.console) {
    			console.warn(config.embedded.then);
    		}
    		var cls = Ext.getClass(config.embedded).getName();
    		if (cls=="Voyant.data.store.DocumentTerms" || cls=="Voyant.data.model.Document") {
    			this.fireEvent('loadedCorpus', this, config.embedded.getCorpus());
    		}
    	}
    	else if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus);
    	}
    	
    	this.on("query", function(src, query) {
    		this.fireEvent("corpusTermsClicked", src, query);
    	}, this);
    	
    	this.on("corpusTermsClicked", function(src, terms) {
    		if (this.getStore().getCorpus()) { // make sure we have a corpus
        		var query = [];
        		terms.forEach(function(term) {
        			query.push(Ext.isString(term) ? term : term.get("term"));
        		});
        		this.setApiParams({
        			query: query,
        			docId: undefined,
        			docIndex: undefined
        		});
        		if (this.isVisible()) {
            		this.getStore().load({params: this.getApiParams()});
        		}
    		}
    	});
    	
    	this.on("documentsClicked", function(src, documents) {
    		var docIds = [];
    		documents.forEach(function(doc) {docIds.push(doc.get('id'));});
    		this.setApiParams({
    			docId: docIds,
    			query: undefined
    		});
    		if (this.isVisible()) {
        		this.getStore().load({params: this.getApiParams()});
    		}
    	});

		this.on("documentsSelected", function(src, docIds) {
    		this.setApiParams({
    			docId: docIds,
    			query: undefined
    		});
    		if (this.isVisible()) {
        		this.getStore().load({params: this.getApiParams()});
    		}
		});

		this.on("corpusSelected", function(src, corpus) {
			this.setApiParams({
				docId: undefined,
				docIndex: undefined
			});
			if (this.isVisible()) {
				this.getStore().load({params: this.getApiParams()});
			}
		});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {
    			this.getStore().load({params: this.getApiParams()});
    		}
    	}, this);
    },
    
    initComponent: function() {
        var me = this;

        var store = Ext.create("Voyant.data.store.DocumentTermsBuffered", {parentPanel: this});
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
            store : store,
    		selModel: Ext.create('Ext.selection.CheckboxModel', {
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		this.getApplication().dispatchEvent('documentTermsClicked', this, selections);
                    	},
                    	scope: this
                    }
                },
                pruneRemoved: false,
    			mode: 'SIMPLE'
            }),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                }, {
                    xtype: 'totalpropertystatus'
                },{
        			xtype: 'corpusdocumentselector'
        		}]
            }],
    		columns: [{
    			text: '#',
    			width: 30,
        		dataIndex: 'docIndex',
                sortable: true,
                renderer: function(v) {return v+1;} // 0-based to 1-based
            },{
    			text: this.localize("term"),
        		dataIndex: 'term',
            	tooltip: this.localize("termTip"),
                sortable: true,
                flex: 1,
				xtype: 'coloredtermfield',
				useCategoriesMenu: true
            },{
            	text: this.localize("rawFreq"),
            	dataIndex: 'rawFreq',
            	tooltip: this.localize("rawFreqTip"),
            	width: 'autoSize',
            	sortable: true
            },{
            	text: this.localize("relativeFreq"),
            	tooltip: this.localize("relativeFreqTip"),
            	dataIndex: 'relativeFreq',
            	width: 'autoSize',
            	sortable: true,
            	renderer: Ext.util.Format.numberRenderer('0,000')
            },{
            	text: this.localize("tfidf"),
            	tooltip: this.localize("tfidfTip"),
            	dataIndex: 'tfidf',
            	width: 'autoSize',
            	sortable: true,
            	hidden: true,
            	renderer: Ext.util.Format.numberRenderer('0,000.000')
            },{
            	text: this.localize("zscore"),
            	tooltip: this.localize("zscoreTip"),
            	dataIndex: 'zscore',
            	width: 'autoSize',
            	sortable: true,
            	hidden: true,
            	renderer: Ext.util.Format.numberRenderer('0,000.000')
            },{
                xtype: 'widgetcolumn',
                text: this.localize("trend"),
                tooltip: this.localize('trendTip'),
                flex: 1,
                dataIndex: 'distributions',
                widget: {
                    xtype: 'sparklineline'
                }
            }],
            
            listeners: {
            	termsClicked: {
            		fn: function(src, terms) {
                		if (this.getStore().getCorpus()) { // make sure we have a corpus
                    		var queryTerms = [];
                    		terms.forEach(function(term) {
                    			if (Ext.isString(term)) {queryTerms.push(term);}
                    			else if (term.term) {queryTerms.push(term.term);}
                    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
                    		});
                    		if (queryTerms.length > 0) {
                    			this.setApiParams({
                    				docIndex: undefined,
                    				docId: undefined,
                    				query: queryTerms
                    			});
                        		if (this.isVisible()) {
                            		if (this.isVisible()) {
                                		this.getStore().load({params: this.getApiParams()});
                            		}
                        		}
                    		}
                		}
                	},
                	scope: this
            	}
            }
        });

        me.callParent(arguments);
        
        me.getStore().getProxy().setExtraParam("withDistributions", true);
        
    }
    
});

Ext.define('Voyant.panel.Documents', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel','Voyant.util.Downloadable'],
	alias: 'widget.documents',
	isConsumptive: true,
    statics: {
    	i18n: {
			newCorpusError: 'There was an error creating the new the corpus. You may not have permission to do this.'
    	},
    	api: {
    		query: undefined,
    		docIndex: undefined,
    		docId: undefined
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    
    MODE_EDITING: 'editing',
    MODE_NORMAL: 'normal',
    config: {
    	options: [{
    		xtype: 'stoplistoption'
    	},
        	{xtype: 'categoriesoption'}
        ],
    	mode: this.MODE_NORMAL
    },

    constructor: function(config) {
    	
    	var store = Ext.create("Voyant.data.store.Documents", {
    	    selModel: {pruneRemoved: false},
    	    proxy: {
    	    	extraParams: {
    	    		forTool: 'documents'
    	    	}
    	    }
    	});
    	
    	var dockedItemsItems = [{
            xtype: 'querysearchfield'
        }, {
            xtype: 'totalpropertystatus'
        }]
    	
    	var me = this;
    	
    	if (!config || config.mode!=this.MODE_EDITING) {
    		dockedItemsItems.push({
            	text: this.localize("modify"),
            	tooltip: this.localize("modifyTip"),
    			glyph: 'xf044@FontAwesome',
    			scope: this,
    			itemId: 'modifyButton',
            	handler: function(btn) {
            		var win = Ext.create('Ext.window.Window', {
            		    title: this.localize("title"),
            		    modal: true,
            		    width: "80%",
            		    minWidth: 300,
            		    minHeight: 200,
            		    height: "80%",
            		    layout: 'fit',
            		    frame: true,
            		    border: true,
            		    items: {
            		    	xtype: 'documents',
            		    	mode: this.MODE_EDITING,
            		    	corpus: this.getStore().getCorpus(),
            		    	header: false,
            		    	viewConfig: {
            		            plugins:{
            		                ptype:'gridviewdragdrop'
            		            },
            		            listeners: {
            		            	beforedrop: function(node, data, overModel, dropPosition, dropHandlers) {
            		            		if (this.getStore().getCount()<this.getStore().getCorpus().getDocumentsCount()) {
            		            			var panel = this.up("panel");
            		        				Ext.Msg.show({
            		        				    title: panel.localize('error'),
            		        				    message: panel.localize('reorderFilteredError'),
            		        				    buttons: Ext.Msg.OK,
            		        				    icon: Ext.Msg.ERROR
            		        				});
            		            			return false;
            		            		}
            		            		return true;
            		            	}
            		            }
            		    	}
            		    },
            		    buttons: [{
                			text: this.localize('add'),
                			tooltip: this.localize("addTip"),
                			glyph: 'xf067@FontAwesome',
                			handler: function(btn) {
                				btn.up("window").close();
                				Ext.create('Ext.window.Window', {
                					header: false,
                        		    modal: true,
                        		    layout: 'fit',
                        		    items: {
                        		    	xtype: 'corpuscreator',
                        		    	corpus: this.getStore().getCorpus()
                        		    }
                        		}).show();
                			},
                			scope: this
                		}, {
                			text: this.localize('remove'),
                			tooltip: this.localize("removeTip"),
                			glyph: 'xf05e@FontAwesome',
                			hidden: this.getStore().getCorpus().getDocumentsCount()==1,
                			handler: this.keepRemoveReorderHandler,
                			itemId: 'remove',
                			scope: this
                		}, {
                			text: this.localize('keep'),
                			tooltip: this.localize("keepTip"),
                			glyph: 'xf00c@FontAwesome',
                			hidden: this.getStore().getCorpus().getDocumentsCount()==1,
                			handler: this.keepRemoveReorderHandler,
                			itemId: 'keep',
                			scope: this
                		}, {
                			text: this.localize('reorder'),
                			tooltip: this.localize("reorderTip"),
                			glyph: 'xf0dc@FontAwesome',
                			hidden: this.getStore().getCorpus().getDocumentsCount()==1,
                			handler: this.keepRemoveReorderHandler,
                			itemId: 'reorder',
                			scope: this
                		},{
            		        text: 'Cancel',
                			glyph: 'xf00d@FontAwesome',
            		        handler: function(btn) {
            		        	btn.up("window").close();
            		        }
            		    }]
            		}).show();

            	}
    		}, {
    			text: this.localize('downloadButton'),
		    	glyph: 'xf019@FontAwesome',
    			itemId: 'downloadButton',
    			handler: function() {
    				me.downloadFromCorpusId(me.getStore().getCorpus().getId())
    			}
    		})
    	}
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
	    	columns:[
	    	   {
	    		   xtype: 'rownumberer',
	    	        renderer: function(value, metaData, record) {return record.getIndex()+1},
	    	        sortable: false
	    	    },{
	    	        text: this.localize('documentTitle'),
	    	        dataIndex: 'title',
	    	        sortable: true,
	    	        renderer: function(val, metadata, record) {return record.getTitle();},
	    	        flex: 3
	    	    },{
	    	        text: this.localize('documentAuthor'),
	    	        dataIndex: 'author',
	    	        sortable: true,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getAuthor();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('documentPubDate'),
	    	        dataIndex: 'pubDate',
	    	        sortable: true,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getPubDate();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('documentPublisher'),
	    	        dataIndex: 'publisher',
	    	        sortable: false,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getPublisher();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('documentPubPlace'),
	    	        dataIndex: 'pubPlace',
	    	        sortable: false,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getPubPlace();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('documentKeyword'),
	    	        dataIndex: 'keyword',
	    	        sortable: false,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getKeyword();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('documentCollection'),
	    	        dataIndex: 'collection',
	    	        sortable: false,
	    	        hidden: true,
	    	        renderer: function(val, metadata, record) {return record.getCollection();},
	    	        flex: 2
	    	    },{
	    	        text: this.localize('tokensCountLexical'),
	    	        dataIndex: 'tokensCount-lexical',
	    	        renderer: Ext.util.Format.numberRenderer('0,000'),
	    	        sortable: true,
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('typesCountLexical'),
	    	        dataIndex: 'typesCount-lexical',
	    	        renderer: Ext.util.Format.numberRenderer('0,000'),
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('typeTokenRatioLexical'),
	    	        dataIndex: 'typeTokenRatio-lexical',
	    	        renderer: function(val) {return Ext.util.Format.percent(val)},
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('averageWordsPerSentence'),
	    	        dataIndex: 'averageWordsPerSentence',
	    	        renderer: Ext.util.Format.numberRenderer('0,000.0'),
	            	tooltip: this.localize("averageWordsPerSentenceTip"),
	    	        width: 'autoSize'
	    	    },{
	    	        text: this.localize('language'),
	    	        dataIndex: 'language',
	    	        hidden: true,
	    	        renderer: function(val, metaData, record, rowIndex, colIndex, store, view) {return view.ownerCt.getLanguage(val);},
	    	        width: 'autoSize'
	    	    }
	    	],
	    	
	        store: store,
	    	
	    	selModel: {
	    		type: 'rowmodel',
	    		mode: 'MULTI',
                listeners: {
                    selectionchange: {
                    	fn: function(sm, selections) {
                    		this.getApplication().dispatchEvent('documentsClicked', this, selections, this.getStore().getCorpus());
                    	},
                    	scope: this
                    }
                }
            },
            
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: dockedItemsItems
            }]
    	});
    	
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {

    		this.store.setCorpus(corpus);

    		if (this.isVisible()) {
        		this.store.load({params: this.getApiParams()});
    		} else {
    			this.on('afterrender', function() {
            		this.store.load({params: this.getApiParams()});
    			}, this);
    		}

			var app = this.getApplication();
    		if (this.hasCorpusAccess(corpus) === false || (app.getAllowDownload && app.getAllowDownload() === 'false')) {
    			this.queryById('modifyButton').hide();
    			this.queryById('downloadButton').hide();
    		}
    	});
    	
    	this.on("activate", function() { // load after tab activate (if we're in a tab panel)
    		if (this.getStore().getCorpus()) {
    			this.getStore().load({params: this.getApiParams()});
    		}
    	}, this);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('query', function(src, query) {
    		this.setApiParam('query', query);
    		this.store.load({params: this.getApiParams()});
    	})
    	
    	if (config.embedded) {
        	if (Ext.getClass(config.embedded).getName() == "Voyant.data.model.Corpus") {
        		config.corpus = config.embedded
        	}
        	else if (Ext.getClass(config.embedded).getName() == "Voyant.data.store.Documents") {
        		this.store.setRecords(config.embedded.getData())
        		config.corpus = config.embedded.getCorpus()
        	}
    		
    	}
    	
    	// if we have a corpus, load it
    	if (config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus)
    	}
    },
    
    keepRemoveReorderHandler: function(btn) {
    	// we're not sure which scope we're in, so ensure we're talking about this buttons panel
		var panel = btn.up("window").down("documents");
		var selection = panel.getSelection();
		var docs = panel.getStore().getCorpus().getDocumentsCount();
		var btnMode = btn.getItemId();
		// if reordering, check to make sure that we're not looking at a subset
		if (btnMode=='reorder') {
			if (panel.getStore().getCount()<docs) {
				return Ext.Msg.show({
				    title: this.localize('error'),
				    message: this.localize('reorderFilteredError'),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR
				});
			}
			else {
				docIndex = [];
				panel.getStore().each(function(doc) {
					docIndex.push(doc.getIndex())
			    }, this);
				for (var i=1; i<docIndex.length; i++) {
					if (docIndex[i-1]>docIndex[i]) {
						return Ext.Msg.confirm(panel.localize('newCorpus'), new Ext.Template(panel.localize(btnMode+'Documents')).applyTemplate([selection.length]), function(confirmBtn){
							if (confirmBtn==='yes') {
								docIndex = [];
								this.getStore().each(function(doc) {
									docIndex.push(doc.getIndex())
							    }, this);
								var params = {docIndex: docIndex};
								params[btnMode+"Documents"] = true;
								this.editCorpus(params)
							}
						}, panel);
					}
				}
				// if we get here it's because nothing's been reordered
				return Ext.Msg.show({
				    title: this.localize('error'),
				    message: this.localize('reorderOriginalError'),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR
				});
			}
			
		}
		
		if (selection.length>0) {
			if (selection.length==docs) {
				if (docs==1) {
					return Ext.Msg.show({
					    title: this.localize('error'),
					    message: this.localize('onlyOneError'),
					    buttons: Ext.Msg.OK,
					    icon: Ext.Msg.ERROR
					});
				}
				else {
					return Ext.Msg.show({
					    title: this.localize('error'),
					    message: this.localize('allSelectedError'),
					    buttons: Ext.Msg.OK,
					    icon: Ext.Msg.ERROR
					});
				}
			}
			else {
				return Ext.Msg.confirm(this.localize('newCorpus'), new Ext.Template(this.localize(btnMode+'SelectedDocuments')).applyTemplate([selection.length]), function(confirmBtn){
					if (confirmBtn==='yes') {
						docIndex = [];
						selection.forEach(function(doc){
							docIndex.push(doc.getIndex())
						})
						var params = {docIndex: docIndex};
						params[btnMode+"Documents"] = true;
						this.editCorpus(params)
					}
				}, panel);
			}
		}
		else if (panel.getApiParam("query") && panel.getStore().getCount()<docs) {
			return Ext.Msg.confirm(this.localize('newCorpus'), new Ext.Template(this.localize(btnMode+'FilteredDocuments')).applyTemplate([selection.length]), function(confirmBtn){
				if (confirmBtn==='yes') {
					docIndex = [];
					this.getStore().each(function(doc) {
						docIndex.push(doc.getIndex())
				    }, this);
					var params = {docIndex: docIndex};
					params[btnMode+"Documents"] = true;
					this.editCorpus(params)
				}
			}, panel);
		}
		else {
			return Ext.Msg.show({
			    title: this.localize('error'),
			    message: this.localize('selectOrFilterError'),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
		}    	
    },
    
    editCorpus: function(params) {
    	
    	Ext.apply(params, {
    		tool: 'corpus.CorpusManager',
    		corpus: this.getStore().getCorpus().getId()
    	})

    	// mask main viewport while we create a new corpus
    	var app = this.getApplication();
    	var view = app.getViewport();
		view.mask(this.localize("Creating new corpus…"));
    	Ext.Ajax.request({
    		url: this.getApplication().getTromboneUrl(),
    		method: 'POST',
    		params: params,
    		success: function(response) {
    			view.unmask();
    			var obj = Ext.decode(response.responseText);
				app.openUrl(app.getBaseUrl()+"?corpus="+obj.corpus.id);
//    			view.mask("Loading new corpus…")
//    			new Voyant.data.model.Corpus({corpus: obj.corpus.id}).then(function(corpus) {
//    				view.unmask();
//    				app.openUrl(app.getBaseUrl()+"/?corpus="+obj.corpus.id)
//    				app.dispatchEvent('loadedCorpus', app, corpus);
//    			}).fail(function(message, response) {
//    				view.unmask();
//    				app.showErrorResponse({message: message}, response);
//    			});
    		},
			failure: function(response) {
				view.unmask();
				Ext.Msg.show({
					title: this.localize('error'),
					message: this.localize('newCorpusError'),
					buttons: Ext.Msg.OK,
					icon: Ext.Msg.ERROR
				});
			},
			scope: this
    	});
    	
    	// close editing window if we're in modal mode, should happen asynchronously while new corpus is created
    	var win = this.up("window");
    	if (win && win.isFloating()) {win.close()}
    }
})
Ext.define('Voyant.panel.DocumentsFinder', {
	extend: 'Ext.grid.Panel',
	require: ['Voyant.data.store.DocumentQueryMatches','Ext.grid.plugin.CellEditing'],
	mixins: ['Voyant.panel.Panel'/*,'Voyant.util.Localization'*/],
	alias: 'widget.documentsfinder',
    statics: {
    	i18n: {
    	}
    },
    config: {
    	exportGridAll: false // prevents export all options from grid
    },

    constructor: function(config) {
    	
        this.cellEditing = Ext.create("Ext.grid.plugin.CellEditing", {
            clicksToEdit: 1
        });

        this.cellEditing.on('edit', this.onEditComplete, this);
    	
    	var me = this;
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		emptyText: this.localize("emptyText"),
    		plugins: [this.cellEditing],
    		bbar: [
    		       {
                       text: this.localize('addRow'),
                       glyph: 'xf055@FontAwesome',
                       handler: this.addRow,
                       scope: this
    		       },{
                       text: this.localize('exportNewCorpus'),
                       disabled: true,
                       glyph: 'xf08e@FontAwesome',
                       tooltip: this.localize('exportNewCorpusTip'),
                       handler: function() {
                    	   var query = this.getQueryFromStore();
                    	   if (query) {
                    		   this.setLoading(true);
	   	               			var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
		            			documentQueryMatches.load({
		            				params: {query: query, createNewCorpus: true},
		            				callback: function(records, operation, success) {
		                     		   this.setLoading(false);
		            					if (success) {
		            						var corpus = operation.getProxy().getReader().rawData.documentsFinder.corpus;
		            						var url = this.getBaseUrl()+'?corpus='+corpus;
		                         		   Ext.Msg.alert({
		                        			   title: this.localize('title'),
		                        			   message: "<a href='"+url+"' target='_blank'>New Corpus</a>"
		                        		   })
		            					}
		            					else {
		            						Ext.create("Voyant.util.ResponseError", {
		            							msg: this.localize("unsuccessfulQuery"),
		            							response: operation.getError().response
		            						}).show();
		            					}
		            				},
		            				scope: this
		            			})
                    		   
                    	   }
                    	   else {
                    		   Ext.Msg.alert({
                    			   title: this.localize('title'),
                    			   message: this.localize('noMatches')
                    		   })
                    	   }
                       },
                       scope: this,
                       cls: 'exportBtn'
    		       },{
    		    	   xtype: 'tbtext',
    		    	   name: 'status',
    		    	   cls: 'status'
    		       }
    		],
	    	columns:[
 	    	    {
	    	        text: this.localize('query'),
	    	        dataIndex: 'query',
	    	        renderer: function(value) {
	    	        	return Ext.isEmpty(value) ? '<span class="placeholder">'+me.localize('emptyQuery') + '</span>' : value;
	    	        },
	    	        editor: true,
	    	        minWidth: 150,
	    	        maxWidth: 300
	    	    },{
	    	        text: this.localize('field'),
	    	        dataIndex: 'field',
	    	        editor: {
	    	        	xtype: 'combo',
	                    typeAhead: true,
	                    triggerAction: 'all',
	                    forceSelection: true,
	                    value: '',
	                    valueField: 'value',
	                    listeners: {
	                    	change:function() {
	                    	  if (Ext.isEmpty(this.getValue())) {
		                    	    this.reset();
		                    	  }
		                    	}
	                    },
	                    store: new Ext.data.Store({
	                        fields: ['text','value'],
	                		data: [[this.localize('textField'),'text'],[this.localize('advancedField'),'advanced']]
	                    })
	    	        },
	    	        width: 150,
                    renderer: function(v) {return Ext.isEmpty(v) ? '' : me.localize(v+"Field")}
	    	    },{
	    	        text: this.localize('operator'),
	    	        dataIndex: 'operator',
	    	        editor: {
	    	        	xtype: 'combo',
	                    forceSelection: true,
	                    store: new Ext.data.Store({
	                        autoDestroy: true,
	                        fields: ['text','value'],
	                        displayField:  'text',
	                        valueField: 'value',
	                		data: [{text:'AND',value:'+'},{text:'OR',value:''}]
	                    })
	    	        },
	    	        minWidth: 75,
	    	        maxWidth: 75
	    	    },{
	    	        text: this.localize('count'),
	    	        dataIndex: 'count',
	    	        renderer: function(value, metadata, record) {
	    	        	return Ext.isEmpty(record.get('query')) ? '' : Ext.util.Format.number(value, '0,000')
	    	        },
	    	        minWidth: 100,
	    	        maxWidth: 100
	    	    },{
	    	    	xtype: 'actioncolumn',
	                width: 25,
	                getGlyph: 'xf014@FontAwesome',
	                tooltip: this.localize('deleteQueryTip'),
	                menuDisabled: true,
	                sortable: false,
	                handler: this.removeRow,
	                scope: this
	    	    }
	    	],
	    	
	    	store: new Ext.data.Store({
                // destroy the store if the grid is destroyed
                autoDestroy: true,
                fields: ['id','operator','field','query','count'],
	    		data: [['','','','',0]]
            })
      	});
    			
        this.callParent(arguments);
        
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
        
  
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		var docs = corpus.getDocuments();
    		if (docs && docs.getCount()>0) {
    			var doc = docs.getDocument(0);
    			var records = [];
    			["title","author","pubDate","publisher","pubPlace"].forEach(function(field) {
    				if (!Ext.isEmpty(doc.get(field))) {
    					records.push([this.localize(field+'Field'),field])
    				}
    			}, this);
    			if (records) {
    				var editor = this.getColumnManager().getHeaderByDataIndex("field").getEditor();
    				var store = editor.getStore();
    				store.each(function(record) {
    					records.push([record.get('text'), record.get('value')]);
    				}, this);
    				editor.setStore(Ext.create("Ext.data.Store",{
    					fields: ['text','value'],
    					data: records
    				}))
    			}
    			this.updateStatus(0);
    			this.setLoading(false);
    		}
    	})
    	
    },
    
    removeRow:function(grid, rowIndex) {
    	this.getStore().removeAt(rowIndex);
    	if (this.getStore().getCount()==0) {this.addRow();}
    	this.updateAggregate();
    },
    
    addRow: function() {
    	this.store.loadData([['','','','',0]], true);
    },
    
    onEditComplete: function(editor, context) {
    	
    	
    	var query = this.getQueryFromRecord(context.record);
		if (Ext.isEmpty(query)) {
			context.record.set('count','');
			this.updateAggregate();
		}
		else {
			var cell = context.view.getCell(context.record, this.getColumnManager().getHeaderByDataIndex("count"));
			cell.mask("loading");
			var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
			documentQueryMatches.load({
				params: {
					query: query
				},
				callback: function(records, operation, success) {
					cell.unmask();
					if (success) {
						context.record.set('count', records.length==0 ? 0 : records[0].get('count'))
					}
					else {
						Ext.create("Voyant.util.ResponseError", {
							msg: this.localize("unsuccessfulQuery"),
							response: operation.getError().response
						}).show();
						context.record.set('count',0);
					}
					this.updateAggregate();
				},
				scope: this
			})
		}

    },
    
    getQueryFromRecord: function(record) {
		if (Ext.isEmpty(record) || Ext.isEmpty(record.get('query'))) {return ""}
		var query = record.get('query').trim();
		if (Ext.isEmpty(query)) {return ""}
		var field = record.get('field');
		return Ext.isEmpty(field ? field.trim() : field) ? query : field+":"+query
    },
    
    getQueryFromStore: function() {
    	var query = "";
 		this.getStore().each(function(record) {
 			var q = this.getQueryFromRecord(record);
 			if (!Ext.isEmpty(q)) {
 				if (!Ext.isEmpty(query)) {
 					var op = record.get('operator');
 					query += op== 'AND' ? ' + ' : ' | '
 				}
 				query+=q
 			}
 		}, this)
 		console.warn(query)
 		return query;
    },
    
    updateAggregate: function() {
    	var count = this.getStore().sum('count');
    	if (!count || typeof count == 'string') {
    		this.updateStatus(0);
    	}
    	else if (count==1) {
    		var count = this.getStore().getAt(0).get('count');
    		this.updateStatus(this.getStore().getAt(0).get('count'))
    	}
    	else {
    		
    		var query = this.getQueryFromStore();
    		if (!Ext.isEmpty(query)) {
            	if (!this.status) {this.status=this.down("[cls~=status]")} // make sure we have status for masking
    			this.status.mask(this.localize("loading"));
    			var documentQueryMatches = this.getCorpus().getDocumentQueryMatches();
    			documentQueryMatches.load({
    				params: {query: query},
    				callback: function(records, operation, success) {
    					
    					this.status.unmask();
    					if (success) {
    						this.updateStatus(records[0].get('count'));
    					}
    					else {
    						Ext.create("Voyant.util.ResponseError", {
    							msg: this.localize("unsuccessfulQuery"),
    							response: operation.getError().response
    						}).show();
    						this.updateStatus(0);
    					}
    				},
    				scope: this
    			})
    		}
    	}
    },
    
    updateStatus: function(count) {
    	if (!this.status) {this.status=this.down("[cls~=status]")}
    	if (!this.exportBtn) {this.exportBtn=this.down("[cls~=exportBtn]")}
    	if (count==0) {
        	this.status.update(new Ext.XTemplate(this.localize('noMatches')).apply([this.getCorpus().getDocumentsCount()]))
    	}
    	else {
    		this.status.update(new Ext.XTemplate(this.localize('queryMatches')).apply([count,this.getCorpus().getDocumentsCount()]))
    	}
    	this.exportBtn.setDisabled(count==0);
    	
    }
    
})
Ext.define('Voyant.panel.Embedder', {
	extend: 'Ext.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.embedder',
	statics: {
		i18n: {
			title: 'Embedder',
			url: 'URL',
			go: 'Go',
			help: 'Embedder provides a way to embed a web page into your Voyant Tools experience.',
			helpTip: 'Embedder provides a way to embed a web page into your Voyant Tools experience.'
		},
		api: {
			url: undefined
		},
		glyph: 'xf0c1@FontAwesome'
	},
	constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		this.setApiParam('url', config.url);

        this.callParent(arguments);
		
		this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
	initComponent: function() {
		Ext.apply(this, {
			title: this.localize('title'),
			layout: {
				type: 'fit'
			},
			items: {
				xtype: 'uxiframe',
				src: this.getApiParam('url')
			},
			tbar: [{
				xtype: 'textfield',
				value: this.getApiParam('url'),
				emptyText: this.localize('url'),
				listeners: {
					specialkey: function(field, e){
						if (e.getKey() == e.ENTER) {
							field.up('panel').down('uxiframe').load(field.getValue());
						}
					}
				}
			},{
				xtype: 'button',
				text: this.localize('go'),
				handler: function(btn) {
					var url = btn.prev('textfield').getValue();
					btn.up('panel').down('uxiframe').load(url);
				}
			}]
		});
		
		this.callParent();
	},
	loadUrl: function(url) {
		this.down('uxiframe').load(url);
	}
});
// assuming Bubblelines library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Fountain', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.fountain',
    statics: {
    	i18n: {
    		title: "FountainMeter"
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		docIndex: 0,
    		
    		speed: 30,
    		
    		groups: undefined
    			
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	audio: false,
    	words: [],
    	groups: {},
    	moveWordsTimeout: undefined
	},
	
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	Ext.apply(this, {
    		title: this.localize('title'),
    		layout: {
    			type: 'hbox',
    			align: 'stretch'
    		},
    		items: [{
        		html: '<svg></svg>',
        		itemId: 'fountain',
        		flex: 2
    		},{
    			flex: 1,
    			layout:  'vbox',
    			items: [{
    				   xtype: 'polar',
    				   itemId: 'gauge',
    				   width: 300,
    				   flex: 1,
    				   store: {
    				       fields: ['mph', 'fuel', 'temp', 'rpm'],
    				       data: [{val: 10}]
    				   },
    				   series: {
    				       type: 'gauge',
    				       colors: this.getApplication().getColorPalette(this.getApplication().getApiParam('palette'), true),
    				       angleField: 'val',
    				       donut: 20
    				   }
    				},{
		    			width: 300,
		    			height: 16,
    					items: {
    		    			xtype: 'sparklineline',
        				    itemId: 'gaugsparkline',
    		    			values: [0,1,2,34],
    		    			height: 16,
    		    			width: 300
    					},
		    			listeners: {
		    				afterrender: function(cmp) {
		    					cmp.getTargetEl().setStyle("cursor", "pointer");
			    				cmp.getTargetEl().on("click", function(e, t, eOpts) {
	    					    	clearTimeout(this.getMoveWordsTimeout());
		    						this.getWords().forEach(function(word) {

		    							if (word.svg) {
		    								word.svg.remove();
		    								delete word.svg;
		    							}
		    							word.direction = -1; // reset
		    						})
		    						var pos = Math.floor(e.event.offsetX * this.getWords().length / t.offsetWidth)
		    						this.moveWords(pos);
		    					}, this);
		    				},
		    				scope: this
		    			}
    				}]
    		}],
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					fieldLabel: this.localize('speed'),
					labelAlign: 'right',
					labelWidth: 40,
					width: 100,
					increment: 1,
					minValue: 1,
					maxValue: 60,
					value: 30,
					listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(parseInt(this.getApiParam("speed")));
	                		if (this.bubbles) {this.bubbles.frameRate(cmp.getValue())}
	                		this.setAudio(cmp.getValue());
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('speedTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    changecomplete: function(cmp, val) {
	                    	this.setApiParam('speed', val);
	                		if (this.bubbles) {this.bubbles.frameRate(val)}
	                    },
	                    scope: this
					}
				}]
    		}]
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		this.loadDocument();
    	}, this);
    	
    },
    
    loadDocument: function() {
    	var me = this;
    	var docIndex = parseInt(this.getApiParam('docIndex')) || 0;
    	this.getCorpus().getWordsArray({docIndex: docIndex, stopList: 'auto'}).then(function(words) {

    		// fold to lower case
    		var lcwords = words.map(function(w) {return w.toLowerCase()});
    		
    		// if we don't have any groups of words, form them based on words that are longer than four letters
    		if (me.getApiParam("groups")==undefined) {
    			var group = {};
    			lcwords.forEach(function(w) {
    				if (w.length>5 && !(w in group)) {
    					group[w] = w.length;
    				} 
    			});
    			var maxLen = Math.max.apply(this, Object.values(group))
    			var lenVal = d3.scaleLinear().domain([4,maxLen]).range([.5,1])
    			for (var w in group) {
    				group[w] = lenVal(group[w]); // convert length to val between 0 and 1
    			}
    			me.setGroups({length: {
    				color: me.getApplication().getColorForTerm("length"),
    				terms: group
    			}})
    		}

    		var el = me.getComponent('fountain').getTargetEl();
			var svgEl = el.down("svg");
    		svgEl.set({width: el.getWidth(), height: el.getHeight()});
    		var svgDom = svgEl.dom
    		var svg = d3.select(svgDom);
    		svg.selectAll("*").remove(); // clear
    		
    		// create words and set min height (highest point)
    		var types = {};
    		var groups = me.getGroups();

    		me.setWords(words.slice(0,1000).map(function(w) {
    			var word = new me.FountainWord(w.toLowerCase());
    			if (word.word in types) {types[word.word]++}
    			else {types[word.word]=1;}
    			word.min = parseInt(Math.random()*svgDom.clientHeight*.05);
    			var yshift = Math.sqrt(Math.random()*10)
    			word.yshift = Math.random()*2<1 ? - yshift : yshift;
    			word.jump = svgDom.clientHeight/10
    			word.groupVals = {};
    			for (var g in groups) {
    				if (word.word in groups[g].terms) {
    					word.groupVals[g] = groups[g].terms[word.word]
    				}
    			}
    			return word;
    		}));
    		var max = Math.max.apply(this, Object.values(types));
    		var fontSize = d3.scaleLog().domain([1,Math.max.apply(this, Object.values(types))]).range([4,12]);
    		me.getWords().forEach(function(word) {
    			word.fontSize = fontSize(types[word.word])
    		})
    		me.moveWords();
    	})
    },
    
    FountainWord: function(word) {
    	this.word = word;
    	this.direction = -1;
    },
    
    moveWords: function(until) {

    	var words = this.getWords(),
    		svg = this.getComponent('fountain').getTargetEl().down("svg").dom,
			height = svg.clientHeight,
			width = svg.clientWidth,
			groups = this.getGroups();
		var opacity = d3.scaleLinear().domain([0,height]).range([1,0]);

		var gaugeVals = [];
		var seen = 0;
    	for (var i=0; i<words.length; i++) {
    		seen++;
    		
			// make sure to count group hits for all words since start to current point
			if (Object.keys(words[i].groupVals).length==0) {
				gaugeVals.push(0)
			} else {
				Object.values(words[i].groupVals).forEach(function(val) {
					gaugeVals.push(val);
				});
			}
			
    		if (words[i].direction<0) { // going up
    			
				
    			if (!words[i].svg) {
    	    		var word = d3.select(svg)
    	    			.append("text")
    	    			.text(words[i].word)
    	    			.attr("font-size", words[i].fontSize)
    	    			.attr("text-anchor", "middle")
    	    			.attr("x", width/2)
    	    			.attr("y", height-(Math.random()*height)/5)
    	    			.attr("fill", Object.keys(words[i].groupVals).length==0 ? "black" : this.getApplication().getColorForTerm(Object.keys(words[i].groupVals).shift(), true));
    	    		words[i].ys = [height];
    	    		words[i].svg = word;
    	    		if (!until || i>until) {
    	    			break;
    	    		}
    			} else {
    				var y = parseInt(words[i].svg.attr("y"));
        			var delta = y-words[i].min;
        			var change = delta/5
        			words[i].svg.attr("y", y-change);
        			words[i].svg.attr("x", parseInt(words[i].svg.attr("x"))+words[i].yshift);
        			y = parseInt(words[i].svg.attr("y"))
        			words[i].ys.push(y);
        			if (y<=words[i].min) {
        				words[i].direction = 1;
        			}
    			}
    			
    		} else if (words[i].direction>0) { // going down
    			if (words[i].svg && words[i].ys.length>0) {
        			words[i].svg.attr("y", words[i].ys.pop());
        			words[i].svg.attr("x", parseInt(words[i].svg.attr("x"))+words[i].yshift);
        			words[i].svg.attr("opacity", opacity(parseInt(words[i].svg.attr("y"))));
    				
    			} else {
    				words[i].direction = 0;
    			}
    		} else {
    			if ("svg" in words[i]) {
    				words[i].svg.remove()
    				delete words[i].svg
    			}
    		}
    		
    	}

    	var avg = gaugeVals.length==0 ? 0 : Ext.mean(gaugeVals)*100;
    	var polar = this.down("polar")
    	polar.getStore().getAt(0).set("val", avg)
    	polar.setSprites({
            type: 'text',
            text: Ext.util.Format.number(avg, '%0.0'),
            x: 145,
            y: 240
        });
    	var sparkline = this.down("sparklineline");
    	sparkline.setValues(gaugeVals.length>100 ? this.chunkify(gaugeVals, 100, true).map(function(vals) {return Ext.mean(vals)}) : gaugeVals);
    	sparkline.setWidth(seen*sparkline.ownerCt.getWidth()/words.length)
    	
    	this.setMoveWordsTimeout(Ext.defer(this.moveWords, 100, this));
    },
    
    // https://stackoverflow.com/questions/8188548/splitting-a-js-array-into-n-arrays
    chunkify: function(a, n, balanced) {
        if (n < 2)
            return [a];

        var len = a.length,
                out = [],
                i = 0,
                size;

        if (len % n === 0) {
            size = Math.floor(len / n);
            while (i < len) {
                out.push(a.slice(i, i += size));
            }
        }

        else if (balanced) {
            while (i < len) {
                size = Math.ceil((len - i) / n--);
                out.push(a.slice(i, i += size));
            }
        }

        else {

            n--;
            size = Math.floor(len / n);
            if (len % size === 0)
                size--;
            while (i < size * n) {
                out.push(a.slice(i, i += size));
            }
            out.push(a.slice(size * n));

        }

        return out;    	
    },
    
    initComponent: function() {
    	this.callParent(arguments);
    }
});
Ext.define('Voyant.panel.RezoViz', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.rezoviz',
	statics: {
		i18n: {
			timedOut: 'The entities call took too long and has timed out. Retry?',
			maxLinks: 'Max. Links',
			nerService: 'Entity Identification Service'
		},
		api: {
			query: undefined,
			mode: undefined,
			limit: 50,
			type: ['organization','location','person'],
			minEdgeCount: 2,
			terms: undefined,
			stopList: 'auto',
			docId: undefined,
			nerService: 'spacy'
		},
		glyph: 'xf1e0@FontAwesome'
	},
	
	config: {
		graphStyle: {
			link: {
				normal: {
					stroke: '#000000',
					strokeOpacity: 0.1
				},
				highlight: {
					stroke: '#000000',
					strokeOpacity: 0.5
				}
			}
		},

		options: [{xtype: 'stoplistoption'}]
	},
	
	constructor: function(config) {
		this.callParent(arguments);
		this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	
	initComponent: function() {
		var me = this;

		var graphStyle = {};
		var entityTypes = ['person', 'location', 'organization'];
		entityTypes.forEach(function(entityType) {
			var baseColor = me.getApplication().getColorForEntityType(entityType, true);
			var nFill = d3.hsl(baseColor);
			nFill.s *= .85;
			nFill.l *= 1.15;
			var nStroke = d3.hsl(baseColor);
			nStroke.s *= .85;
			var hFill = d3.hsl(baseColor);
			var hStroke = d3.hsl(baseColor);
			hStroke.l *= .75;
			graphStyle[entityType+'Node'] = {
				normal: {
					fill: nFill.toString(),
					stroke: nStroke.toString()
				},
				highlight: {
					fill: hFill.toString(),
					stroke: hStroke.toString()
				}
			}
		});
		this.setGraphStyle(Ext.apply(this.getGraphStyle(), graphStyle));

		Ext.apply(me, {
			title: this.localize('title'),
			layout: 'fit',
			items: {
				xtype: 'voyantnetworkgraph',
				applyNodeStyle: function(sel, nodeState) {
					var state = nodeState === undefined ? 'normal' : nodeState;
					var style = this.getGraphStyle().node[state];
					sel.selectAll('rect')
						.style('fill', function(d) { var type = d.type+'Node'; return me.getGraphStyle()[type][state].fill; })
						.style('stroke', function(d) { var type = d.type+'Node'; return me.getGraphStyle()[type][state].stroke; });
				},
				listeners: {
					nodeclicked: function(graph, node) {
						me.dispatchEvent('termsClicked', me, [node.term]);
					},
					edgeclicked: function(graph, edge) {
						me.dispatchEvent('termsClicked', me, ['"'+edge.source.term+' '+edge.target.term+'"~'+me.getApiParam('context')]);
					}
				}
			},
			dockedItems: [{
				dock: 'bottom',
				xtype: 'toolbar',
				overflowHandler: 'scroller',
				items: [{
					xtype: 'corpusdocumentselector'
				},{
					xtype: 'button',
					text: this.localize('categories'),
					menu: {
						items: [{
							xtype: 'menucheckitem',
							text: this.localize('people'),
							itemId: 'person',
							checked: true
						},{
							xtype: 'menucheckitem',
							text: this.localize('locations'),
							itemId: 'location',
							checked: true
						},{
							xtype: 'menucheckitem',
							text: this.localize('organizations'),
							itemId: 'organization',
							checked: true
						},{
							xtype: 'button',
							text: this.localize('reload'),
							style: 'margin: 5px;',
							handler: this.categoriesHandler,
							scope: this
						}]
					}
				},{
					xtype: 'button',
					text: this.localize('nerService'),
					menu: {
						items: [{
							xtype: 'menucheckitem',
							group: 'nerService',
							text: 'SpaCy',
							itemId: 'spacy',
							checked: true,
							handler: this.serviceHandler,
							scope: this
						},{
							xtype: 'menucheckitem',
							group: 'nerService',
							text: 'NSSI',
							itemId: 'nssi',
							checked: true,
							handler: this.serviceHandler,
							scope: this
						},{
							xtype: 'menucheckitem',
							group: 'nerService',
							text: 'Voyant',
							itemId: 'voyant',
							checked: false,
							handler: this.serviceHandler,
							scope: this
						}]
					}
				},{
					xtype: 'numberfield',
					itemId: 'minEdgeCount',
					fieldLabel: this.localize('minEdgeCount'),
					labelAlign: 'right',
					labelWidth: 120,
					width: 170,
					maxValue: 10,
					minValue: 1,
					allowDecimals: false,
					allowExponential: false,
					allowOnlyWhitespace: false,
					listeners: {
						render: function(field) {
							field.setRawValue(this.getApiParam('minEdgeCount'));
						},
						change: function(field, newVal) {
							if (field.isValid()) {
								this.setApiParam('minEdgeCount', newVal);
								this.preloadEntities();
							}
						},
						scope: this
					}
				},{
					xtype: 'slider',
					fieldLabel: this.localize('maxLinks'),
					labelAlign: 'right',
					labelWidth: 100,
					width: 170,
					minValue: 10,
					maxValue: 1000,
					increment: 10,
					listeners: {
						render: function(field) {
							field.setValue(this.getApiParam('limit'));
						},
						changecomplete: function(field, newVal) {
							this.setApiParam('limit', newVal);
							this.preloadEntities();
						},
						scope: this
					}
				}]
			}]
		});
		
		this.on('loadedCorpus', function(src, corpus) {
			if (this.isVisible()) {
				this.preloadEntities();
			}
		}, this);

		this.on('corpusSelected', function(src, corpus) {
			this.setApiParam('docId', undefined);
			this.preloadEntities();
		}, this);
		this.on('documentsSelected', function(src, docIds) {
			this.setApiParam('docId', docIds);
			this.preloadEntities();
		}, this);
		
		this.on('activate', function() { // load after tab activate (if we're in a tab panel)
			if (this.getCorpus()) {
				// only preloadEntities if there isn't already data
				if (this.down('voyantnetworkgraph').getNodeData().length === 0) {
					Ext.Function.defer(this.preloadEntities, 100, this);
				}
			}
		}, this);
		
		this.on('query', function(src, query) {this.loadFromQuery(query);}, this);
		
		me.callParent(arguments);

	},

	categoriesHandler: function(item) {
		var categories = [];
		item.up('menu').items.each(function(checkitem) {
			if (checkitem.checked) {
				categories.push(checkitem.itemId);
			}
		});
		
		this.setApiParam('type', categories);
		this.preloadEntities();
	},

	serviceHandler: function(menuitem) {
		this.setApiParam('nerService', menuitem.itemId);
		this.preloadEntities();
	},

	preloadEntities: function() {
		var me = this;
		new Voyant.data.util.DocumentEntities({annotator: this.getApiParam('nerService')}, function() {
			me.getEntities();
		});
	},

	getEntities: function() {
		this.down('voyantnetworkgraph').resetGraph();

		var corpusId = this.getCorpus().getId();
		var el = this.getLayout().getRenderTarget();
		el.mask(this.localize('loadingEntities'));

		Ext.Ajax.request({
			url: this.getApplication().getTromboneUrl(),
			method: 'POST',
			params: {
				tool: 'corpus.EntityCollocationsGraph',
				annotator: this.getApiParam('nerService'),
				type: this.getApiParam('type'),
				limit: this.getApiParam('limit'),
				minEdgeCount: this.getApiParam('minEdgeCount'),
				corpus: this.getCorpus().getId(),
				docId: this.getApiParam('docId'),
				stopList: this.getApiParam('stopList'),
				noCache: true
			},
			timeout: 120000,
			success: function(response) {
				el.unmask();
				var obj = Ext.decode(response.responseText);
				if (obj.entityCollocationsGraph.edges.length==0) {
					this.showError({msg: this.localize('noEntities')});
					var currMinEdgeCount = this.getApiParam('minEdgeCount');
					if (currMinEdgeCount > 1) {
						Ext.Msg.confirm(this.localize('error'), this.localize('noEntitiesForEdgeCount'), function(button) {
							if (button === 'yes') {
								var newEdgeCount = Math.max(1, currMinEdgeCount-1);
								this.queryById('minEdgeCount').setRawValue(newEdgeCount);
								this.setApiParam('minEdgeCount', newEdgeCount);
								this.preloadEntities();
							}
						}, this);
					}
				}
				else {
					this.processEntities(obj.entityCollocationsGraph);
				}
			},
			failure: function(response) {
				el.unmask();
				Ext.Msg.confirm(this.localize('error'), this.localize('timedOut'), function(button) {
					if (button === 'yes') {
						this.preloadEntities();
					}
				}, this);
			},
			scope: this
		});
	},

	processEntities: function(entityParent) {
		var nodes = entityParent.nodes;
		var edges = entityParent.edges;
		
		var el = this.getLayout().getRenderTarget();
		var cX = el.getWidth()/2;
		var cY = el.getHeight()/2;

		var visNodes = [];
		for (var i = 0; i < nodes.length; i++) {
			var n = nodes[i];

			visNodes.push({
				term: n.term,
				title: n.term + ' ('+n.rawFreq+')',
				type: n.type,
				value: n.rawFreq,
				fixed: false,
				x: cX,
				y: cY
			});
		}
		
		var visEdges = [];
		for (var i = 0; i < edges.length; i++) {
			var link = edges[i].nodes;

			var sourceId = nodes[link[0]].term;
			var targetId = nodes[link[1]].term;
			visEdges.push({
				source: sourceId,
				target: targetId,
				rawFreq: nodes[link[1]].rawFreq // TODO
			});
		}

		this.down('voyantnetworkgraph').loadJson({nodes: visNodes, edges: visEdges});
	}
	
});

Ext.define('Voyant.panel.Loom', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.panel.Panel'],
    alias: 'widget.loom',
    statics: {
        i18n: {
        	title: "Loom",
        	controls: "Controls",
        	frequenciesGroup: "Frequencies",
        	coverageGroup: "Coverage",
        	distributionsGroup: "Distribution",
        	termsGroup: "Terms",
        	inDocumentsLabel: "in documents",
        	inDocumentsLabelTip: "each term must be present in the number of documents defined by this range",
        	spanSomeLabel: "some documents",
        	spanSomeLabelTip: "each term must be present in at least one document defined by this range",
        	spanAllLabel: "all documents",
        	spanAllLabelTip: "each term must be present in all documents defined by this range",
        	spanOnlyLabel: "only documents",
        	spanOnlyLabelTip: "each term must be present in only the documents defined by this range",
        	rawFreqLabel: "raw frequency",
        	rawFreqLabelTip: "raw term frequencies for the term must be between these values (inclusively)",
        	rawFreqPercentileLabel: "raw frequency percentile",
        	rawFreqPercentileLabelTip: "raw term frequencies for the term must be between these percentile values (inclusively), this is useful for saying something like terms in the top 90th percentile which will provide 10% of words regardless of the variation in values.",
        	distributionsStdDevLabel: "standard deviation of distributions",
        	distributionsStdDevLabelTip: "the standard deviation of term distribution scores must be between the defined range of values (lower will be for values that are more consistent, higher will be for values that have greater variability)",
        	distributionsStdDevPercentileLabel: "percentile of standard deviations of distributions",
        	distributionsStdDevPercentileLabelTip: "the percentile of standard deviations of distributions must be between the defined range of values (lower will be for values that are more consistent, higher will be for values that have greater variability)",
        	termsLengthLabel: "term length",
        	termsLengthLabelTip: "the length (number of characters) of the term (word)",
        	termsLengthPercentileLabel: "term length percentile",
        	termsLengthPercentileLabelTip: "the percentile of the length (number of characters) of the term (word)",
        	distributionIncreasesLabel: "increases in distribution values",
        	distributionIncreasesLabelTip: "the number of increases of the distribution values must be between the defined range (inclusively)",
        	distributionConsecutiveIncreasesLabel: "consecutive decreases in distribution values",
        	distributionConsecutiveIncreasesLabelTip: "the number of consecutive decreases of the distribution values must be between the defined range (inclusively)",
        	distributionDecreasesLabel: "decreases in distribution values",
        	distributionDecreasesLabelTip: "the number of decreases of the distribution values must be between the defined range (inclusively)",
        	distributionConsecutiveDecreasesLabel: "consecutive decreases in distribution values",
        	distributionConsecutiveDecreasesLabelTip: "the number of consecutive decreases of the distribution values must be between the defined range (inclusively)",
        	distributionMaxLabel: "distribution maximum",
        	distributionMaxLabelTip: "the maximum of the distribution values must be between the defined range (inclusively)",
        	distributionMinLabel: "distribution minimum",
        	distributionMinLabelTip: "the minimum of the distribution values must be between the defined range (inclusively)",
        	presetsGroup: "pre-sets",
        	presetHighFreq: "terms that are high frequency",
        	presetHighFreqLonger: "terms that are longer and high frequency",
        	presetSingleDoc: "higher frequency terms that only occur once",
        	presetIncreaseDistributions: "terms that generally increase in frequency",
        	presetDecreaseDistributions: "terms that generally decrease in frequency ",
        	presetNearStartDistributions: "terms that peak in distribution toward the beginning ",
        	presetNearEndDistributions: "terms that peak in distribution toward the end ",
        	presetSporadicDistributions: "terms whose distributions vary the most",
        	visibleTerms: "max terms",
        	scaling: "scaling",
        	scaleLinear: "linear",
        	scaleLog: "logarithmic",
        	scaleSqrt: "square root"
        	
        },
        api: {
            limit: 500,
            stopList: 'auto',
            inDocuments: undefined,
            spanSome: undefined,
            spanAll: undefined,
            spanOnly: undefined,
            termLength: undefined,
            termsLengthPercentile: undefined,
            rawFreq: undefined,
            rawFreqPercentile: undefined,
            distributionsStdDev: undefined,
            distributionsStdDevPercentile: undefined,
            distributionIncreases: undefined,
            distributionDecreases: undefined,
            distributionConsecutiveIncreases: undefined,
            distributionConsecutiveDecreases: undefined,
            distributionMax: undefined,
            distributionMin: undefined,
            scaling: 'linear'
        },
        glyph: 'xf1e0@FontAwesome'
    },
    
    config: {
    	store: undefined,
    	terms: undefined,
    	options: [
    		{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}
    	],
    	controls: undefined
    },


    constructor: function(config) {
        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
        
    initComponent: function() {
    	
        this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
        
    	var controls = new Ext.util.MixedCollection({
    		allowFunctions: true
    	});
    	controls.addAll({
    		inDocuments: new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'inDocuments',
	    		initControl: function(store) {
	    			this.setMin(1);
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var count = record.getDistributions().filter(function(val) {return val>0}).length;
	        		return count >= this.getLow() && count <= this.getHigh();
	        	}
    		}),
    		spanSome :new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'spanSome',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length-1);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		for (var i=low; i<high+1; i++) {
	        			if (vals[i]>0) {return true}
	        		}
	        		return false;
	        	}
    		}),
    		spanAll :new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'spanAll',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length-1);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		for (var i=low; i<high+1; i++) {
	        			if (vals[i]==0) {return false}
	        		}
	        		return true;
	        	}
    		}),
    		spanOnly :new Voyant.util.LoomControl({
	    		group: 'coverage',
	    		name: 'spanOnly',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length-1);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		for (var i=0; i<vals.length; i++) {
	        			if (i<low || i>high) {
	        				if (vals[i]>0) {return false}
	        			} else {
	        				if (vals[i]==0) {return false}
	        			}
	        		}
	        		return true;
	        	}
    		}),
    		rawFreq :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'rawFreq',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			var vals = store.getRange().map(function(r) {return r.get('rawFreq')});
	    			this.setMin(Ext.Array.min(vals))
	    			this.setMax(Ext.Array.max(vals))
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), val = record.get("rawFreq");
	        		return val>=low && val <= high;
	        	}
    		}),
    		rawFreqPercentile :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'rawFreqPercentile',
	    		min: 0,
	    		max: 100,
	    		initControl: function(store) {
	    			this.vals = store.getRange().map(function(r) {return r.get('rawFreq')});
	    			this.vals.sort(function (a, b) {  return a - b;  });
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
	        			ind = Ext.Array.indexOf(this.vals, record.get("rawFreq")),
	        			val = Math.round(ind*100/this.vals.length)
	        		return val>=low && val <= high;
	        	}
    		}),
    		distributionsStdDev :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'distributionsStdDev',
	    		initControl: function(store) {
	    			var allvals = Ext.Array.flatten(store.getRange().map(function(r) {return r.getDistributions()}));
	    			// we'll scale to all available distributions, otherwise we're not making similar comparisons
	    			var scale = d3.scaleLinear().domain([d3.min(allvals),d3.max(allvals)]).range([0,100]);
	    			store.each(function(record) {
	    				if (record.get("distributionsStdDev")===undefined) {
	    					// https://derickbailey.com/2014/09/21/calculating-standard-deviation-with-array-map-and-array-reduce-in-javascript/
	    					// https://gist.github.com/Daniel-Hug/7273430
		    				var vals = record.getDistributions();
		    				var scaledVals = vals.map(function(v) {return scale(v)});
		    				var avg = Ext.Array.mean(scaledVals);
							var squareDiffs = vals.map(function(value){
								    var diff = value - avg;
								    var sqrDiff = diff * diff;
								    return sqrDiff;
							});
							var avgSquareDiff = Ext.Array.mean(squareDiffs);
							var stdDev = Math.sqrt(avgSquareDiff);
							record.set("distributionsStdDev", stdDev);
	    				}
	    			})
	    			var vals = store.getRange().map(function(r) {return r.get('distributionsStdDev')});
	    			this.setMin(Ext.Array.min(vals))
	    			this.setMax(Ext.Array.max(vals))
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
	        			val = record.get("distributionsStdDev");
	        		return val>=low && val <= high;
	        	}
    		}),
    		distributionsStdDevPercentile :new Voyant.util.LoomControl({
	    		group: 'frequencies',
	    		name: 'distributionsStdDevPercentile',
	    		min: 0,
	    		max: 100,
	    		initControl: function(store) {
	    			this.vals = store.getRange().map(function(r) {return r.get('distributionsStdDev')});
	    			this.vals.sort(function (a, b) {  return a - b;  });
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
        				ind = Ext.Array.indexOf(this.vals, record.get("distributionsStdDev")),
        				val = Math.round(ind*100/this.vals.length)
        			return val>=low && val <= high;
	        	}
    		}),
    		termsLength :new Voyant.util.LoomControl({
	    		group: 'terms',
	    		name: 'termsLength',
	    		offsetTipText: true,
	    		initControl: function(store) {
	    			var vals = store.getRange().map(function(r) {return r.get('term').length});
	    			this.setMin(Ext.Array.min(vals))
	    			this.setMax(Ext.Array.max(vals))
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), val = record.get("term").length;
	        		return val>=low && val <= high;
	        	}
    		}),
    		termsLengthPercentile :new Voyant.util.LoomControl({
	    		group: 'terms',
	    		name: 'termsLengthPercentile',
	    		min: 0,
	    		max: 100,
	    		initControl: function(store) {
	    			this.vals = store.getRange().map(function(r) {return r.get('term').length});
	    			this.vals.sort(function (a, b) {  return a - b;  });
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(),
        				ind = Ext.Array.indexOf(this.vals, record.get("term").length),
        				val = Math.round(ind*100/this.vals.length)
        			return val>=low && val <= high;
	        	}
    		}),
    		distributionIncreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionIncreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var increases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]>vals[i-1]) {
	        				increases++;
	        				if (increases>high) {return false}
	        			}
	        		}
	        		return increases>=low;
	        	}
    		}),
    		distributionConsecutiveIncreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionConsecutiveIncreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var increases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]>vals[i-1]) {
	        				increases++;
	        				if (increases>high) {return false}
	        			} else {
	        				increases=0;
	        			}
	        		}
	        		return increases>=low;
	        	}
    		}),
    		distributionDecreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionDecreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var decreases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]<vals[i-1]) {
	        				decreases++;
	        				if (decreases>high) {return false}
	        			}
	        		}
	        		return decreases>=low;
	        	}
    		}),
    		distributionConsecutiveDecreases :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionConsecutiveDecreases',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions();
	        		var decreases = 0;
	        		for (var i=1;i<vals.length;i++) {
	        			if (vals[i]<vals[i-1]) {
	        				decreases++;
	        				if (decreases>high) {return false}
	        			} else {
	        				decreases = 0;
	        			}
	        		}
	        		return decreases>=low;
	        	}
    		}),
    		distributionMax :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionMax',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions(), val = Ext.Array.max(vals);
	        		for (var i=low;i<high;i++) { // look at every value in case there are duplicate values
	        			if (vals[i]==val) {return true}
	        		}
	        		return false;
	        	}
    		}),
    		distributionMin :new Voyant.util.LoomControl({
	    		group: 'distributions',
	    		name: 'distributionMin',
	    		initControl: function(store) {
	    			this.setMax(store.getAt(0).getDistributions().length);
	        	},
	        	validateRecord: function(record) {
	        		var low = this.getLow(), high = this.getHigh(), vals = record.getDistributions(), val = Ext.Array.min(vals);
	        		for (var i=low;i<high;i++) { // look at every value in case there are duplicate values
	        			if (vals[i]==val) {return true}
	        		}
	        		return false;
	        	}
    		})
    	});

    	controls.each(function(control) {
    		var val = this.getApiParam(control.getName()), vals = (val || "").split(",");
    		control.setEnabled(val!==undefined);
    		if (vals.length==2) {
    			control.setLow(parseInt(vals[0]))
    			control.setHigh(parseInt(vals[1]))
    		}
    		control.on("change", function(control) {
    			if (control.getEnabled()) {
    				this.setApiParam(control.getName(), control.getLow()+","+control.getHigh());
    			} else {
    				this.setApiParam(control.getName(), undefined);
    			}
    			this.filterRecords();
    		}, this);
    	}, this);

    	this.setControls(controls);
    	
    	// used below in preset handlers
    	var me = this;
    	var clearApiParamsForControls = function() {
    		var currentParams = me.getApiParams();
    		var params = {};
    		me.controls.each(function(control) {
    			control.setEnabled(false, true);
    			var name = control.getName();
    			if (name in currentParams) {
    				me.setApiParam(name, undefined)
    			}
    		})
    	}

    	
    	var tbitems = [{
    		text: this.localize("presetsGroup"),
    		menu: {
    			items: [{
    				text: this.localize('presetHighFreq'),
    				handler: function() {
    					clearApiParamsForControls();
    			    	this.filterRecords();
    				},
    				scope: this
    			},{
    				text: this.localize('presetHighFreqLonger'),
    				handler: function() {
    					clearApiParamsForControls();
    					this.controls.getByKey("termsLengthPercentile").setEnabled(true, true).setValues(50,100, true);
    					this.controls.getByKey("rawFreqPercentile").setEnabled(true, true).setValues(50,100);
    				},
    				scope: this
    			},{
    				text: this.localize('presetSingleDoc'),
    				handler: function() {
    					clearApiParamsForControls();
    					this.controls.getByKey("inDocuments").setEnabled(true, true).setValues(1,1);
    				},
    				scope: this
    			},{
    				text: this.localize('presetIncreaseDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionIncreases");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(Math.round(max*.75),max);
    				},
    				scope: this
    			},{
    				text: this.localize('presetDecreaseDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionDecreases");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(Math.round(max*.75),max);
    				},
    				scope: this
    			},{
    				text: this.localize('presetNearStartDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionMax");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(0, Math.round(max*.2));
    				},
    				scope: this
    			},{
    				text: this.localize('presetNearEndDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					var control = this.controls.getByKey("distributionMax");
    					var max = control.getMax();
    					control.setEnabled(true, true).setValues(Math.round(max*.8), max);
    				},
    				scope: this
    			},{
    				text: this.localize('presetSporadicDistributions'),
    				handler: function() {
    					clearApiParamsForControls();
    					this.controls.getByKey("distributionsStdDevPercentile").setEnabled(true, true).setValues(80, 100);
    				},
    				scope: this
    			}]
    		}
    	}, {
    		xtype: 'tbspacer'
    	}];
    	["frequencies","coverage","distributions","terms"].map(function(group) {
    		tbitems.push({
    			text: this.localize(group+"Group"),
    			menu: {
    				items: controls.filterBy(function(control) {return control.getGroup()==group}).getRange().map(function(control) {
    					return {
    						xtype: 'menucheckitem',
    						checked: control.getEnabled(),
							text: this.localize(control.getName()+"Label"),
							tooltip: this.localize(control.getName()+"LabelTip"),
							listeners: {
								beforerender: function(cmp) {
									cmp.setChecked(control.getEnabled());
									control.on("change", function() {
										cmp.setChecked(control.getEnabled());
									})
								},
								click: function(cmp) {
									control.setEnabled(cmp.checked)
									cmp.getMenu().setDisabled(!cmp.checked)
									if (cmp.checked) {cmp.getMenu().show();}
									else {cmp.getMenu().hide()}
								}
    						},
							menu: {
								disabled: !control.getEnabled(),
								items: {
									xtype: 'multislider',
									width: 100,
									minValue: control.getMin() || 0,
									maxValue: control.getMax() || 0,
									values: [(control.getLow() || 0), (control.getHigh() || 0)],
									tipText: function(t) {
										return control.getOffsetTipText() ? t.value+1 : t.value;
									},
									listeners: {
    									beforerender: function(slider) {
    										slider.updateFromControl(control);
    										control.on("change", function() {
    											slider.updateFromControl(control);
    										})
    									},
    									changecomplete: function(slider) {
    										control.setValues(slider.getValues());
    									}
									},
									updateFromControl: function(control) {
										this.setMinValue(control.getMin() || 0);
										this.setMaxValue(control.getMax());
										this.setValue(0, control.getLow() || 0)
										this.setValue(1, control.getHigh()===undefined ? (control.getMax() || 0) : control.getHigh())
									}
								}
							}
    					}
    				}, this)
    			}
    		});
    	}, this);
    	
        Ext.apply(this, {
            title: this.localize('title'),
            layout: {
            	type: 'hbox',
            	align: 'stretch'
            },
            listeners: {
            	afterrender: function() {
            		var terms = this.getComponent("terms"), threads = this.getComponent("threads");
            		
            		// this is a quick and dirty implementation to mirror actions in the terms panel to the threads panel,
            		// but it should probably redone locally to the threads logic and using the tips
            		terms.on("termHovered", function(src, term) {
            			var thick = threads.getTargetEl().dom.querySelector("path[term="+term+"]");
            			if (thick) {
                			var fadeIt = function(node, time) {
                				opacity = node.getAttribute("opacity");
                				if (opacity>0) {
                					opacity-=.01;
                					node.setAttribute("opacity", opacity)
                					time=time/2
                					Ext.defer(fadeIt, time, this, [node, time]);
                				}
                			}   
                			thick.setAttribute("opacity", 1);
                			fadeIt(thick, 1000);
            			}
            		})
            	}
            },
            items: [{
            	itemId: 'terms',
            	width: 100,
            	layout: 'fit',
            	listeners: {
            		filterchange: function(store) {
            			var el = this.getTargetEl(), width = el.getWidth(), height = el.getHeight(), len = store.getCount();
            			el.setHtml(" ")
            			terms = store.getRange().map(function(r,i) {
            				return {
            					term: r.getTerm(),
            					col: Voyant.application.getColorForTerm(r.getTerm(), true),
            					x: width/2,
            					y: i*height/len
            				}
            			});
            			terms.sort(function(a, b) {return a.term.localeCompare(b.term)});
            			
            			// attempts to use fisheye code failed with larger number or words http://bl.ocks.org/jczaplew/8603055

            			
            			
          			  var svg = d3.select(el.dom).append("svg")
      			    .attr("width", width)
      			    .attr("height", height)
      			  .append("g")
      			    .attr("transform", "translate(-.5,-.5)");
          			  
          			var textHeight = Math.ceil(height/terms.length);
        			  var text = svg.selectAll("ytext")
      			    .data(terms)
      			  .enter().append("text")
      			    .text(function(d,i){return d.term})
      			    .attr("class", "ytext") 
      			    .attr("text-anchor", "middle")
    			  	.attr("x", width/2)
    			  	.attr("y", function(t, i) {return textHeight*i})
      			    .attr("fill", function(d) {return Voyant.application.getColorForTerm(d.term, true)})

            			var textHeight = Math.ceil(height/terms.length);

            			
            			var fisheye = d3.fisheye.circular()
	            		    .radius(50)
	            		    .distortion(2);
            			
            			yFisheye = d3.fisheye.scale(d3.scaleIdentity).domain([0, height]);
            			
            			var me = this;
            			svg.on("mousemove", function() {
            				var mouse = d3.mouse(this);
            					currentItem = Math.round(mouse[1]*terms.length/height),
            					currentItem = Math.min(currentItem, terms.length-1);
            				fisheye.focus(mouse[1]);
            				yFisheye.focus(mouse[1]);
            				
            			var nodes = text.nodes();
            			if (nodes[currentItem]) {
                			me.fireEvent("termHovered", me, nodes[currentItem].textContent)
            			}
            			
            			var fs = 14, y=Math.max(mouse[1],fs), fo=1;
            			d3.select(nodes[currentItem])
            				.attr("y", function(d) { return y })
            				.attr("font-size", fs)
            				.attr("fill-opacity", fo)
            				
            			var yin = undefined;
            			for (var i=currentItem-1;i>-1;i--) {
            				if (fs>=8) {
            					y-=fs
            					fs-=.5
            				} else {
            					if (yin==undefined) {
            						yin = y/i
            					}
            					y-=yin;
            				}
            				if (fo>.1) {fo-=.05}
                			d3.select(nodes[i])
            				.attr("y", function(d) { return y })
            				.attr("font-size", fs)
            				.attr("fill-opacity", fo)
            			}
            			
            			fs = 14, y=Math.max(mouse[1],fs), fo=1, yin=undefined;
            			

            			for (var i=currentItem+1,len=terms.length;i<len;i++) {
            				if (fs>=8) {
            					y+=fs
            					fs-=.5
            				} else {
            					if (yin==undefined) {
            						yin = (height-y)/(len-i)
            					}
            					y+=yin;
            				}
            				if (fo>.1) {fo-=.05}
                			d3.select(nodes[i])
            				.attr("y", function(d) { return y })
            				.attr("font-size", fs)
            				.attr("fill-opacity", fo)
            			}

            			})

            		}
            	}
            },{
            	itemId: 'threads',
//                html: '<canvas></canvas>',
                layout: 'fit',
                flex: 1,
                listeners: {
//                	boxready: function() {
//                		this.body.down("canvas").dom.width=this.getTargetEl().getWidth();
//                		this.body.down("canvas").dom.height=this.getTargetEl().getHeight();
//                	},
            		filterchange: function(store) {
            			var el = this.getTargetEl(), width = el.getWidth(), height = el.getHeight();
            			el.setHtml(" "); // empty
            			terms = store.getRange().map(function(r) {return {
            				term: r.getTerm(),
            				vals: r.getDistributions()
            			}})
            			var svg = d3.select(el.dom).append("svg")
            		      .attr("width", el.getWidth())
            		      .attr("height", el.getHeight());
            			
            			if (terms.length==0) {
            				return this.up("panel").toastInfo("No hits")
            			}
            			
            			var xincrement = width/terms[0].vals.length;
            			
            			var scale, scaleApi = this.up('loom').getApiParam("scaling");
            			if (scaleApi=="sqrt") {scale = d3.scaleSqrt()}
            			else if (scaleApi=="log") {scale = d3.scaleLog();}
            			else {scale = d3.scaleLinear();}
            			
            			var yscale = scale
            				.domain([
            					Math.max(1e-6, Ext.Array.min(terms.map(function(t) {return Ext.Array.min(t.vals)}))),
            					Math.max(1e-6, Ext.Array.max(terms.map(function(t) {return Ext.Array.max(t.vals)})))
            					]).range([1e-6, height-2]);
            			
//            			console.warn(
//            					Math.max(1e-6, Ext.Array.min(terms.map(function(t) {return Ext.Array.min(t.vals)}))),
//            					Math.max(1e-6, Ext.Array.max(terms.map(function(t) {return Ext.Array.max(t.vals)})))
//            					);
            			
            			var valueline = d3.line()
            				.curve(d3.curveCardinal)
	            		    .x(function(d, i) { return (xincrement/2)+(xincrement*i)})
	            		    .y(function(d) { return height-1-yscale(d)});
            			
        			    var tooltip = svg.append("g")
        			    	.attr("opacity", 0);
        			    
        			    var tooltipbox = tooltip.append("rect")
        			    	.attr("fill", "white")
        			    	.attr("text-anchor", "middle")
        			    	.attr("alignment-baseline", "middle")
        			    	.attr("stroke", "rgba(0,0,0,.05)")
        			    	.attr("class", "rect")
        			    	.attr("x", 100)
        			    	.attr("y", 100)
        			    	.attr("width", 70)
        			    	.attr("height", 16)
        			    	.attr("opacity", 1)
        			    	
        			    var tooltiptext = tooltip
        			    	.append("text")
        			    	.attr("text-anchor", "middle")
        			    	.attr("alignment-baseline", "middle")
        			    	.attr("x", 100)
        			    	.attr("y", 100)
//        			    	.attr("width", 100)
//        			    	.attr("height", 12)
        			    	.text("testing")

            			terms.forEach(function(term) {
            				var color = Voyant.application.getColorForTerm(term.term, true)
            				
            				// draw a first line, always visible
            				svg.append("path")
            			      .datum(term.vals)
						      .attr("fill", "none")
						      .attr("stroke", color)
						      .attr("opacity", .5)
						      .attr("stroke-linejoin", "round")
						      .attr("stroke-linecap", "round")
						      .attr("stroke-width", 1)
						      .attr("class", "line")
            			      .attr("d", valueline)

            				
            			    // draw a second line to make it easier to hover (line width 1 is harder to find)
            				svg.append("path")
            			      .datum(term.vals)
						      .attr("fill", "none")
						      .attr("stroke", color)
						      .attr("opacity", 0)
						      .attr("stroke-width", 3)
						      .attr("class", "line")
            			      .attr("term", term.term)
            			      .attr("d", valueline)
						      .on('mouseover', function() { // on mouse out hide line, circles and text
						    	  d3.select(this)
						    	  	.attr("opacity", 1);
						    	  
						    	  var coords = d3.mouse(this);
						    	  
						    	  tooltip
						    	  	.attr("opacity", 1)
						    	  	
						    	  tooltipbox
						    	  	.attr("x", coords[0]-35)
						    	  	.attr("y", coords[1] -8+ (coords[1]>height/2 ? -18 : 18))
							    	 
						    	  tooltiptext
							    	  	.text(term.term)
							    	  	.attr("fill", color)
							    	  	.attr("x", coords[0])
							    	  	.attr("y", coords[1] + (coords[1]>height/2 ? -18 : 18))

						      })
						      .on('mouseout', function() { // on mouse out hide line, circles and text
						    	  d3.select(this)
						    	  	.attr("opacity", 0);
						    	  tooltip.attr("opacity", 0)
						      })
						      
						      tooltip.raise(); // make sure this is at top level for legibility

            			}, this)
            		}

                }
            }],
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [tbitems[0], tbitems[2], tbitems[3], tbitems[4], tbitems[5]/*, {
                	text: this.localize("controls"),
                	tooltip: this.localize("controlsTip"),
                	menu: {
                    	items: tbitems
                	}
                }*/,{
        			fieldLabel: this.localize('visibleTerms'),
        			labelWidth: 70,
        			width: 120,
        			xtype: 'slider',
	            	increment: 25,
	            	minValue: 25,
	            	maxValue: 5000,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("limit")));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			// maybe not necessary when value is smaller
	            			this.fireEvent("loadedCorpus", this, this.getCorpus())
	            		},
	            		scope: this
	            	}
                },{
                	text: this.localize("scaling"),
                	menu: {
                		defaults: {
                			xtype: 'menucheckitem',
                			handler: function(cmp) {
                				this.setApiParam("scaling", cmp.getItemId());
                        		this.getComponent("threads").fireEventArgs("filterchange", [this.getStore()]);
                			},
                			scope: this,
                			listeners: {
                				afterrender: function(cmp) {
                					cmp.setChecked(cmp.getItemId()==this.getApiParam("scaling"))
                				},
                				scope: this
                			},
                			group: 'scaling'
                		},
                		items: [{
                			text: this.localize("scaleLinear"),
                			itemId: 'linear'
                		},{
                			text: this.localize("scaleLog"),
                			itemId: 'log'
                		},{
                			text: this.localize("scaleSqrt"),
                			itemId: 'sqrt'
                		}]
                
                	}
                }]
              }]
        });
        
        this.on('loadedCorpus', function(src, corpus) {
        	var store = corpus.getDocumentsCount()==1 ? corpus.getDocumentTerms() : corpus.getCorpusTerms();
        	store.on("load", function() {
        	    this.updateControlsFromStore();
		    	this.filterRecords();
        	}, this);
        	store.on("filterchange", function() {
        		this.getComponent("terms").fireEventArgs("filterchange", arguments);
        		this.getComponent("threads").fireEventArgs("filterchange", arguments);
        		
        	}, this);
        	this.setStore(store);
        	params = this.getApiParams();
        	Ext.apply(params, {
        		withDistributions: true
        	});
        	store.load({
    		    callback: function(records, operation, success) {
    		    	this.filterRecords();
    		    },
    		    scope: this,
    		    params: params
        	});

        }, this);
        
        this.callParent(arguments);
    },

    filterRecords: function() {
    	var store = this.getStore();
    	store.clearFilter();
    	var limit = parseInt(this.getApiParam("limit")), hit = 0;
    	store.filterBy(function(record) {
    		var keep = Ext.Array.every(this.getControls().getRange(), function(control) {
    			return control.getEnabled()==false || control.getValidateRecord().call(control, record);
    		}, this);
    		return keep && hit++<limit;
    	}, this)
    },
    
    updateControlsFromStore: function() {
    	var store = this.getStore();
    	this.getControls().each(function(control) {
    		control.suspendEvent("change");
    		control.initControl.call(this, store);
    		if (control.getMin()===undefined) {control.setMin(0);}
    		if (control.getLow()==undefined) {control.setLow(control.getMin())}
    		if (control.getMax()===undefined) {control.setMax(1);} // shouldn't happen
    		if (control.getHigh()==undefined) {control.setHigh(control.getMax())}
    		control.resumeEvent("change");
    	})
    },
    
    revalidate: function() {
    	var canvas = this.body.down('canvas').dom, ctx = canvas.getContext("2d");
    	ctx.clearRect(0,0,canvas.width,canvas.height);

    	var controls = this.query('loomcontrol');
    	
    	var loomTermRecords = new Voyant.panel.LoomTermRecords();
    	this.getStore().each(function(record) {
    		var vals = record.getDistributions().map(function(v) {return true;})
    		Ext.Array.each(controls, function(control) {
    			if (control.getChecked()) {
    				if (control.validateRecord) {
    					var newvals = control.validateRecord.call(this, control.getField(), record, record.getDistributions());
//    					console.warn(control.getName(), newvals)
    					if (Ext.isBoolean(newvals) && !newvals) {
    						vals = false;
    						return false;
    					} else if (Ext.isArray(newvals)) {
        					for (var i=0; i<vals.length; i++) {
        						vals[i] = vals[i] && newvals[i];
        					}
        					return Ext.Array.some(vals, function(v) {return v})
    					}
    				}
    			}
    		});
    		if (Ext.isArray(vals) && Ext.Array.some(vals, function(v) {return v})) {
    			loomTermRecords.add(record);
    		}
    	})
    	
    	loomTermRecords.update(canvas, ctx);
    }
    
});

Ext.define('Voyant.panel.LoomTermRecords', {
	config: {
		termRecords: []
	},
	constructor: function(config) {
		this.setTermRecords([])
	    this.callParent(arguments);
	},
	add: function(record) {
		this.getTermRecords().push(new Voyant.panel.LoomTermRecord(record));
	},
	update: function(canvas, ctx) {
		var min = Ext.Array.min(this.getTermRecords().map(function(r) {return Ext.Array.min(r.getValues())}))
		var max = Ext.Array.max(this.getTermRecords().map(function(r) {return Ext.Array.max(r.getValues())}))
		this.getTermRecords().forEach(function(r) {
			r.update(canvas, ctx, min, max)
		})
	}
})

Ext.define('Voyant.panel.LoomTermRecord', {
	config: {
		record: undefined,
		values: undefined,
		term: undefined,
		texts: undefined
	},
	constructor: function(config) {
		this.setRecord(config);
		this.setValues(config.getDistributions());
		var term = config.getTerm();
		this.setTerm(term);
		this.setTexts(config.getDistributions().map(function(v) {
			return new Ext.draw.sprite.Text({
				type: 'text',
				text: term
			})
		}))
	    this.callParent(arguments);
	},
	update: function(canvas, ctx, min, max) {
		var values = this.getValues(), columnWidth = canvas.offsetWidth/(values.length),
			height = canvas.offsetHeight, term = this.getTerm();
		this.getTexts().forEach(function(text, i) {
			var y = values[i]*height/max;
		    ctx.fillText(term, (columnWidth/2)+(i*columnWidth), height-y);
		})
	}
})

Ext.define('Voyant.util.LoomControl', {
    extend: 'Ext.Base',
    mixins: ['Ext.mixin.Observable'],
    constructor: function(config) {
    	this.mixins.observable.constructor.call(this, config);
        this.callParent(arguments);
    },
    config: {
    	group: undefined,
    	name: undefined,
    	enabled: false,
    	min: undefined,
    	max: undefined,
    	low: undefined,
    	high: undefined,
    	initControls: Ext.emptyFn,
    	validateRecord: Ext.emptyFn,
		offsetTipText: false
    },
    setMin: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setMax: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setLow: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setHigh: function() {
    	this.callParent(arguments);
    	this.fireEvent("change", this);
    	return this;
    },
    setValues: function(low, high) {
    	this.suspendEvent("change");
    	if (Ext.isArray(low)) {
        	this.setLow(low[0]);
        	this.setHigh(low[1]);
    	} else {
        	this.setLow(low);
        	this.setHigh(high);
    	}
    	this.resumeEvent("change");
    	if (arguments.length < 3 || !arguments[2]) {this.fireEvent("change", this);}
    	return this;
    },
    setEnabled: function() {
    	this.callParent(arguments);
    	if (arguments.length < 2 || !arguments[1]) {this.fireEvent("change", this);}
    	return this;
    }
    
})
Ext.define('Voyant.panel.MicroSearch', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.microsearch',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		query: undefined
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	/**
    	 * @private
    	 */
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	
    	/**
    	 * @private
    	 */
    	maxTokens: 0,
    	
    	/**
    	 * @private
    	 */
    	tokensPerSegment: 0,
    	
    	/**
    	 * @private
    	 */
    	maxVerticalLines: 0,
    	
    	/**
    	 * @private
    	 */
    	maxSegments: 0
    },
    constructor: function(config ) {

    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                }]
    		}]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.rendered) {
    			this.initialize();
    		}
    		else {
    			this.on("afterrender", function() {
    				this.initialize();
    			}, this)
    		}

    	});
    	
    	this.on('query', function(src, query) {
    		this.setApiParam('query', query);
    		this.updateSearchResults();
    	})
    	
    },
    
    initialize: function() {

    	var el = this.getTargetEl(), corpus = this.getCorpus();
    	
		var lineSize = 5; // pixels, including margins below and above
		this.setMaxVerticalLines(Math.floor((el.getHeight() - 10 /* margin of 5px */) / lineSize));
		
		// max segments
		var gutterSize = 10;
		var corpusSize = corpus.getDocumentsCount();
		var gutter = corpusSize * gutterSize;
		var columnSize = Math.floor((el.getWidth() - gutter - 10 /* margin of 5px */) / corpusSize);
		if (columnSize>200) {columnSize=200;}
		var segmentWidth = 3; // each segment is 3 pixels
		var maxSegmentsPerLine = Math.floor(columnSize / segmentWidth);
		if (maxSegmentsPerLine<1) {maxSegmentsPerLine=1;}
		
		// and the answer is...
		this.setMaxSegments(maxSegmentsPerLine * this.getMaxVerticalLines());
		
		var documentsStore = corpus.getDocuments();
		this.setMaxTokens(documentsStore.max('tokensCount-lexical'));

		this.setTokensPerSegment(this.getMaxTokens() < this.getMaxSegments() ? 1 : Math.ceil(this.getMaxTokens()/this.getMaxSegments()));
		

		var canvas = "<table cellpadding='0' cellspacing='0' style='height: 100%'><tr>";
		this.segments = [];
		documentsStore.each(function(document) {
			docIndex = document.getIndex();
			canvas+='<td style="overflow: hidden; vertical-align: top; width: '+columnSize+'px;">'+
				'<div class="docLabel" style="white-space: nowrap; width: '+columnSize+'px;" data-qtip="'+document.getFullLabel()+'">'+document.getFullLabel()+"</div>"+
				'<canvas style="display: block;" width="'+columnSize+'" height="'+el.getHeight()+'" id="'+this.body.id+'-'+docIndex+'">'+
				'</td>';
			if (docIndex+1<corpusSize) {canvas+='<td style="width: '+gutterSize+'px;">&nbsp;</td>';}
		}, this);
		canvas+='</tr></table>';
		el.update(canvas);
		
		this.updateSearchResults();
		
    	if (!this.getApiParam('query')) {
    		var me = this;
    		return this.getCorpus().loadCorpusTerms({limit: 1, stopList: this.getApiParam('stopList'), categories: this.getApiParam("categories")}).then(function(corpusTerms) {
    			var term = corpusTerms.getAt(0).getTerm();
    			var q = me.down('querysearchfield');
    			q.addValue(new Voyant.data.model.CorpusTerm({term: term}));
    			me.fireEvent("query", me, [term])
    		});
    	}

    },
    
    updateSearchResults: function() {
    	query = this.getApiParam('query');
    	
		// draw background
		this.getCorpus().getDocuments().each(function(document) {
			var distributions = this.redistributeDistributions(document, new Array(this.getMaxSegments()));
			this.drawDocumentDistributions(document, null, distributions);
		}, this);

    	if (Ext.Array.from(query).length > 0) {
    		this.mask(this.localize('loading'))
    		this.getCorpus().getDocumentTerms().load({
    			params: {
    				query: Ext.Array.from(query),
        			withDistributions: 'relative',
        			bins: this.getMaxSegments(),
        			categories: this.getApiParam('categories')
    			},
    			callback: function(records, operation, success) {
    				this.unmask();
    				var max = 0;
					var min = Number.MAX_VALUE;
					var docs = [];
    				records.forEach(function(record) {
    					var doc = this.getCorpus().getDocument(record.getDocIndex());
    					var distributions = this.redistributeDistributions(doc, record.getDistributions());
    					var m = Ext.Array.max(distributions);
    					if (m>max) {max=m;}
    					distributions.forEach(function(d) {
    						if (d && d<min) {
    							min = d;
    						}
    					})
						if (docs[record.getDocIndex()] === undefined) {
							docs[record.getDocIndex()] = {};
						}
						docs[record.getDocIndex()][record.getTerm()] = this.redistributeDistributions(doc, record.getDistributions());
    				}, this);
    				docs.forEach(function(termDistributions, i) {
						for (var term in termDistributions) {
							var distributions = termDistributions[term];
                    		this.drawDocumentDistributions(this.getCorpus().getDocument(i), term, distributions, min || Ext.Array.min(distributions), max || Ext.Array.max(distributions));
						}
    				}, this)
    			},
    			scope: this
    		})
    	}
    },
    
    redistributeDistributions: function(doc, distributions) {
		var segments = Math.ceil(doc.getLexicalTokensCount() / this.getTokensPerSegment());

		// redistribute if needed, we'll take the mean of the distribution values to maintain comparison across segments
    	if (distributions.length>segments) {
    		var newdistributions = [];
    		for (var i=0; i<distributions.length; i++) {
    			var a = parseInt(i*segments/distributions.length);
    			if (newdistributions[a]) {newdistributions[a].push(distributions[i])}
    			else {newdistributions[a]=[distributions[i]];}
    		}
			distributions = newdistributions
    		for (var i=0; i<distributions.length; i++) {
    			distributions[i] = Ext.Array.mean(distributions[i]);
    		}
    	}
    	return distributions;
    },
    
    drawDocumentDistributions: function(doc, term, distributions, min, max) {
    	var canvas = this.getTargetEl().dom.querySelector("#"+this.body.id+"-"+doc.getIndex());
    	var c = canvas.getContext('2d');
    	var x = 0, w = canvas.clientWidth, y = 0;
		
		var isBlank = term === null;
		var color = [230, 230, 230];
		if (!isBlank) {
			color = this.getApplication().getColorForTerm(term);
		}

    	for (var j=0; j<distributions.length;j++) {
			if (isBlank) {
				c.fillStyle = "rgb(230,230,230)";
				c.fillRect(x,y,3,3);
			} else if (distributions[j]) {
				var alpha = ((distributions[j]-min)*.7/(max-min))+.3;
				c.fillStyle = "rgba("+color[0]+","+color[1]+","+color[2]+","+alpha+")";
				c.fillRect(x,y,3,3);
			}
    		x+=3;
    		if (x>=w) {x=0; y+=5}
    	}
    	
    }
});
Ext.define('Voyant.panel.Mandala', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.mandala',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		query: undefined,
    		
    		labels: true
    		
    	},
    	glyph: 'xf1db@FontAwesome'
	},
	
	gutter: 5,
	
	textFont: '12px sans-serif',
	
	config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}]
	},
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	Ext.apply(this, {
    		title: this.localize('title'),
			html: '<div style="text-align: center"><canvas width="800" height="600"></canvas></div>',
			dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	text: this.localize('add'),
        			glyph: 'xf067@FontAwesome',
                	handler: function() {
                		this.editMagnet();
                	},
                	scope: this
                },{
                	text: this.localize('clear'),
					glyph: 'xf014@FontAwesome',
                	handler: function() {
                		this.setApiParam('query', undefined);
                		this.updateFromQueries(true);
                		this.editMagnet();
                	},
                	scope: this
	            },{
	                xtype: 'checkbox',
	                boxLabel: this.localize('labels'),
	                listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(this.getApiParam("labels")===true);
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('labelsTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    change: function(cmp, val) {
	                    	this.setApiParam('labels', val);
	                    	this.draw();
	                    },
	                    scope: this
	                }
	            }]
    		}]			
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('boxready', function(cmp) {
			var canvas = this.getTargetEl().dom.querySelector("canvas");
			var me = this;
    		canvas.addEventListener('mousemove', function(evt) {
    			var rect = canvas.getBoundingClientRect(), x =  evt.clientX - rect.left, y = evt.clientY - rect.top,
				change = false, docRadius = parseInt(me.textFont)/2;
    			if (me.documents) {
    				me.documents.forEach(function(doc) {
    					var isHovering = x > doc.x-docRadius && x < doc.x+docRadius && y > doc.y-docRadius && y < doc.y+docRadius;    					
    					if (isHovering!=doc.isHovering) {change = true;}
    					doc.isHovering = isHovering;
    				})
    			}
				radius = parseInt(me.textFont)/2;
				for (term in me.magnets) {
					var isHovering = x > me.magnets[term].x-radius && x < me.magnets[term].x+radius && y > me.magnets[term].y-radius && y < me.magnets[term].y+radius;    					
					if (isHovering!=me.magnets[term].isHovering) {change = true;}
					me.magnets[term].isHovering = isHovering;
				}
				if (change) {
					me.draw();
				}
    	    }, false);
    		canvas.addEventListener('click', function(evt) {
    			var rect = canvas.getBoundingClientRect(), x =  evt.clientX - rect.left, y = evt.clientY - rect.top,
					docRadius = parseInt(me.textFont)/2;
				for (term in me.magnets) {
					if (x > me.magnets[term].x-radius && x < me.magnets[term].x+radius && y > me.magnets[term].y-radius && y < me.magnets[term].y+radius) {
						me.editMagnet(term);
					}
				}
    	    }, false);
    	})
    	
    	this.on('loadedCorpus', function(src, corpus) {
    		this.documents = [];
    		var canvas = this.getTargetEl().dom.querySelector("canvas"), ctx = canvas.getContext("2d"), radius = canvas.width/2;
    		ctx.font = this.textFont;
    		corpus.getDocuments().each(function(document) {
    			var label = document.getTinyTitle();
    			this.documents.push({
    				doc: document,
    				label: label,
    				width: ctx.measureText(label).width,
    				x: radius,
    				y: radius,
    				matches: [],
    				isHovering: false
    			});
    		}, this);
    		this.updateDocs(canvas);
    		this.draw();
    		this.updateFromQueries();
    	}, this);
    	
    	this.on("resize", function() {
    		var canvas = this.getTargetEl().dom.querySelector("canvas"),
    			diam = Math.min(this.getTargetEl().getWidth(), this.getTargetEl().getHeight());
    		canvas.width = diam;
    		canvas.height = diam;
	    	this.updateMagnets();
	    	this.updateDocs();
    		this.draw(canvas)
    	})
    },
    
    editMagnet: function(term) {
    	var me = this, currentTerms = Ext.Array.from(me.getApiParam('query'));
		Ext.create('Ext.window.Window', {
			title: this.localize("EditMagnet"),
			modal: true,
			items: {
				xtype: 'form',
				width: 300,
				items: [{
					xtype: 'querysearchfield',
					corpus: this.getCorpus(),
					store: this.getCorpus().getCorpusTerms({
						proxy: {
							extraParams: {
								stopList: this.getApiParam('stopList')
							}
						}
					}),
					stopList: this.getApiParam('stopList'),
					listeners: {
						afterrender: function(field) {
							if (term) {
								var termObj = new Ext.create("Voyant.data.model.CorpusTerm", {
									term: term
								});
								field.getStore().loadData(termObj, true)
								field.setValue(termObj);
							}
						}
					}
				},{
					xtype: "numberfield",
				    fieldLabel: me.localize('rotateClockwise'),
				    minValue: 0,
				    maxValue: currentTerms.length-1,
				    value: 0,
				    stepValue: 1,
				    width: 200,
				    name: "rotate"
				}],
				buttons: [{
	            	text: this.localize("remove"),
					glyph: 'xf0e2@FontAwesome',
	            	flex: 1,
		            ui: 'default-toolbar',
	        		handler: function(btn) {
	        			var queries = Ext.Array.filter(Ext.Array.from(me.getApiParam('query')), function(query) {
	        				return query!=term
	        			});
	        			me.setApiParam('query', queries);
	        			me.updateFromQueries(queries.length==0);
	        			btn.up('window').close();
	        		},
	        		scope: this
				},{xtype: 'tbfill'}, {
	            	text: this.localize("cancel"),
		            ui: 'default-toolbar',
	                glyph: 'xf00d@FontAwesome',
	        		flex: 1,
	        		handler: function(btn) {
	        			btn.up('window').close();
	        		}
				},{
	            	text: this.localize("update"),
					glyph: 'xf00c@FontAwesome',
	            	flex: 1,
	        		handler: function(btn) {
	        			var val = btn.up('window').down('querysearchfield').getValue().join("|")
	        			if (val) {

	        				// start by updating the term in place
		        			var position = -1;
		        			for (var i=0; i<currentTerms.length; i++) {
		        				if (term==currentTerms[i]) {
		        					position=i;
		        					currentTerms[i]=val;
		        					
				        			// see if we need to shift
				        			var rotate = btn.up('window').down('numberfield').getValue();
				        			if (rotate) {
				        				currentTerms.splice(i, 1);
				        				var newpos = i+rotate;
				        				if (newpos>currentTerms.length) {newpos-=currentTerms.length+1;}
				        				currentTerms.splice(newpos, 0, val);
				        			}
				        			break
				        			
		        				}
		        			}
		        			if (position==-1) { // not sure why it couldn't be found
		        				currentTerms.push(val);
		        			}		        			
	        			}
	        			
	        			me.setApiParam('query', currentTerms);
	        			me.updateFromQueries(currentTerms.length==0);
	        			btn.up('window').close();
	        		},
	        		scope: this
	            }]
			},
			bodyPadding: 5
		}).show()
    },
    
    updateFromQueries: function(allowEmpty) {
		this.magnets = undefined;
		this.documents.forEach(function(doc) {doc.matches=[]})
		this.updateDocs();
		this.draw();
    	if (this.documents) {
    		var params = this.getApiParams();
    		if (!params.query) {params.limit=10;}
        	var queries = Ext.Array.from(this.getApiParam('query'));
        	if (!allowEmpty || queries.length>0) {
        		this.getCorpus().getCorpusTerms().load({
        			params: Ext.apply(params, {withDistributions: true}),
        			callback: function(records) {
        		    	var canvas = this.getTargetEl().dom.querySelector("canvas"), ctx = canvas.getContext("2d");
        		    		diam = canvas.width, rad = diam /2;
        		    	ctx.font = this.textFont;
        		    	var magnets = {};
        		    	for (var i=0, len=records.length; i<len; i++) {
        		    		var term = records[i].getTerm();
        		    		records[i].getDistributions().forEach(function(val, i) {
        		    			if (val>0) {
        		    				this.documents[i].matches.push(term)
        		    			}
        		    		}, this);
        		    		magnets[term] = {
        		    			record: records[i],
        		    			colour: this.getApplication().getColor(i),
        		    			width: ctx.measureText(term).width,
        		    			isHovering: false
        		    		}
        		    	}

        		    	this.magnets = {};
        		    	
        		    	// try ordering by queries
        		    	queries.forEach(function(query) {
        		    		if (magnets[query]) {
            		    		this.magnets[query] = magnets[query]
            		    		delete magnets[query]
        		    		}
        		    	}, this);
        		    	
        		    	// now for any leftovers
        		    	for (term in magnets) {
        		    		this.magnets[term] = magnets[term]
        		    	}
        		    	
        		    	this.setApiParam('query', Object.keys(this.magnets))
        		    	this.updateMagnets();
        		    	this.updateDocs();
        		    	this.draw();
        			},
        			scope: this
        		})
        	}
    	}
    },
    
    updateMagnets: function(canvas) {
    	var canvas = this.getTargetEl().dom.querySelector("canvas"), diam = canvas.width, rad = diam /2;
    	var len = Object.keys(this.magnets || {}).length;
    	var i = 0;
    	for (var term in this.magnets) {
    		Ext.apply(this.magnets[term], {
				x:  rad+((rad-this.gutter-50) * Math.cos(2 * Math.PI * i / len)),
				y:  rad+((rad-this.gutter-50) * Math.sin(2 * Math.PI * i / len))
    		})
    		i++;
    	}
    },
    
    updateDocs: function(canvas) {
    	canvas = canvas ||  this.getTargetEl().dom.querySelector("canvas"), diam = canvas.width, rad = diam /2;
    	var notMatching = [];
    	if (this.documents) {
        	this.documents.forEach(function(doc, i) {
        		if (Ext.Array.from(doc.matches).length==0) {notMatching.push(i);} // will be set around perimeter below
        		else if (Ext.Array.from(doc.matches).length==1) { // try to set it away from magnet
        			var x = (Math.random()*15)+15, y = (Math.random()*15)+15;
        			doc.targetX = this.magnets[doc.matches[0]].x + (Math.round(Math.random())==0 ? x : -x);
        			doc.targetY = this.magnets[doc.matches[0]].y + (Math.round(Math.random())==0 ? y : -y);
        		} else {
        			// determine the weighted position
        			var x = 0, y = 0,
        				vals = doc.matches.map(function(term) {return this.magnets[term].record.getDistributions()[i]}, this),
        				min = Ext.Array.min(vals), max = Ext.Array.max(vals);
        			var weights = 0;
        			doc.matches.forEach(function(term, j) {
        				weight = max==min ? 1 : ((vals[j]-min)+min)/((max-min)+min);
        				weights += weight;
        				x += this.magnets[term].x*weight;
        				y += this.magnets[term].y*weight;
        				
        			}, this)
        			doc.targetX = x/weights
        			doc.targetY = y/weights
        		}
        	}, this);
        	
        	// set around perimeter
        	for (var i=0, len=notMatching.length; i<len; i++) {
        		Ext.apply(this.documents[i], {
    				targetX:  rad+((rad-this.gutter) * Math.cos(2 * Math.PI * i / len)),
    				targetY:  rad+((rad-this.gutter) * Math.sin(2 * Math.PI * i / len))
        		})
        	}
    	}
    },
    
    draw: function(canvas, ctx) {
    	canvas = canvas ||  this.getTargetEl().dom.querySelector("canvas");
    	ctx = ctx || canvas.getContext("2d");
    	ctx.font = this.textFont;
    	var radius = canvas.width/2;
    	ctx.clearRect(0,0,canvas.width,canvas.height);
    	var labels = this.getApiParam('labels');
    	
    	// draw circle
    	ctx.beginPath();
    	ctx.strokeStyle = "rgba(0,0,0,.1)"
        ctx.fillStyle = "rgba(0,0,0,.02)"
    	ctx.arc(radius, radius, radius-this.gutter, 0, 2 * Math.PI, false);
    	ctx.fill();
    	ctx.lineWidth = 2;
    	ctx.stroke();
    	
    	// determine if we're animating a move and need to come back
    	var needRedraw = false;
    	
    	// draw documents
    	
    	if (this.documents && this.documents.length>0) {
    		var needMove = false;
    		
    		var noHovering = Ext.Array.each(this.documents, function(doc) {
    			return !doc.isHovering
    		}, this);
    		
    		if (noHovering===true) {
    			noHovering = Ext.Array.each(Object.keys(this.magnets || {}), function(term) {
        			return !this.magnets[term].isHovering
        		}, this);
    		}
			// go through a first time to draw connecting lines underneath
    		var hoveringTerms = {}; hoveringDocs = [];
    		this.documents.forEach(function(document, j) {
	        	document.matches.forEach(function(term, i) {
	        		ctx.beginPath();
	        		ctx.moveTo(document.x, document.y);
	        		ctx.lineTo(this.magnets[term].x, this.magnets[term].y);
	        		if (noHovering===true) {
		        		ctx.strokeStyle = "rgba("+this.magnets[term].colour.join(",")+",.1)";
	        		} else {
	        			if (document.isHovering || this.magnets[term].isHovering) {
	        				hoveringDocs[j]=true;
	        				hoveringTerms[term]=true;
			        		ctx.strokeStyle = "rgba("+this.magnets[term].colour.join(",")+",.5)";
	        			} else {
		        			ctx.strokeStyle = "rgba(0,0,0,.02)";
	        			}
	        		}
	        		ctx.stroke();
	        	}, this);
    		}, this);
    			
			// now a second time for labels/markers
    		var halfSize = parseInt(this.textFont)/2, height = parseInt(this.textFont)+4;
    		this.documents.forEach(function(document, i) {
    			
    			// draw marker/label
    			if (labels || document.isHovering || hoveringDocs[i]==true) {
	    		    var width = document.width+4;
			        ctx.fillStyle = document.isHovering || hoveringDocs[i]==true || noHovering===true ? "white" : "rgba(255,255,255,.05)"
	    		    ctx.fillRect(document.x-(width/2), document.y-(height/2), width, height);
			        ctx.strokeStyle = document.isHovering || hoveringDocs[i]==true || noHovering===true ? "rgba(0,0,0,.2)" : "rgba(0,0,0,.05)"
	    		    ctx.strokeRect(document.x-(width/2), document.y-(height/2), width, height);
			        ctx.textAlign = "center";
			        ctx.fillStyle = document.isHovering || hoveringDocs[i]==true || noHovering===true ? "rgba(0,0,0,.8)" : "rgba(0,0,0,.05)";
	    		    ctx.fillText(document.label, document.x, document.y);
    			} else {
    		    	ctx.beginPath();
    		        ctx.fillStyle = "rgba(0,0,0,.8)"
    		    	ctx.arc(document.x, document.y, halfSize, 0, 2 * Math.PI);
    	        	ctx.fill();
    		    	ctx.stroke();
    			}
	        	
	        	// determine if we need to move
		    	var dx = Math.abs(document.x - document.targetX), dy = Math.abs(document.y- document.targetY)
		    	if (dx!=0 || dy!=0) {
		    		if (dx<1) {document.x = document.targetX}
		    		else {
		    			dx/=2;
		    			document.x = document.x > document.targetX ? document.x-dx : document.x+dx;
		    		}
		    		if (dy<1) {document.y = document.targetY}
		    		else {
		    			dy/=2;
		    			document.y = document.y > document.targetY ? document.y-dy : document.y+dy;
		    		}
		    		needRedraw = true;
		    	}
    		}, this);
    		
    		// now magnets
    		var i = 0, height = parseInt(this.textFont)+4;
	        ctx.textAlign = "center";
	        ctx.textBaseline="middle";
	        for (var term in this.magnets) {
	        	if (labels || term in hoveringTerms || this.magnets[term].isHovering) {
	    		    var width = this.magnets[term].width+4;
			        ctx.fillStyle = term in hoveringTerms || this.magnets[term].isHovering || noHovering===true ? "white" : "rgba(255,255,255,.05)";
	    		    ctx.fillRect(this.magnets[term].x-(width/2), this.magnets[term].y-(height/2), width, height);
			        ctx.strokeStyle = term in hoveringTerms || this.magnets[term].isHovering || noHovering===true ? "rgb("+this.magnets[term].colour.join(",")+")" : "rgba(0,0,0,.05)";
	    		    ctx.strokeRect(this.magnets[term].x-(width/2), this.magnets[term].y-(height/2), width, height);
			        ctx.textAlign = "center";
			        ctx.fillStyle = term in hoveringTerms || this.magnets[term].isHovering || noHovering===true ?"rgba(0,0,0,.8)" : "rgba(0,0,0,.05)";
	    		    ctx.fillText(term, this.magnets[term].x, this.magnets[term].y);
	        	} else {
			    	ctx.beginPath();
			        ctx.fillStyle = "rgb("+this.magnets[term].colour.join(",")+")"
			        ctx.strokeStyle = "rgb("+this.magnets[term].colour.join(",")+")"
			    	ctx.arc(this.magnets[term].x, this.magnets[term].y, 12, 0, 2 * Math.PI);
		        	ctx.fill();
			    	ctx.stroke();
	        	}
    		}
    	}
    	
		if (needRedraw) {
			var me = this;
			setTimeout(function() {
				me.draw();
			}, 100);
		} else if (this.documents) {
			var minDist = Math.max(radius/this.documents.length, 50), spring = .1
			for (var i=0, len=this.documents.length; i<len; i++) {
				for (var j=0; j<len; j++) {
					if (i<j) {
						
						var dx = this.documents[i].x  - this.documents[j].x,
							dy = this.documents[i].y - this.documents[j].y,
							dist = Math.sqrt(dx * dx + dy * dy);
						if (dist < minDist) {
							var ax = dx * spring, ay = dy * spring;
							this.documents[i].targetX += ax;
							this.documents[j].targetX -= ax;
							this.documents[i].targetY += ay;
							this.documents[j].targetY -= ay;
							needRedraw = true;
						}
					}
				}
			}
			if (needRedraw) {
				var me = this;
				setTimeout(function() {
					me.draw();
				}, 100);
			}
		}
    }
    
});
Ext.define('Voyant.panel.MicroOcp', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.microocp',
    statics: {
    	i18n: {
    		title: "MicroOCP"
    	},
    	api: {
    		config: undefined,
    		stopList: 'auto',
    		uri: undefined
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	editor: undefined
    },
    
    constructor: function(config) {
    	config = config || {};
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
		
		
	    var store = Ext.create('Ext.data.Store', {
	        fields: [{
	            name: 'cocoa',
	            type: 'string'
	        }]});
	    
	    var microocp = this;
    	Ext.apply(this, {
    		title: this.localize('title'),
    		layout: 'border',
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                groupId: 'tbar',
                items: [{
                	text: "Create New Voyant Corpus",
                	handler: function() {
                		var items = this.down('grid').getSelectionModel().getSelection().map(function(item) {return item.get("cocoa")});
              // items = ["one","one two","two"]
                		if (items.length==0) {
                			return this.showError({title: "Error", msg: "No items are selected in the grid (on the right)."})
                		}
                		// convert to map for faster lookup
                		itemsMap = {};
                		items.forEach(function(item) {itemsMap[item]=true})
                		
                		
						var str = this.getEditor().getValue();
               // str = "<one>this<one two>is<two>a</one>sentence<two> <one>another"
						var tags = /<(\/)?(\w+)(\s(\w+))?>/g;
						var matches;
						var tagsMap = {}
						while ((matches = tags.exec(str)) != null) {
							var isClose = matches[1]=="/", tag = matches[2], attr = matches[4],
								item = (matches[4] ? matches[2]+" "+matches[4] : matches[2]);
							if (isClose || item in itemsMap) {
								if (tag in tagsMap) {
									tagsMap[tag][tagsMap[tag].length-1].end = matches.index
								}
								if (!isClose) {
									if (!(tag in tagsMap)) {tagsMap[tag] = []}
									tagsMap[tag].push({
										start: matches.index+matches[0].length,
										tag: tag,
										attr: attr
									})
								}
							}
							else if (item in itemsMap) {
								if (tag in tagsMap) {
									tagsMap[tag][tagsMap[tag].length-1].end = matches.index
								}
							}
						}
						
                		// this should be more robust
                		isGroupItems = this.getDockedComponent(1).down('checkbox').checked;

                		var documents = [];
                		if (isGroupItems) {
                			var docs = {};
    						for (var tag in tagsMap) {
    							tagsMap[tag].forEach(function(entry,i) {
    								var text = str.substring(entry.start, entry.end).replace(/<\/?\w+(\s+\w)*>/g, "").trim();
    								if (text) {
    									var item = entry.tag+(entry.attr ? " "+entry.attr : "");
    									if (item in docs) {
    										docs[item]+= text;
    									} else {
    										docs[item] = text;
    									}
    								}
    							})
    						}
    						for (var item in docs) {
    							documents.push({
    								title: item,
    								text: docs[item]
    							})
    						}
                		} else {
    						for (var tag in tagsMap) {
    							tagsMap[tag].forEach(function(entry,i) {
    								var text = str.substring(entry.start, entry.end).replace(/<\/?\w+(\s+\w)*>/g, "").trim();
    								if (text) {
    									documents.push({
    										title: entry.tag+(entry.attr ? " "+entry.attr : "")+" "+(i+1),
    										text: text
    									})
    								}
    							})
    						}
                		}

                		if (documents.length==0) {
                			return this.showError({title: "Error", msg: "No documents found."})
						}
						
						this.mask();
						var progress = Ext.Msg.progress("Creating", "Creating new corpus.");
						// create new corpus
						var me = this;
						new Corpus({
							inputFormat: 'json',
							input: Ext.JSON.encode({documents: documents}),
							jsonDocumentsPointer: "/documents",
							jsonTitlePointer: "/title",
							jsonContentPointer: "/text"
						}).then(function (corpus) {
							progress.close();
							me.unmask();
							var app = me.getApplication();
							me.openUrl(app.getBaseUrl()+"?corpus="+corpus.getAliasOrId())
						});

                		
                	},
                	scope: this
                },{
                	xtype: 'checkbox',
                	boxLabel: "Combine documents with the same tag attribute.",
                	checked: true
                }]
            }],
    		items: [{
		        	xtype: 'panel',
    		    	autoScroll: true,
		        	flex: 1,
		        	height: '100%',
		        	align: 'stretch',
		        	header: false,
		        	region: 'center',
		        	listeners: {
		        		boxready: function() {
		        			var me = this;
							/* TODO swap out ace for codemirror
		        			var editor = ace.edit(Ext.getDom(this.getEl()));
		        			microocp.setEditor(editor); // set to the containing panel
//		        			editor.setOptions({enableBasicAutocompletion: false, enableLiveAutocompletion: false});
//		        			editor.setTheme("ace/theme/monokai");
		        			editor.getSession().setMode("ace/mode/xml")
//		        			editor.$blockScrolling = Infinity;
//		        			editor.getSession().setUseWorker(true);
//		        			editor.setTheme(this.getTheme());
//		        			editor.getSession().setMode(this.getMode());
//		        			editor.setOptions({minLines: 6, maxLines: this.getMode().indexOf("javascript")>-1 ? Infinity : 10, autoScrollEditorIntoView: true, scrollPastEnd: true});
//		        			editor.setHighlightActiveLine(false);
		        			editor.renderer.setShowPrintMargin(false);
		        			editor.renderer.setShowGutter(false);
//		        			editor.setValue(this.getContent() ? this.getContent() : this.localize('emptyText'));
//		        			editor.clearSelection();
//		        		    editor.on("focus", function() {
//		        		    	me.getEditor().renderer.setShowGutter(true);
//		        		    }, this);
		        			editor.$blockScrolling = Infinity
		        			editor.setOptions({autoScrollEditorIntoView: true});
		        			editor.setBehavioursEnabled(false); // disable auto-complete
		        			editor.on("change", function(delta) {
		        				reparse = false;
		        				if (delta.action=="insert") {
		        					if (delta.lines[0].indexOf(">")==0) { // close tag
		        						reparse = true
		        					}
		        				} else if (delta.action=="remove") {
		        					for (var i=0; i<delta.lines.length; i++) {
		        						if (delta.lines[i].indexOf(">")>-1) {
		        							reparse = true;
		        							break;
		        						}
		        					}
		        				}
		        				if (reparse) {
		        					Ext.defer(function() {
		        						var str = editor.getValue();
		        						var tags = /<(\w+)(\s(\w+))?>/g;
		        						var matches;
		        						var expressions = {}
		        						while ((matches = tags.exec(str)) != null) {
		        							if (matches[3]) {expressions[matches[1]+" "+matches[3]]=true}
		        							else {expressions[matches[1]]=true}
		        						}
		        						
		        						var store = this.up("panel").down("grid").getStore();
		        						var inStoreItems = {};
		        						store.getRange().forEach(function(item) {inStoreItems[item.get("cocoa")]=true;});
		        						
		        						for (item in expressions) {
		        							if (!(item in inStoreItems)) {
		        								store.add({cocoa: item});
		        							}
		        						}
		        						for (inStoreItem in inStoreItems) {
		        							if (!(inStoreItem in expressions)) {
		        								var rec = store.findRecord("cocoa", inStoreItem)
		        								store.remove(rec);
		        							}
		        						}
		        						
		        						
		        					}, 100, me)
		        				}
		        			})
		            		if (microocp.getApiParam("uri")) {
		            			Notebook.loadDataFromUrl(microocp.getApiParam("uri")).then(function(data) {
		            				microocp.getEditor().setValue(data);
		            			})
		            		}
							*/

		        		}

		        	}
		        }, {
		        	xtype: 'grid',
		        	region: 'east',
		        	height: '100%',
		        	align: 'stretch',
//    		    	autoScroll: true,
    		    	scrollable: true,
    		    	header: false,

		        	width: 200,
		    		selModel: Ext.create('Ext.selection.CheckboxModel', {
		    			mode: 'SIMPLE'
		            }),
		            store: store,
		            columns: [ {
		                text: 'COCOA',
		                flex: 1,
		                dataIndex: 'cocoa'
		            }]
		        }]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.getApiParam('uri')) {return;}
    		var me = this;
    		corpus.getPlainText().then(function(text) {
    			text = text.replace(/(\r\n|\r|\n)(\r\n|\r|\n)(\r\n|\r|\n)+/g,"\n\n")
				// TODO swap out ace for codemirror
    			// var editor = me.getEditor();
    			// editor.setValue(text).trim();
    			// editor.scrollToLine(1, true, true, function () {});
    		})
    	}, this);
    	
    	this.on('afterrender', function(panel) {
    		Ext.Msg.alert("MicroOCP", "MicroOCP is an experimental prototype that is intended to give a taste of working with the COCOA markup format (COunt and COncordance on the Atlas). Cocoa tags are like switches, you can place one and that tag remains in effect until the next instance of the tag, which can have an optional attribute (single word). As an enhancement to COCOA, you can also close a tag.<pre>&lt;speaker jack&gt;I'm falling &lt;speaker jill&gt;down the hill.&lt;/speaker&gt;</pre>")
    	});
    	
    	
    }
        
});

Ext.define('Voyant.panel.Reader', {
	extend: 'Ext.panel.Panel',
	requires: ['Voyant.data.store.Tokens'],
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.reader',
	isConsumptive: true,
    statics: {
    	i18n: {
			highlightEntities: 'Highlight Entities',
			entityType: 'entity type',
			nerVoyant: 'Entity Identification with Voyant',
			nerNssi: 'Entity Identification with NSSI',
			nerSpacy: 'Entity Identification with SpaCy'
    	},
    	api: {
    		start: 0,
    		limit: 1000,
    		skipToDocId: undefined,
    		query: undefined
    	},
    	glyph: 'xf0f6@FontAwesome'
	},
    config: {
    	innerContainer: undefined,
    	tokensStore: undefined, // for loading the tokens to display in the reader
    	documentsStore: undefined, // for storing a copy of the corpus document models
    	documentTermsStore: undefined, // for getting document term positions for highlighting
		documentEntitiesStore: undefined, // for storing the results of an entities call
    	exportVisualization: false,
    	lastScrollTop: 0,
		scrollIntoView: false,
		insertWhere: 'beforeEnd',
    	lastLocationUpdate: new Date(),
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}]
    },
    
    SCROLL_UP: -1,
    SCROLL_EQ: 0,
    SCROLL_DOWN: 1,
    
	LOCATION_UPDATE_FREQ: 100,
	
	INITIAL_LIMIT: 1000, // need to keep track since limit can be changed when scrolling,

	MAX_TOKENS_FOR_NER: 100000, // upper limit on document size for ner submission

    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function(config) {
    	var tokensStore = Ext.create("Voyant.data.store.Tokens", {
    		parentTool: this,
    		proxy: {
    			extraParams: {
    				forTool: 'reader'
    			}
    		}
    	})
    	var me = this;
    	tokensStore.on("beforeload", function(store) {
    		return me.hasCorpusAccess(store.getCorpus());
    	})
    	tokensStore.on("load", function(s, records, success) {
    		if (success) {
	    		var contents = "";
	    		var documentFrequency = this.localize("documentFrequency");
	    		var isPlainText = false;
	    		var docIndex = -1;
	    		var isLastNewLine = false;
	    		records.forEach(function(record) {
	    			if (record.getPosition()==0) {
	    				contents+="<h3>"+this.getDocumentsStore().getById(record.getDocId()).getFullLabel()+"</h3>";
	    			}
	    			if (record.getDocIndex()!=docIndex) {
	    				isPlainText = this.getDocumentsStore().getById(record.getDocId()).isPlainText();
	    				docIndex = record.getDocIndex();
	    			}
	    			if (record.isWord()) {
	    				isLastNewLine = false;
	    				contents += "<span class='word' id='"+ record.getId() + "' data-qtip='<div class=\"freq\">"+documentFrequency+" "+record.getDocumentRawFreq()+"</div>'>"+ record.getTerm() + "</span>";
	    			}
	    			else {
	    				var newContents = record.getTermWithLineSpacing(isPlainText);
	    				var isNewLine = newContents.indexOf("<br />")==0;
	    				if (isLastNewLine && (isNewLine || newContents.trim().length==0)) {}
	    				else {
	    					contents += newContents;
	    					isLastNewLine = isNewLine;
	    				}
	    			}
	    		}, this);
	    		this.updateText(contents);
	    		
	    		this.highlightKeywords();

				if (this.getDocumentEntitiesStore() !== undefined) {
					this.highlightEntities();
				}
    		}
    	}, this);
    	this.setTokensStore(tokensStore);
    	
    	this.on("query", function(src, queries) {
    		this.loadQueryTerms(queries);
    	}, this);
    	
    	this.setDocumentTermsStore(Ext.create("Ext.data.Store", {
			model: "Voyant.data.model.DocumentTerm",
    		autoLoad: false,
    		remoteSort: false,
    		proxy: {
				type: 'ajax',
				url: Voyant.application.getTromboneUrl(),
				extraParams: {
					tool: 'corpus.DocumentTerms',
					withPositions: true,
					bins: 25,
					forTool: 'reader'
				},
				reader: {
					type: 'json',
		            rootProperty: 'documentTerms.terms',
		            totalProperty: 'documentTerms.total'
				},
				simpleSortMode: true
   		    },
   		    listeners: {
   		    load: function(store, records, successful, opts) {
   		    		this.highlightKeywords(records);
   		    	},
   		    	scope: this
   		    }
    	}));
    	
    	this.on("afterrender", function() {
    		var centerPanel = this.down('panel[region="center"]');
    		this.setInnerContainer(centerPanel.getLayout().getRenderTarget());
    		
    		// scroll listener
    		centerPanel.body.on("scroll", function(event, target) {
    			var scrollDir = this.getLastScrollTop() < target.scrollTop ? this.SCROLL_DOWN
    								: this.getLastScrollTop() > target.scrollTop ? this.SCROLL_UP
									: this.SCROLL_EQ;
    			
    			// scroll up
    			if (scrollDir == this.SCROLL_UP && target.scrollTop < 1) {
    				this.fetchPrevious(true);
    			// scroll down
    			} else if (scrollDir == this.SCROLL_DOWN && target.scrollHeight - target.scrollTop < target.offsetHeight*1.5) {//target.scrollTop+target.offsetHeight>target.scrollHeight/2) { // more than half-way down
    				this.fetchNext(false);
    			} else {
    				var amount;
    				if (target.scrollTop == 0) {
    					amount = 0;
    				} else if (target.scrollHeight - target.scrollTop == target.clientHeight) {
    					amount = 1;
    				} else {
    					amount = (target.scrollTop + target.clientHeight * 0.5) / target.scrollHeight;
    				}
					
					var now = new Date();
        			if (now - this.getLastLocationUpdate() > this.LOCATION_UPDATE_FREQ || amount == 0 || amount == 1) {
        				this.updateLocationMarker(amount, scrollDir);
        			}
    			}
    			this.setLastScrollTop(target.scrollTop);
    		}, this);
    		
    		// click listener
    		centerPanel.body.on("click", function(event, target) {
    			target = Ext.get(target);
				// if (target.hasCls('entity')) {} TODO
    			if (target.hasCls('word')) {
    				var info = Voyant.data.model.Token.getInfoFromElement(target);
    				var term = target.getHtml();
    				var data = [{
    					term: term,
    					docIndex: info.docIndex
    				}];
    				this.loadQueryTerms([term]);
    				this.getApplication().dispatchEvent('termsClicked', this, data);
    			}
    		}, this);
    		
    		if (this.getCorpus()) {
				if (this.getApiParam('skipToDocId') === undefined) {
					this.setApiParam('skipToDocId', this.getCorpus().getDocument(0).getId());
				}
    			this.load();
	    		var query = this.getApiParam('query');
	    		if (query) {
	    			this.loadQueryTerms(Ext.isString(query) ? [query] : query);
	    		}
    		}
			this.on("loadedCorpus", function() {
				if (this.getApiParam('skipToDocId') === undefined) {
					this.setApiParam('skipToDocId', this.getCorpus().getDocument(0).getId());
				}
    			this.load(true); // make sure to clear in case we're replacing the corpus
	    		var query = this.getApiParam('query');
	    		if (query) {
	    			this.loadQueryTerms(Ext.isString(query) ? [query] : query);
	    		}
			}, this);
    	}, this);
    	
    	Ext.apply(this, {
    		title: this.localize('title'),
    		cls: 'voyant-reader',
    	    layout: 'fit',
    	    items: {
    	    	layout: 'border',
    	    	items: [{
    		    	bodyPadding: 10,
    		    	region: 'center',
    		    	border: false,
    		    	autoScroll: true,
    		    	html: '<div class="readerContainer"></div>'
    		    },{
					xtype: 'readergraph',
    		    	region: 'south',
					weight: 0,
    		    	height: 30,
    		    	split: {
    		    		size: 2
    		    	},
    		    	splitterResize: true,
					border: false,
					listeners: {
						documentRelativePositionSelected: function(src, data) {
							var doc = this.getDocumentsStore().getAt(data.docIndex);
							var totalTokens = doc.get('tokensCount-lexical');
							var position = Math.floor(totalTokens * data.fraction);
							var bufferPosition = position - (this.getApiParam('limit')/2);
							this.setApiParams({'skipToDocId': doc.getId(), start: bufferPosition < 0 ? 0 : bufferPosition});
							this.load(true);
						},
						scope: this
					}
    		    },{
					xtype: 'entitieslist',
					region: 'east',
					weight: 10,
					width: '40%',
					split: {
						size: 2
					},
					splitterResize: true,
					border: false,
					hidden: true,
					collapsible: true,
					animCollapse: false
				}]
    	    },

    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	glyph: 'xf060@FontAwesome',
            		handler: function() {
            			this.fetchPrevious(true);
            		},
            		scope: this
            	},{
            		glyph: 'xf061@FontAwesome',
            		handler: function() {
            			this.fetchNext(true);
            		},
            		scope: this
            	},{xtype: 'tbseparator'},{
                    xtype: 'querysearchfield'
                },'->',{
					glyph: 'xf0eb@FontAwesome',
					tooltip: this.localize('highlightEntities'),
					itemId: 'nerServiceParent',
					hidden: true,
					menu: {
						items: [{
							xtype: 'menucheckitem',
							group: 'nerService',
							text: this.localize('nerSpacy'),
							itemId: 'spacy',
							checked: true,
							handler: this.nerSeviceHandler,
							scope: this
						},{
							xtype: 'menucheckitem',
							group: 'nerService',
							text: this.localize('nerNssi'),
							itemId: 'nssi',
							checked: false,
							handler: this.nerSeviceHandler,
							scope: this
						},{
							xtype: 'menucheckitem',
							group: 'nerService',
							text: this.localize('nerVoyant'),
							itemId: 'stanford',
							checked: false,
							handler: this.nerSeviceHandler,
							scope: this
						}
						// ,{
						// 	xtype: 'menucheckitem',
						// 	group: 'nerService',
						// 	text: 'NER with Voyant (OpenNLP)',
						// 	itemId: 'opennlp',
						// 	checked: false,
						// 	handler: this.nerSeviceHandler,
						// 	scope: this
						// }
						]
					}
				}]
    		}],
    		listeners: {
    			loadedCorpus: function(src, corpus) {
    	    		this.getTokensStore().setCorpus(corpus);
    	    		this.getDocumentTermsStore().getProxy().setExtraParam('corpus', corpus.getId());
    	    		
    	    		var docs = corpus.getDocuments();
    	    		this.setDocumentsStore(docs);
					
    	    		if (this.rendered) {
    	    			this.load();
        	    		if (this.hasCorpusAccess(corpus)==false) {
        	    			this.mask(this.localize("limitedAccess"), 'mask-no-spinner')
        	    		}
        	    		var query = this.getApiParam('query');
        	    		if (query) {
        	    			this.loadQueryTerms(Ext.isString(query) ? [query] : query);
        	    		}
    	    		}
    	    		
    			},
            	termsClicked: function(src, terms) {
            		var queryTerms = [];
            		terms.forEach(function(term) {
            			if (Ext.isString(term)) {queryTerms.push(term);}
            			else if (term.term) {queryTerms.push(term.term);}
            			else if (term.getTerm) {queryTerms.push(term.getTerm());}
            		});
            		if (queryTerms.length > 0) {
            			this.loadQueryTerms(queryTerms);
            		}
        		},
        		corpusTermsClicked: function(src, terms) {
        			var queryTerms = [];
            		terms.forEach(function(term) {
            			if (term.getTerm()) {queryTerms.push(term.getTerm());}
            		});
            		this.loadQueryTerms(queryTerms);
        		},
        		documentTermsClicked: function(src, terms) {
        			var queryTerms = [];
            		terms.forEach(function(term) {
            			if (term.getTerm()) {queryTerms.push(term.getTerm());}
            		});
            		this.loadQueryTerms(queryTerms);
        		},
        		documentSelected: function(src, document) {
        			var corpus = this.getTokensStore().getCorpus();
        			var doc = corpus.getDocument(document);
        			this.setApiParams({'skipToDocId': doc.getId(), start: 0});
					this.load(true);
        		},
        		documentsClicked: function(src, documents, corpus) {
        			if (documents.length > 0) {
            			var doc = documents[0];
            			this.setApiParams({'skipToDocId': doc.getId(), start: 0});
						this.load(true);
            		}
        		},
        		termLocationClicked: function(src, terms) {
    				if (terms[0] !== undefined) {
    					var term = terms[0];
    					var docIndex = term.get('docIndex');
    					var position = term.get('position');
    					this.showTermLocation(docIndex, position, term);
    				};
        		},
        		documentIndexTermsClicked: function(src, terms) {
        			if (terms[0] !== undefined) {
    					var term = terms[0];
    					var termRec = Ext.create('Voyant.data.model.Token', term);
    					this.fireEvent('termLocationClicked', this, [termRec]);
        			}
        		},
				entityClicked: function(src, entity) {
					var docIndex = entity.get('docIndex');
					var position = entity.get('positions')[0];
					if (Array.isArray(position)) position = position[0];
					this.showTermLocation(docIndex, position, entity);
					
				},
				entityLocationClicked: function(src, entity, positionIndex) {
					var docIndex = entity.get('docIndex');
					var position = entity.get('positions')[positionIndex];
					if (Array.isArray(position)) position = position[0];
					this.showTermLocation(docIndex, position, entity);
				},
				scope: this
    		}
    	});
    	
        this.callParent(arguments);
    },
    
    loadQueryTerms: function(queryTerms) {
    	if (queryTerms && queryTerms.length > 0) {
			var docId = this.getApiParam('skipToDocId');
			if (docId === undefined) {
				var docIndex = 0;
				var locationInfo = this.getLocationInfo();
				if (locationInfo) {
					docIndex = locationInfo[0].docIndex;
				}
				docId = this.getCorpus().getDocument(docIndex).getId();
			}
			this.getDocumentTermsStore().load({
				params: {
					query: queryTerms,
					docId: docId,
					categories: this.getApiParam('categories'),
					limit: -1
    			}
			});
			this.down('readergraph').loadQueryTerms(queryTerms);
		}
    },

	showTermLocation(docIndex, position, term) {
		var bufferPosition = position - (this.getApiParam('limit')/2);
		var doc = this.getCorpus().getDocument(docIndex);
		this.setApiParams({'skipToDocId': doc.getId(), start: bufferPosition < 0 ? 0 : bufferPosition});
		this.load(true, {
			callback: function() {
				var el = this.body.dom.querySelector("#_" + docIndex + "_" + position);
				if (el) {
					el.scrollIntoView({
						block: 'center'
					});
					Ext.fly(el).frame('#f80');
				}
				if (term.get('type')) {
					this.highlightEntities();
				} else {
					this.highlightKeywords(term, false);
				}
			},
			scope: this
		});
	},
    
    highlightKeywords: function(termRecords, doScroll) {
		var container = this.getInnerContainer().first();
		container.select('span[class*=keyword]').removeCls('keyword').applyStyles({backgroundColor: 'transparent', color: 'black'});

		if (termRecords === undefined && this.getDocumentTermsStore().getCount() > 0) {
			termRecords = this.getDocumentTermsStore().getData().items;
		}
		if (termRecords === undefined) {
			return;
		}

		if (!Ext.isArray(termRecords)) termRecords = [termRecords];

		termRecords.forEach(function(r) {
			var term = r.get('term');
			var bgColor = this.getApplication().getColorForTerm(term);
			var textColor = this.getApplication().getTextColorForBackground(bgColor);
			bgColor = 'rgb('+bgColor.join(',')+') !important';
			textColor = 'rgb('+textColor.join(',')+') !important';
			var styles = 'background-color:'+bgColor+';color:'+textColor+';';
			
			// might be slightly faster to use positions so do that if they're available
			if (r.get('positions')) {
				var positions = r.get('positions');
				var docIndex = r.get('docIndex');
				
				positions.forEach(function(pos) {
					var match = container.dom.querySelector('#_'+docIndex+'_'+pos);
					if (match) {
						Ext.fly(match).addCls('keyword').dom.setAttribute('style', styles);
					}
				})
			} else {
				var caseInsensitiveQuery = new RegExp('^'+term+'$', 'i');
				var nodes = container.select('span.word');
				nodes.each(function(el, compEl, index) {
					if (el.dom.firstChild && el.dom.firstChild.nodeValue.match(caseInsensitiveQuery)) {
						el.addCls('keyword').dom.setAttribute('style', styles);
					}
				});
			}
		}, this);
	},

	nerSeviceHandler: function(menuitem) {
		var annotator = menuitem.itemId;

		var docIndex = [];
		var locationInfo = this.getLocationInfo();
		if (locationInfo) {
			for (var i = locationInfo[0].docIndex; i <= locationInfo[1].docIndex; i++) {
				docIndex.push(i);
			}
		} else {
			docIndex.push(0);
		}

		this.clearEntityHighlights();

		var me = this;
		new Voyant.data.util.DocumentEntities({
			annotator: annotator,
			includeEntities: true,
			docIndex: docIndex
		}, function(entities) {
			if (entities) {
				me.clearEntityHighlights(); // clear again in case failed documents were rerun
				me.setDocumentEntitiesStore(entities);
				me.highlightEntities();
				me.down('entitieslist').show().addEntities(entities);
			}
		});
	},

	clearEntityHighlights: function() {
		var container = this.getInnerContainer().first();
		container.select('.entity').each(function(el) {
			el.removeCls('entity start middle end location person organization misc money time percent date duration set unknown');
			el.dom.setAttribute('data-qtip', el.dom.getAttribute('data-qtip').replace(/<div class="entity">.*?<\/div>/g, ''));
		});
	},

	highlightEntities: function() {
		var container = this.getInnerContainer().first();
		var entities = this.getDocumentEntitiesStore();
		var entityTypeStr = this.localize('entityType');
		entities.forEach(function(entity) {
			var positionInstances = entity.positions;
			if (positionInstances) {
				positionInstances.forEach(function(positions) {
					var multiTermEntity = positions.length > 1;
					if (multiTermEntity) {
						// find the difference between start and end positions
						if (positions.length === 2 && positions[1]-positions[0] > 1) {
							// more than two terms, so fill in the middle positions
							var endPos = positions[1];
							var curPos = positions[0]+1;
							var curIndex = 1;
							while (curPos < endPos) {
								positions.splice(curIndex, 0, curPos);
								curPos++;
								curIndex++;
							}
						}
					}

					for (var i = 0, len = positions.length; i < len; i++) {
						var position = positions[i];
						if (position === -1) {
							console.warn('missing position for: '+entity.term);
						} else {
							var match = container.selectNode('#_'+entity.docIndex+'_'+position, false);
							if (match) {
								var termEntityPosition = '';
								if (multiTermEntity) {
									if (i === 0) {
										termEntityPosition = 'start ';
									} else if (i === len-1) {
										termEntityPosition = 'end ';
									} else {
										termEntityPosition = 'middle ';
									}
								}

								match.addCls('entity '+termEntityPosition+entity.type);
								var prevQTip = match.dom.getAttribute('data-qtip');
								if (prevQTip.indexOf('class="entity"') === -1) {
									match.dom.setAttribute('data-qtip', prevQTip+'<div class="entity">'+entityTypeStr+': '+entity.type+'</div>');
								}
							}
						}
					}
				});
			} else {
				console.warn('no positions for: '+entity.term);
			}
		});
	},
    
	fetchPrevious: function(scroll) {
		var readerContainer = this.getInnerContainer().first();
		var first = readerContainer.first('.word');
		if (first != null && first.hasCls("loading")===false) {
			while(first) {
				if (first.hasCls("word")) {
					var info = Voyant.data.model.Token.getInfoFromElement(first);
					var docIndex = info.docIndex;
					var start = info.position;
					var doc = this.getDocumentsStore().getAt(docIndex);    						
					var limit = this.getApiParam('limit');
					var getPrevDoc = false;
					if (docIndex === 0 && start === 0) {
						var scrollContainer = this.down('panel[region="center"]').body;
						var scrollNeeded = first.getScrollIntoViewXY(scrollContainer, scrollContainer.dom.scrollTop, scrollContainer.dom.scrollLeft);
						if (scrollNeeded.y != 0) {
							first.dom.scrollIntoView();
						}
						first.frame("red");
						break;
					}
					if (docIndex > 0 && start === 0) {
						getPrevDoc = true;
						docIndex--;
						doc = this.getDocumentsStore().getAt(docIndex);
						var totalTokens = doc.get('tokensCount-lexical');
						start = totalTokens-limit;
						if (start < 0) {
							start = 0;
							this.setApiParam('limit', totalTokens);
						}
					} else {
						limit--; // subtract one to limit for the word we're removing. need to do this to account for non-lexical tokens before/after first word.
						start -= limit;
					}
					if (start < 0) start = 0;
					
					var mask = first.insertSibling("<div class='loading'>"+this.localize('loading')+"</div>", 'before', false).mask();
					if (!getPrevDoc) {
						first.destroy();
					}
					
					var id = doc.getId();
					this.setApiParams({'skipToDocId': id, start: start});
					this.setInsertWhere('afterBegin')
					this.setScrollIntoView(scroll);
					this.load();
					this.setApiParam('limit', this.INITIAL_LIMIT);
					break;
				}
				first.destroy(); // remove non word
				first = readerContainer.first();
			}
		}
	},
	
	fetchNext: function(scroll) {
		var readerContainer = this.getInnerContainer().first();
		var last = readerContainer.last();
		if (last.hasCls("loading")===false) {
			while(last) {
				if (last.hasCls("word")) {
					var info = Voyant.data.model.Token.getInfoFromElement(last);
					var docIndex = info.docIndex;
					var start = info.position;
					var doc = this.getDocumentsStore().getAt(info.docIndex);
					var id = doc.getId();
					
					var totalTokens = doc.get('tokensCount-lexical');
					if (start + this.getApiParam('limit') >= totalTokens && docIndex == this.getCorpus().getDocumentsCount()-1) {
						var limit = totalTokens - start;
						if (limit <= 1) {
							last.dom.scrollIntoView();
							last.frame("red")
							break;
						} else {
							this.setApiParam('limit', limit);
						}
					}
					
					// remove any text after the last word
					var nextSib = last.dom.nextSibling;
					while(nextSib) {
						var oldNext = nextSib;
						nextSib = nextSib.nextSibling;
						oldNext.parentNode.removeChild(oldNext);
					}
					
					var mask = last.insertSibling("<div class='loading'>"+this.localize('loading')+"</div>", 'after', false).mask();
					last.destroy();
					this.setApiParams({'skipToDocId': id, start: info.position});
					this.setInsertWhere('beforeEnd');
					this.setScrollIntoView(scroll);
					this.load(); // callback not working on buffered store
					this.setApiParam('limit', this.INITIAL_LIMIT);
					break;
				}
				last.destroy(); // remove non word
				last = readerContainer.last();
			}
		}
	},
	
    load: function(doClear, config) {
    	if (doClear) {
    		this.getInnerContainer().first().destroy(); // clear everything
    		this.getInnerContainer().setHtml('<div class="readerContainer"><div class="loading">'+this.localize('loading')+'</div></div>');
			this.getInnerContainer().first().first().mask();
		}

		// check if we're loading a different doc and update terms store if so
		var tokensStore = this.getTokensStore();
		if (tokensStore.lastOptions && tokensStore.lastOptions.params.skipToDocId && tokensStore.lastOptions.params.skipToDocId !== this.getApiParam('skipToDocId')) {
			var dts = this.getDocumentTermsStore();
			if (dts.lastOptions) {
				var query = dts.lastOptions.params.query;
				this.loadQueryTerms(query);
			}
		}

    	this.getTokensStore().load(Ext.apply(config || {}, {
    		params: Ext.apply(this.getApiParams(), {
    			stripTags: 'blocksOnly',
    			stopList: '' // token requests shouldn't have stopList
    		})
    	}));
    },
    
    updateText: function(contents) {
    	var loadingMask = this.getInnerContainer().down('.loading');
    	if (loadingMask) loadingMask.destroy();
    	// FIXME: something is weird here in tool/Reader mode, this.getInnerContainer() seems empty but this.getInnerContainer().first() gets the canvas?!?
    	var inserted = this.getInnerContainer().first().insertHtml(this.getInsertWhere()/* where is this defined? */, contents, true); // return Element, not dom
    	if (inserted && this.getScrollIntoView()) {
    		inserted.dom.scrollIntoView(); // use dom
    		// we can't rely on the returned element because it can be a transient fly element, but the id is right in a deferred call
    		Ext.Function.defer(function() {
    			var el = Ext.get(inserted.id); // re-get el
    			if (el) {el.frame("red")}
    		}, 100);
    	}
    	var target = this.down('panel[region="center"]').body.dom;
    	var amount;
		if (target.scrollTop == 0) {
			amount = 0;
		} else if (target.scrollHeight - target.scrollTop == target.clientHeight) {
			amount = 1;
		} else {
			amount = (target.scrollTop + target.clientHeight * 0.5) / target.scrollHeight;
		}
    	this.updateLocationMarker(amount);
	},
	
	updateLocationMarker: function(amount, scrollDir) {
		var locationInfo = this.getLocationInfo();
		if (locationInfo) {
			var info1 = locationInfo[0];
			var info2 = locationInfo[1];

			var corpus = this.getCorpus();
			var partialFirstDoc = false;

			if (info1.position !== 0) {
				partialFirstDoc = true;
			}

			var docTokens = {};
			var totalTokens = 0;
			var showNerButton = this.getApplication().getEntitiesEnabled ? this.getApplication().getEntitiesEnabled() : false;
			var currIndex = info1.docIndex;
			while (currIndex <= info2.docIndex) {
				var tokens = corpus.getDocument(currIndex).get('tokensCount-lexical');
				if (tokens > this.MAX_TOKENS_FOR_NER) {
					showNerButton = false;
				}
				if (currIndex === info2.docIndex) {
					tokens = info2.position; // only count tokens up until last displayed word
				}
				if (currIndex === info1.docIndex) {
					tokens -= info1.position; // subtract missing tokens, if any
				}
				totalTokens += tokens;
				docTokens[currIndex] = tokens;
				currIndex++;
			}

			var nerParent = this.down('#nerServiceParent');
			if (showNerButton) {
				nerParent.show();
			} else {
				nerParent.hide();
			}
			
			var tokenPos = Math.round(totalTokens * amount);
			var docIndex = 0;
			var currToken = 0;
			for (var i = info1.docIndex; i <= info2.docIndex; i++) {
				docIndex = i;
				currToken += docTokens[i];
				if (currToken >= tokenPos) {
					break;
				}
			}
			var remains = (currToken - tokenPos);
			var tokenPosInDoc = docTokens[docIndex] - remains;
			
			if (partialFirstDoc && docIndex === info1.docIndex) {
				tokenPosInDoc += info1.position;
			}
				
			var fraction = tokenPosInDoc / corpus.getDocument(docIndex).get('tokensCount-lexical');

			this.down('readergraph').moveLocationMarker(docIndex, fraction, scrollDir);
		}
	},

	getLocationInfo: function() {
		var readerWords = Ext.DomQuery.select('.word', this.getInnerContainer().down('.readerContainer', true));
		var firstWord = readerWords[0];
		var lastWord = readerWords[readerWords.length-1];
		if (firstWord !== undefined && lastWord !== undefined) {
			var info1 = Voyant.data.model.Token.getInfoFromElement(firstWord);
			var info2 = Voyant.data.model.Token.getInfoFromElement(lastWord);
			return [info1, info2];
		} else {
			return null;
		}
	}
});

Ext.define('Voyant.panel.SimpleDocReader', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.simpledocreader',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		docIndex: undefined,
    		docId: undefined
    	},
    	glyph: 'xf0f6@FontAwesome'
	},
    config: {
    },
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function(config) {
    	var me = this;
    	Ext.apply(this, {
    		html: '<iframe style="width: 100%; height: 100%; border: none;"></iframe>',
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	glyph: 'xf060@FontAwesome',
            		handler: this.fetchPrevious,
            		scope: this
            	},{
            		glyph: 'xf061@FontAwesome',
            		handler: this.fetchNext,
            		scope: this
                }]
    		}],
    		listeners: {
    			loadedCorpus: function(src, corpus) {
    				
    				// we can keep the reader blank to begin
    				if (this.getApiParam("autoLoadOnLoadedCorpus", "false")==="true") {return;}
    				
    				this.fireEvent("documentSelected", this, 0);
    				
    			},
        		documentSelected: function(src, document) {
        			this.setApiParams({
        				docIndex: this.getCorpus().getDocument(document).getIndex(),
        				docId: undefined
        			});
        			this.fetch();
        		},
        		scope: this
    		}
    	});
    	
        this.callParent(arguments);
    },
    
	fetchPrevious: function() {
		var doc;
		if (this.getApiParam("docIndex")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docIndex"));}
		else if (this.getApiParam("docId")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docId"));}
		else {doc = this.getCorpus().getDocument(1);}
		if (doc.getIndex()>0) {
			this.setApiParams({docIndex: doc.getIndex()-1, docId: undefined});
			this.fetch();
		} else {
			this.toastInfo(this.localize('noPrevious'))
		}
	},
	
	fetchNext: function() {
		var doc;
		if (this.getApiParam("docIndex")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docIndex"));}
		else if (this.getApiParam("docId")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docId"));}
		else {
			this.setApiParams({docIndex: 0, docId: undefined});
			return this.fetch();
		}
		if (doc.getIndex()<this.getCorpus().getDocumentsCount()-1) {
			this.setApiParams({docIndex: doc.getIndex()+1, docId: undefined});
			this.fetch();
		} else {
			this.toastInfo(this.localize('noNext'))
		}
	},
	
	fetch: function() {
		var doc;
		if (this.getApiParam("docIndex")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docIndex"));}
		else if (this.getApiParam("docId")!==undefined) {doc = this.getCorpus().getDocument(this.getApiParam("docId"));}
		else {doc = this.getCorpus().getDocument(0);}
		var iframe = this.getTargetEl().down("iframe", true);
		iframe.setAttribute("src", "about:blank")
		if (this.getApiParam("originalUrlMetadataKey")) {
			var url = doc.get(this.getApiParam("originalUrlMetadataKey"));
			if (url) {
				iframe.setAttribute("src", url)
				return;
			}
		}
		
		var params = {
			corpus: this.getCorpus().getId(),
			docIndex: doc.getIndex(),
			tool: 'corpus.DocumentTokens',
			template: 'docTokensPlusStructure2html',
			outputFormat: 'html',
			limit: 0
		}
		var url = this.getTromboneUrl() + "?" + Ext.Object.toQueryString(params);
		iframe.setAttribute("src", url);

	}
});

Ext.define('Voyant.panel.ScatterPlot', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Ext.chart.CartesianChart'],
	alias: 'widget.scatterplot',
    statics: {
    	i18n: {
    	},
    	api: {
    		docId: undefined,
    		analysis: 'ca',
    		limit: 50,
    		dimensions: 3,
    		bins: 10,
    		clusters: 3,
    		perplexity: 15,
    		iterations: 1500,
    		comparisonType: 'relative',
    		stopList: 'auto',
    		target: undefined,
    		term: undefined,
    		query: undefined,
    		whitelist: undefined,
    		label: ['summary', 'docs', 'terms'],
    		storeJson: undefined
    	},
		glyph: 'xf06e@FontAwesome'
    },
	config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	caStore: null,
    	pcaStore: null,
    	tsneStore: null,
    	docSimStore: null,
    	termStore: null,
    	chartMenu: null,
    	newTerm: null,
    	termsTimeout: null,
    	highlightData: {x: 0, y: 0, r: 0},
        highlightTask: null
	},
    
    tokenFreqTipTemplate: null,
    docFreqTipTemplate: null,
    
    constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		if ("storeJson" in config) {
    		var json = JSON.parse(config.storeJson);
    		Ext.apply(config, json);
    	}
		this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
    	this.setCaStore(Ext.create('Voyant.data.store.CAAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	this.setPcaStore(Ext.create('Voyant.data.store.PCAAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	this.setTsneStore(Ext.create('Voyant.data.store.TSNEAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	this.setDocSimStore(Ext.create('Voyant.data.store.DocSimAnalysis', {
    		listeners: {load: this.maskAndBuildChart, scope: this}
    	}));
    	
    	this.setTermStore(Ext.create('Ext.data.JsonStore', {
			fields: [
				{name: 'term'},
				{name: 'rawFreq', type: 'int'},
				{name: 'relativeFreq', type: 'number'},
				{name: 'coordinates', mapping : 'vector'},
				{name: 'category'}
			],
			sorters: [{property: 'rawFreq', direction: 'DESC'}],
			groupField: 'category'
		}));
    	
    	this.setChartMenu(Ext.create('Ext.menu.Menu', {
    		items: [
    			{text: this.localize('remove'), itemId: 'remove', glyph: 'xf068@FontAwesome'},
    			{text: this.localize('nearby'), itemId: 'nearby', glyph: 'xf0b2@FontAwesome'}
    		],
    		listeners: {
    			hide: function() {
    				var series = this.down('#chart').getSeries();
    				series[0].enableToolTips();
    				series[1].enableToolTips();
    			},
    			scope: this
    		}
    	}));
    	
    	this.tokenFreqTipTemplate = new Ext.Template(this.localize('tokenFreqTip'));
    	this.docFreqTipTemplate = new Ext.Template(this.localize('docFreqTip'));
    	
        Ext.apply(this, {
        	title: this.localize('title'),
        	layout: 'border',
        	autoDestroy: true,
        	items: [{
    			itemId: 'chartParent',
    			region: 'center',
    			layout: 'fit',
        		tbar: {
        			overflowHandler: 'scroller',
        			items: [{
        				xtype: 'querysearchfield',
        				itemId: 'filterTerms',
        				width: 150
        			},{
                		text: this.localize('labels'),
                		itemId: 'labels',
                		glyph: 'xf02b@FontAwesome',
                		menu: {
                			items: [
                			    {text: this.localize("summaryLabel"), itemId: 'summary', xtype: 'menucheckitem'},
                			    {text: this.localize("docsLabel"), itemId: 'docs', xtype: 'menucheckitem'},
                			    {text: this.localize("termsLabel"), itemId: 'terms', xtype: 'menucheckitem'}
                			],
        					listeners: {
        						afterrender: function(menu) {
        							var labels = this.getApiParam('label');
        							menu.items.each(function(item) {
        								item.setChecked(labels.indexOf(item.getItemId())>-1)
        							})
        						},
        						click: function(menu, item) {
        							var labels = this.getApiParam("label");
        							var label = item.getItemId();
        							if (Ext.isString(labels)) {labels = [labels]}
        							if (item.checked && labels.indexOf(label)==-1) {
        								labels.push(label)
        							} else if (!item.checked && labels.indexOf(label)>-1) {
        								labels = labels.filter(function(item) {return item!=label})
        							}
        							this.setApiParam("label", labels);
        							this.doLabels();
        							this.queryById('chart').redraw();
        						},
        						scope: this
        					}
                		}
                	}]
        			
        		},
        		listeners: {
        			query: function(component, value) {
        				this.getTermStore().filter([{property: 'term', value: value, anyMatch: true}]);
        				this.filterChart(value);
        			},
        			scope: this
        		}
    		},{
    			itemId: 'optionsPanel',
        		title: this.localize('options'),
        		region: 'west',
        		split: true,
        		collapsible: true,
        		collapseMode: 'header',
        		width: 135,
        		scrollable: 'y',
        		layout: {
        			type: 'vbox',
        			align: 'stretch'
        		},
        		defaults: {
        			xtype: 'button',
        			margin: '5',
        			labelAlign: 'top'
        		},
        		items: [{
        			xtype: 'label',
        			text: this.localize('input')
        		},{
    				xtype: 'documentselectorbutton'
    			},{
	            	text: this.localize('freqsMode'),
	            	itemId: 'comparisonType',
					glyph: 'xf201@FontAwesome',
				    tooltip: this.localize('freqsModeTip'),
				    menu: {
				    	items: [
			               {text: this.localize("rawFrequencies"), itemId: 'comparisonType_raw', group: 'freqsMode', xtype: 'menucheckitem'},
			               {text: this.localize("relativeFrequencies"), itemId: 'comparisonType_relative', group: 'freqsMode', xtype: 'menucheckitem'},
			               {text: this.localize("tfidf"), itemId: 'comparisonType_tfidf', group: 'freqsMode', xtype: 'menucheckitem'}
			            ],
       					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var type = item.getItemId().split('_')[1];
    								if (type !== this.getApiParam('comparisonType')) {
	    								this.setApiParam('comparisonType', type);
	    								this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    				    }
				    }
        		},{
        			fieldLabel: this.localize('numTerms'),
        			itemId: 'limit',
        			xtype: 'numberfield',
        			minValue: 5,
        			listeners: {
        				change: function(numb, newValue, oldValue) {
        					function doLoad() {
        						this.setApiParam('limit', newValue);
            					this.loadFromApis();
							}
							if (oldValue !== null) {
								if (this.getTermsTimeout() !== null) {
									clearTimeout(this.getTermsTimeout());
								}
								if (numb.isValid()) {
									this.setTermsTimeout(setTimeout(doLoad.bind(this), 500));
								}
							}
        				},
        				scope: this
        			}
        		},{
        			xtype: 'container',
        			html: '<hr style="border: none; border-top: 1px solid #cfcfcf;"/>'
        		},{
        			xtype: 'label',
        			text: this.localize('output')
        		},{
            		text: this.localize('analysis'),
            		itemId: 'analysis',
            		glyph: 'xf1ec@FontAwesome',
                    overflowHandler: 'scroller',
        			menu: {
    					items: [
    					    {text: this.localize('pca'), itemId: 'analysis_pca', group:'analysis', xtype: 'menucheckitem'},
    					    {text: this.localize('ca'), itemId: 'analysis_ca', group:'analysis', xtype: 'menucheckitem'},
    					    {text: this.localize('tsne'), itemId: 'analysis_tsne', group:'analysis', xtype: 'menucheckitem'},
    					    {text: this.localize('docSim'), itemId: 'analysis_docSim', group:'analysis', xtype: 'menucheckitem'}
    					],
    					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var analysis = item.getItemId().split('_')[1];
    								if (analysis !== this.getApiParam('analysis')) {
    									this.doAnalysisChange(analysis);
    									this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    					}
        			}
	            },{
	            	fieldLabel: this.localize('perplexity'),
	            	itemId: 'perplexity',
	            	xtype: 'slider',
	            	minValue: 5,
	            	maxValue: 100,
	            	increment: 1,
	            	listeners: {
	            		changecomplete: function(slider, newValue) {
	            			this.setApiParam('perplexity', newValue);
	            			this.loadFromApis(true);
	            		},
	            		scope: this
	            	}
	            },{
	            	fieldLabel: this.localize('iterations'),
	            	itemId: 'iterations',
	            	xtype: 'slider',
	            	minValue: 100,
	            	maxValue: 5000,
	            	increment: 100,
	            	listeners: {
	            		changecomplete: function(slider, newValue) {
	            			this.setApiParam('iterations', newValue);
	            			this.loadFromApis(true);
	            		},
	            		scope: this
	            	}
	            },{
            		text: this.localize('clusters'),
            		itemId: 'clusters',
            		glyph: 'xf192@FontAwesome',
            		menu: {
            			items: [
            			    {text: '1', itemId: 'clusters_1', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '2', itemId: 'clusters_2', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '3', itemId: 'clusters_3', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '4', itemId: 'clusters_4', group: 'clusters', xtype: 'menucheckitem'},
            			    {text: '5', itemId: 'clusters_5', group: 'clusters', xtype: 'menucheckitem'}
            			],
    					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var clusters = parseInt(item.getItemId().split('_')[1]);
    								if (clusters !== this.getApiParam('clusters')) {
        								this.setApiParam('clusters', clusters);
        								this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    					}
            		}
            	},{
            		text: this.localize('dimensions'),
            		itemId: 'dimensions',
            		glyph: 'xf1b2@FontAwesome',
            		menu: {
            			items: [
            			    {text: '2', itemId: 'dimensions_2', group: 'dimensions', xtype: 'menucheckitem'},
            			    {text: '3', itemId: 'dimensions_3', group: 'dimensions', xtype: 'menucheckitem'}
            			],
    					listeners: {
    						click: function(menu, item) {
    							if (item !== undefined) {
    								var dims = parseInt(item.getItemId().split('_')[1]);
    								if (dims !== this.getApiParam('dimensions')) {
        								if (dims == 3 && this.getApiParam('analysis') == 'ca' && this.getCorpus().getDocumentsCount() == 3) {
        									dims = 2;
        									// TODO add info message 'Because of the nature of Correspondence Analysis, you can only use 2 dimensions with 3 documents.'
        									return false;
        								}
        								
        								this.setApiParam('dimensions', dims);
        								this.loadFromApis(true);
    								}
    							}
    						},
    						scope: this
    					}
            		}
        		},{
        			itemId: 'reloadButton',
        			text: this.localize('reload'),
        			glyph: 'xf021@FontAwesome',
        			handler: function() {
        				this.loadFromApis();
        			},
        			scope: this
        		}]
        	},{
        		itemId: 'termsGrid',
        		xtype: 'grid',
        		title: this.localize('terms'),
        		region: 'east',
        		width: 250,
        		split: true,
        		collapsible: true,
        		collapseMode: 'header',
        		forceFit: true,
        		features: [{
        			ftype: 'grouping',
        			hideGroupedHeader: true,
                    enableGroupingMenu: false
        		}],
        		bbar: {
                    overflowHandler: 'scroller',
        			items: [{
        				itemId: 'nearbyButton',
                        xtype: 'button',
                        text: this.localize('nearby'),
                        glyph: 'xf0b2@FontAwesome',
                        flex: 1,
                        handler: function(btn) {
                        	var sel = btn.up('panel').getSelection()[0];
                        	if (sel === undefined) {
                        		this.toastError({
                        			html: this.localize("noTermSelected"),
                        		     anchor: btn.up("panel").getTargetEl()
                        		 });
                        	}
                        	else {
	                        	var term = sel.get('term');
	                        	this.getNearbyForTerm(term);
                        	}
                        },
                        scope: this
                    },{
                    	itemId: 'removeButton',
                        xtype: 'button',
                        text: this.localize('remove'),
                        glyph: 'xf068@FontAwesome',
                        flex: 1,
                        handler: function(btn) {
                        	var sel = btn.up('panel').getSelection()[0];
                        	if (sel === undefined) {
                        		this.toastError({
                        			html: this.localize("noTermSelected"),
                        		     anchor: btn.up("panel").getTargetEl()
                        		 });
                        	}
                        	else {
	                        	var term = sel.get('term');
	                        	this.removeTerm(term);
                        	}
                        },
                        scope: this
                    }]
        			
        		},
        		tbar: {
                    overflowHandler: 'scroller',
                    items: [{
                    	xtype: 'querysearchfield',
                    	itemId: 'addTerms',
//                    	emptyText: this.localize('addTerm'),
                    	flex: 1
                    }]
                },
        		columns: [{
        			text: this.localize('term'),
    				dataIndex: 'term',
    				flex: 1,
                    sortable: true
    			},{
    				text: this.localize('rawFreq'),
    				dataIndex: 'rawFreq',
    				flex: 0.75,
    				minWidth: 70,
                    sortable: true
    			},{
    				text: this.localize('relFreq'),
    				dataIndex: 'relativeFreq',
    				flex: 0.75,
    				minWidth: 70,
                    sortable: true,
                    hidden: true
    			}],
    			selModel: {
    				type: 'rowmodel',
    				mode: 'SINGLE',
    				allowDeselect: true,
    				toggleOnClick: true,
                    listeners: {
                        selectionchange: {
                        	fn: function(sm, selections) {
//                        		this.getApplication().dispatchEvent('corpusTermsClicked', this, selections);
                        		var sel = selections[0];
                        		if (sel !== undefined) {
	                        		var term = sel.get('term');
	                        		var isDoc = sel.get('category') === 'document';
	                        		this.selectTerm(term, isDoc);
	                        		
	                        		if (isDoc) {
	                        			this.queryById('nearbyButton').disable();
	                        			this.queryById('removeButton').disable();
	                        		} else {
	                        			this.queryById('nearbyButton').enable();
	                        			this.queryById('removeButton').enable();
	                        		}
                        		} else {
                        			this.selectTerm();
                        		}
                        	},
                        	scope: this
                        }
                    }
                },
        		store: this.getTermStore(),
        		listeners: {
        			expand: function(panel) {
        				panel.getView().refresh();
        			},
        			query: function(component, value) {
        				if (value.length > 0 && this.getTermStore().findExact('term', value[0]) === -1) {
	                		this.setNewTerm(value);
	                		this.loadFromApis();
    					} else {
    						this.setNewTerm(null);
    					}
        			},
        			scope: this
        		}
        	}]
        });
        
        this.on('boxready', function(component, width, height) {
			if (width < 400) {
				this.queryById('optionsPanel').collapse();
				this.queryById('termsGrid').collapse();
			}
			if (this.config.storeClass && this.config.storeData) {
				this.loadStoreFromJson(this.config.storeClass, this.config.storeData);
			}
		}, this);
        
        this.on('beforedestroy', function(component) {
        	var oldChart = this.queryById('chart');
        	if (oldChart !== null) {
        		this.queryById('chartParent').remove(oldChart);
        	}
        }, this);
        
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		function setCheckItemFromApi(apiParamName) {
    			var value = this.getApiParam(apiParamName);
    			var menu = this.queryById(apiParamName);
    			var item = menu.down('#'+apiParamName+'_'+value);
    			item.setChecked(true);
    		}
    		var setCheckBound = setCheckItemFromApi.bind(this);
    		
    		setCheckBound('analysis');
    		this.doAnalysisChange(this.getApiParam('analysis'));
    		
    		setCheckBound('comparisonType');
    		setCheckBound('clusters');

    		this.queryById('perplexity').setValue(this.getApiParam('perplexity'));
    		this.queryById('iterations').setValue(this.getApiParam('iterations'));
    		
    		if (corpus.getDocumentsCount() == 3) {
    			this.setApiParam('dimensions', 2);
    		}
    		setCheckBound('dimensions');

    		this.getCaStore().setCorpus(corpus);
    		this.getPcaStore().setCorpus(corpus);
    		this.getDocSimStore().setCorpus(corpus);
    		this.loadFromApis();
    	}, this);
    	
    	this.on('documentsSelected', function(src, docIds) {
    		this.setApiParam('docId', docIds);
    		this.loadFromApis();
    	}, this);
        
    	this.callParent(arguments);
    },
    
    doAnalysisChange: function(analysis) {
    	this.setApiParam('analysis', analysis);
		this.queryById('nearbyButton').setDisabled(analysis === 'tsne');
		this.queryById('reloadButton').setVisible(analysis === 'tsne');
		this.queryById('perplexity').setVisible(analysis === 'tsne');
		this.queryById('iterations').setVisible(analysis === 'tsne');
		if (analysis === 'ca') {
			// TODO handling for when there's no corpus
			if (this.getCorpus().getDocumentsCount() == 3) {
				this.setApiParam('dimensions', 2);
				this.queryById('dimensions').menu.items.get(0).setChecked(true); // need 1-2 docs or 4+ docs for 3 dimensions
			}
		}
    },
    
    loadStoreFromJson: function(storeClass, storeData) {
		if (storeClass == 'Voyant.data.store.CAAnalysis') {
			this.getCaStore().loadRawData(storeData);
			this.doAnalysisChange('ca');
			this.maskAndBuildChart.call(this, this.getCaStore());
		} else if (storeClass == 'Voyant.data.store.PCAAnalysis') {
			this.getPcaStore().loadRawData(storeData);
			this.doAnalysisChange('pca');
			this.maskAndBuildChart.call(this, this.getPcaStore());
		} else if (storeClass == 'Voyant.data.store.TSNEAnalysis') {
			this.getTsneStore().loadRawData(storeData);
			this.doAnalysisChange('tsne');
			this.maskAndBuildChart.call(this, this.getTsneStore());
		} else if (storeClass == 'Voyant.data.store.DocSimAnalysis') {
			this.getDocSimStore().loadRawData(storeData);
			this.doAnalysisChange('docSim');
			this.maskAndBuildChart.call(this, this.getDocSimStore());
		}
    },
    
    maskAndBuildChart: function(store) {
    	this.queryById('chartParent').mask(this.localize('plotting'));
    	Ext.defer(this.buildChart, 50, this, [store]);
    },

    buildChart: function(store) {
    	var that = this; // needed for tooltip renderer
    	
    	var oldChart = this.queryById('chart');
    	if (oldChart !== null) {
    		this.queryById('chartParent').remove(oldChart);
    	}
    	
    	this.queryById('termsGrid').getSelectionModel().deselectAll();
    	
    	var rec = store.getAt(0);
        var numDims = this.getApiParam('dimensions');
        
    	var summary = '';    	
    	if (this.getApiParam('analysis') === 'pca') {
    		// calculate the percentage of original data represented by the dominant principal components
			var pcs = rec.getPrincipalComponents();
			var eigenTotal = 0;
			for (var i = 0; i < pcs.length; i++) {
				var pc = pcs[i];
				eigenTotal += parseFloat(pc.get('eigenValue'));
			}
			if (eigenTotal == 0) {
				// do nothing
			} else {
				summary = this.localize('pcTitle')+'\n';
				var pcMapping = ['xAxis', 'yAxis', 'fill'];
				for (var i = 0; i < pcs.length; i++) {
					if (i >= numDims) break;
					
					var eigenValue = pcs[i].get('eigenValue');
					var percentage = eigenValue / eigenTotal * 100;
					summary += this.localize('pc')+' '+(i+1)+' ('+this.localize(pcMapping[i])+'): '+Math.round(percentage*100)/100+'%\n';
				}
			}
    	} else if (this.getApiParam('analysis') === 'tsne') {
    		
    	} else {
    		summary = this.localize('caTitle')+'\n';
    		var pcMapping = ['xAxis', 'yAxis', 'fill'];
    		
    		var dimensions = rec.getDimensions();
    		for (var i = 0; i < dimensions.length; i++) {
    			if (i >= numDims) break;
    			
    			var percentage = dimensions[i].get('percentage');
    			summary += this.localize('dimension')+' '+(i+1)+' ('+this.localize(pcMapping[i])+'): '+Math.round(percentage*100)/100+'%\n';
    		}
    	}
        
        var maxFreq = 0;
        var minFreq = Number.MAX_VALUE;
        var maxFill = 0;
        var minFill = Number.MAX_VALUE;
        
        
        if (this.getApiParam('analysis') !== 'docSim') { // docSim doesn't return terms so keep the current ones
	        this.getTermStore().removeAll();
        }
	        
        var tokens = rec.getTokens();
        var termData = [];
        var docData = [];
        tokens.forEach(function(token) {
        	var freq = token.get('rawFreq');
        	var category = token.get('category');
        	if (category === undefined) {
        		category = 'term'; // some analyses don't define categories
        		token.set('category', 'term');
        	}
        	var isTerm = category === 'term';
        	if (isTerm) {
	        	if (freq > maxFreq) maxFreq = freq;
	        	if (freq < minFreq) minFreq = freq;
        	}
        	if (this.getTermStore().findExact('term', token.get('term') === -1)) {
        		this.getTermStore().addSorted(token);
        	}
        	if (numDims === 3) {
				var z = token.get('vector')[2];
				if (z !== undefined) {
					if (z < minFill) minFill = z;
					if (z > maxFill) maxFill = z;
				}
			}
        	var tokenData = {
        		x: token.get('vector')[0], y: token.get('vector')[1] || 0, z: token.get('vector')[2] || 0,
    			term: token.get('term'), rawFreq: freq, relativeFreq: token.get('relativeFreq'), cluster: token.get('cluster'), category: category,
    			disabled: false
        	};
        	if (!isTerm) {
        		if (token.get('category') === 'bin') {
        			tokenData.term = tokenData.title = "Bin "+token.get('docIndex');
        		} else {
	        		tokenData.docIndex = token.get('docIndex');
	        		var doc = this.getCorpus().getDocument(tokenData.docIndex);
	        		if (doc !== null) {
		        		tokenData.term = doc.getShortTitle();
		        		tokenData.title = doc.getTitle();
	        		}
        		}
        		docData.push(tokenData);
        	} else {
        		termData.push(tokenData);
        	}
        }, this);
        
        var newCount = this.getTermStore().getCount();
        this.queryById('limit').setRawValue(newCount);
        this.setApiParam('limit', newCount);
        
        
    	var termSeriesStore = Ext.create('Ext.data.JsonStore', {
    		fields: ['term', 'x', 'y', 'z', 'rawFreq', 'relativeFreq', 'cluster', 'category', 'docIndex', 'disabled'],
    		data: termData
    	});
    	var docSeriesStore = Ext.create('Ext.data.JsonStore', {
    		fields: ['term', 'x', 'y', 'z', 'rawFreq', 'relativeFreq', 'cluster', 'category', 'docIndex', 'disabled'],
    		data: docData
    	});
    	
    	var config = {
        	itemId: 'chart',
        	xtype: 'cartesian',
        	interactions: ['crosszoom','panzoom','itemhighlight'],
        	plugins: {
                ptype: 'chartitemevents'
            },
        	axes: [{
        		type: 'numeric',
        		position: 'bottom',
        		fields: ['x'],
        		label: {
                    rotate:{degrees:-30}
            	}
        	},{
        		type: 'numeric',
        		position: 'left',
        		fields: ['y']
        	}],
        	sprites: [{
        		type: 'text',
        		text: summary,
        		x: 70,
        		y: 70
        	}],
        	innerPadding: {top: 25, right: 25, bottom: 25, left: 25},
        	series: [{
        		type: 'customScatter',
        		xField: 'x',
        		yField: 'y',
        		store: termSeriesStore,
        		label: {
        			font: '14px Helvetica',
        			field: 'term',
        			display: 'over'
        		},
        		tooltip: {
        			trackMouse: true,
        			style: 'background: #fff',
        			renderer: function (toolTip, record, ctx) {
        				toolTip.setHtml(that.tokenFreqTipTemplate.apply([record.get('term'),record.get('rawFreq'),record.get('relativeFreq')]));
        			}
        		},
        		marker: {
        		    type: 'circle'
        		},
        		highlight: {
        			fillStyle: 'yellow',
                    strokeStyle: 'black'
        		},
        		renderer: function (sprite, config, rendererData, index) {
    				var store = rendererData.store;
    				var item = store.getAt(index);
    				if (item !== null) {
	    				var clusterIndex = item.get('cluster');
	    				var scatterplot = that;
	    				
	    				if (clusterIndex === -1) {
	    					// no clusters were specified in initial call
	    					clusterIndex = 0;
	    				}
	    				
	    				var fillAlpha = 0.65;
	    				var strokeAlpha = 1;
	    				if (item.get('disabled') === true) {
	    					fillAlpha = 0.1;
	    					strokeAlpha = 0.1;
	    				} else if (numDims === 3 && item.get('z')) {
	    					fillAlpha = scatterplot.interpolate(item.get('z'), minFill, maxFill, 0, 1);
	    				}
	    				var color = scatterplot.getApplication().getColor(clusterIndex);
	    				config.fillStyle = 'rgba('+color.join(',')+','+fillAlpha+')';
	    				config.strokeStyle = 'rgba('+color.join(',')+','+strokeAlpha+')';
	    				
	    				var freq = item.get('rawFreq');
	    				var radius = scatterplot.interpolate(freq, minFreq, maxFreq, 2, 20);
	    				config.radius = radius;
    				}
    			},
    			scope: this
        	},{
        		type: 'customScatter',
        		xField: 'x',
        		yField: 'y',
        		store: docSeriesStore,
        		label: {
        			font: '14px Helvetica',
        			field: 'term',
        			display: 'over',
        			color: this.getDefaultDocColor(true)
        		},
        		tooltip: {
        			trackMouse: true,
        			style: 'background: #fff',
        			renderer: function (toolTip, record, ctx) {
        				toolTip.setHtml(that.docFreqTipTemplate.apply([record.get('title'),record.get('rawFreq')]));
        			}
        		},
        		marker: {
        		    type: 'diamond'
        		},
        		highlight: {
        			fillStyle: 'yellow',
                    strokeStyle: 'black'
        		},
        		renderer: function (sprite, config, rendererData, index) {
    				var store = rendererData.store;
    				var item = store.getAt(index);
    				if (item !== null) {
	    				var clusterIndex = item.get('cluster');
	    				var scatterplot = that;
	    				
	    				var color;
	    				if (clusterIndex === -1 || scatterplot.getApiParam('analysis') !== 'docSim') {
	    					color = scatterplot.getDefaultDocColor();
	    				} else {
	    					color = scatterplot.getApplication().getColor(clusterIndex);	
	    				}
	    				
	    				var a = 0.65;
	    				if (numDims === 3 && item.get('z')) {
	    					a = scatterplot.interpolate(item.get('z'), minFill, maxFill, 0, 1);
	    				}
	    				
	    				config.fillStyle = 'rgba('+color.join(',')+','+a+')';
	    				config.strokeStyle = 'rgba('+color.join(',')+',1)';
	    				config.radius = 5;
    				}
    			},
    			scope: this
        		
        		
        	}],
        	listeners: {
        		itemclick: function(chart, item, event) {
        			var data = item.record.data;
        			if (data.category === 'doc') {
        				var record = this.getCorpus().getDocument(data.docIndex);
	            		this.getApplication().dispatchEvent('documentsClicked', this, [record]);
        			} else if (data.category === 'term') {
	        			var record = Ext.create('Voyant.data.model.CorpusTerm', data);
	            		this.getApplication().dispatchEvent('corpusTermsClicked', this, [record]);
        			}
        		},
        		render: function(chart) {
        			chart.body.on('contextmenu', function(event, target) {
	        			event.preventDefault();
	        			
		            	var xy = event.getXY();
		            	var parentXY = Ext.fly(target).getXY();
		            	var x = xy[0] - parentXY[0];
		            	var y = xy[1] - parentXY[1];
		            	var chartItem = this.down('#chart').getItemForPoint(x,y);
		            	if (chartItem != null && chartItem.record.get('category') === 'term') {
		            		var series = this.down('#chart').getSeries();
		            		series[0].disableToolTips();
		            		series[1].disableToolTips();
		            		
		            		var term = chartItem.record.get('term');
		            		
		            		var text = (new Ext.Template(this.localize('removeTerm'))).apply([term]);
		            		this.getChartMenu().queryById('remove').setText(text);
		            		text = (new Ext.Template(this.localize('nearbyTerm'))).apply([term]);
		            		var nearby = this.getChartMenu().queryById('nearby');
		            		nearby.setText(text);
		            		nearby.setDisabled(this.getApiParam('analysis') === 'tsne');
		            		
		            		this.getChartMenu().on('click', function(menu, item) {
		            			if (item !== undefined) {
		            				var term = chartItem.record.get('term');
			            			if (item.getItemId() === 'nearby') {
			            				this.getNearbyForTerm(term);
			            			} else {
			            				this.removeTerm(term);
			            			}
		            			}
		            		}, this, {single: true});
		            		this.getChartMenu().showAt(xy);
		            	}
		            }, this);
        		},
        		scope: this
        	}
        };
    	
    	var chart = Ext.create('Ext.chart.CartesianChart', config);
    	this.queryById('chartParent').insert(0, chart);
    	
    	this.queryById('chartParent').unmask();
    	
    	this.doLabels();
    	
    	if (this.getNewTerm() !== null) {
        	this.selectTerm(this.getNewTerm()[0]);
        	this.setNewTerm(null);
        }
    },
    
    getDefaultDocColor: function(returnHex) {
    	var color = this.getApplication().getColor(6, returnHex);
    	return color;
    },
    
    doLabels: function() {
    	var chart = this.queryById('chart');
    	var series = chart.getSeries();
    	var summary = chart.getSurface('chart').getItems()[0];
    	var labels = this.getApiParam("label");
    	if (labels.indexOf("summary")>-1) {summary.show();}
    	else {summary.hide();}
    	if (labels.indexOf("terms")>-1) {series[0].getLabel().show();}
    	else {series[0].getLabel().hide();}
    	if (labels.indexOf("docs")>-1) {series[1].getLabel().show();}
    	else {series[1].getLabel().hide();}
    },
    
    selectTerm: function(term, isDoc) {
    	var chart = this.down('#chart');
    	if (chart !== null) {
	    	if (term === undefined) {
				chart.getSeries()[0].setHighlightItem(null);
				chart.getSeries()[1].setHighlightItem(null);
	    	} else {
		    	var series, index;
		    	if (isDoc === true) {
		    		series = chart.getSeries()[1];
			    	index = series.getStore().findExact('title', term);
		    	} else {
			    	series = chart.getSeries()[0];
			    	index = series.getStore().findExact('term', term);
		    	}
		    	if (index !== -1) {
		    		var record = series.getStore().getAt(index);
		    		var sprite = series.getSprites()[0];
		    		// constructing series item, like in the chart series source
		    		var item = {
						series: series,
		                category: series.getItemInstancing() ? 'items' : 'markers',
		                index: index,
		                record: record,
		                field: series.getYField(),
		                sprite: sprite
		    		};
		    		series.setHighlightItem(item);
		    		if (isDoc) {
		    			chart.getSeries()[0].setHighlightItem(null);
		    		} else {
		    			chart.getSeries()[1].setHighlightItem(null);
		    		}
		    		
		    		var point = this.getPointFromIndex(series, index);
		    		this.setHighlightData({x: point[0], y: point[1], r: 50});
		    		
		    		if (this.getHighlightTask() == null) {
		    			this.setHighlightTask(Ext.TaskManager.newTask({
		        			run: this.doHighlight,
		        			scope: this,
		        			interval: 25,
		        			repeat: this.getHighlightData().r
		        		}));
		    		}
		    		this.getHighlightTask().restart();
		    	}
	    	}
    	}
    },
    
    getPointFromIndex: function(series, index) {
		var sprite = series.getSprites()[0];
		if (sprite.surfaceMatrix !== null) {
			var matrix = sprite.attr.matrix.clone().prependMatrix(sprite.surfaceMatrix);
			var dataX = sprite.attr.dataX[index];
			var dataY = sprite.attr.dataY[index];
			return matrix.transformPoint([dataX, dataY]);
		} else {
			return [0,0];
		}
    },
    
    doHighlight: function() {
    	var chart = this.down('#chart');
    	if (this.getHighlightData().r > 0) {
	    	var surf = chart.getSurface();
			var highlight = null;
			var items = surf.getItems();
			for (var i = 0; i < items.length; i++) {
				var item = items[i];
				if (item.id == 'customHighlight') {
					highlight = item;
					break;
				}
			}
			if (highlight == null) {
				surf.add({
					id: 'customHighlight',
					type: 'circle',
					strokeStyle: 'red',
					fillStyle: 'none',
					radius: this.getHighlightData().r,
					x: this.getHighlightData().x,
					y: this.getHighlightData().y
				});
			} else {
				highlight.setAttributes({
					x: this.getHighlightData().x,
					y: this.getHighlightData().y,
					radius: this.getHighlightData().r
				});
				this.getHighlightData().r -= 1.5;
				if (this.getHighlightData().r <= 0) {
					this.getHighlightData().r = 0;
					surf.remove(highlight, true);
				}
			}
			chart.redraw();
    	}
    },
    
    filterChart: function(query) {
    	if (Ext.isString(query)) query = [query];
    	var reQueries = [];
    	for (var i = 0; i < query.length; i++) {
    		var re = new RegExp(query[i]);
    		reQueries.push(re);
    	}
    	
    	// filter terms
    	var chart = this.queryById('chart');
    	var series0 = chart.getSeries()[0];
    	var label0 = series0.getLabel();
    	series0.getStore().each(function(item) {
    		var match = false;
    		if (reQueries.length == 0) match = true;
    		else {
	    		for (var i = 0; i < reQueries.length; i++) {
	    			match = match || reQueries[i].test(item.get('term'));
	    			if (match) break;
	    		}
    		}
    		item.set('disabled', !match);
    		var index = item.store.indexOf(item);
    		label0.setAttributesFor(index, {hidden: !match});
    	}, this);

		chart.redraw();
    },
    
    getCurrentTerms: function() {
    	var terms = [];
    	this.getTermStore().each(function(r) {
    		if (r.get('category') === 'term') {
    			terms.push(r.get('term'));
    		}
    	});
    	return terms;
    },
    
    getNearbyForTerm: function(term) {
    	var limit = Math.max(2000, Math.round(this.getCorpus().getWordTokensCount() / 100));
		this.setApiParams({limit: limit, target: term});
		this.loadFromApis();
		this.setApiParam('target', undefined);
    },
    
    removeTerm: function(term) {
    	var series = this.down('#chart').getSeries()[0];
    	var index = series.getStore().findExact('term', term);
    	series.getStore().removeAt(index);
    	
    	index = this.getTermStore().findExact('term', term);
    	this.getTermStore().removeAt(index);
    	
    	var newCount = this.getTermStore().getCount();
        this.queryById('limit').setRawValue(newCount);
    },
    
    loadFromApis: function(keepCurrentTerms) {
    	this.queryById('chartParent').mask(this.localize('analyzing'));
    	
    	var params = {};
    	var terms = this.getCurrentTerms();
    	if (this.getNewTerm() !== null) {
    		terms = terms.concat(this.getNewTerm());
    		this.setApiParam('limit', terms.length);
    	}
    	if (terms.length > 0) {
    		if (this.getNewTerm() !== null || keepCurrentTerms) {
    			params.query = terms.join(',');
    		}
//    		params.term = terms;
    	}
    	Ext.apply(params, this.getApiParams());
    	if (params.target != null) {
    		params.term = terms;
    	}
    	if (params.analysis === 'pca') {
    		this.getPcaStore().load({
	    		params: params
	    	});
    	} else if (params.analysis === 'tsne'){
    		this.getTsneStore().load({
	    		params: params
	    	});
    	} else if (params.analysis === 'docSim'){
    		this.getDocSimStore().load({
	    		params: params
	    	});
    	} else {
    		this.getCaStore().load({
	    		params: params
	    	});
    	}
    },
    
    interpolate: function(lambda, minSrc, maxSrc, minDst, maxDst) {
        return minDst + (maxDst - minDst) * Math.max(0, Math.min(1, (lambda - minSrc) / (maxSrc - minSrc)));
    }
});

/*
 * Adds tool tip disabling.
 */
Ext.define('Ext.chart.series.CustomScatter', {
	extend: 'Ext.chart.series.Scatter',
	
	alias: 'series.customScatter',
    type: 'customScatter',
    seriesType: 'scatterSeries',
	
	tipsDisabled: false,
	
	enableToolTips: function() {
		this.tipsDisabled = false;
	},
	
	disableToolTips: function() {
		this.tipsDisabled = true;
	},
	
    showTip: function (item, xy) {
    	if (this.tipsDisabled) {
    		return;
    	}
    	
    	this.callParent(arguments);
    }
});
Ext.define('Voyant.panel.StreamGraph', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.streamgraph',
    statics: {
    	i18n: {
    	},
    	api: {
    		limit: 5,
    		stopList: 'auto',
    		query: undefined,
    		withDistributions: 'relative',
    		bins: 50,
    		docIndex: undefined,
    		docId: undefined
    	},
		glyph: 'xf1fe@FontAwesome'
    },
    
    config: {
    	visLayout: undefined,
    	vis: undefined,
    	mode: 'corpus',
    	
    	layerData: undefined,
    	
    	graphId: undefined,
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}]
    },
    
    graphMargin: {top: 20, right: 60, bottom: 110, left: 80},
    
    MODE_CORPUS: 'corpus',
    MODE_DOCUMENT: 'document',
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.setGraphId(Ext.id(null, 'streamgraph_'));
    },
    
    initComponent: function() {
        var me = this;
        
        Ext.apply(me, {
    		title: this.localize('title'),
    		tbar: new Ext.Toolbar({
                overflowHandler: 'scroller',
				items: ['->',{
					xtype: 'legend',
					store: new Ext.data.JsonStore({
						fields: ['name', 'mark', 'active']
					}),
					listeners: {
						itemclick: function(view, record, el, index) {
							var isActive = Ext.fly(el.firstElementChild).hasCls('x-legend-inactive');
							record.set('active', isActive);
							var terms = this.getCurrentTerms();
							this.setApiParams({query: terms, limit: terms.length, stopList: undefined, categories: this.getApiParam("categories")});
							this.loadFromCorpus();
						},
						scope: this
					}
				},'->']
			}),
			bbar: {
                overflowHandler: 'scroller',
				items: [{
                	xtype: 'querysearchfield'
                },{
	            	xtype: 'button',
	            	text: this.localize('clearTerms'),
	            	handler: function() {
	            		this.setApiParams({query: undefined});
	            		this.loadFromRecords([]);
	            	},
	            	scope: this
	            },{
	            	xtype: 'corpusdocumentselector',
	            	singleSelect: true
	            },{
	            	text: this.localize('freqsMode'),
					glyph: 'xf201@FontAwesome',
				    tooltip: this.localize('freqsModeTip'),
				    menu: {
				    	items: [{
				               text: this.localize('relativeFrequencies'),
				               checked: true,
				               itemId: 'relative',
				               group: 'freqsMode',
				               checkHandler: function(item, checked) {
				            	   if (checked) {
				                	   this.setApiParam('withDistributions', 'relative');
				                	   this.loadFromCorpus();
				            	   }
				               },
				               scope: this
				           }, {
				               text: this.localize('rawFrequencies'),
				               checked: false,
				               itemId: 'raw',
				               group: 'freqsMode',
				               checkHandler: function(item, checked) {
				            	   if (checked) {
				                	   this.setApiParam('withDistributions', 'raw');
				                	   this.loadFromCorpus();
				            	   }
				               },
				               scope: this
			           }]
				    }
	            },{
	            	xtype: 'slider',
	            	itemId: 'segmentsSlider',
	            	fieldLabel: this.localize('segments'),
	            	labelAlign: 'right',
	            	labelWidth: 70,
	            	width: 150,
	            	increment: 10,
	            	minValue: 10,
	            	maxValue: 300,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam('bins'));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({bins: newvalue});
	            			this.loadFromCorpus();
	            		},
	            		scope: this
	            	}
	            }]
			}
        });
        
        this.on('loadedCorpus', function(src, corpus) {
        	if (this.getCorpus().getDocumentsCount() == 1 && this.getMode() != this.MODE_DOCUMENT) {
				this.setMode(this.MODE_DOCUMENT);
			}
			if (!('bins' in this.getModifiedApiParams())) {
				if (this.getMode() == this.MODE_CORPUS) {
					var count = corpus.getDocumentsCount();
					var binsMax = 100;
					this.setApiParam('bins', count > binsMax ? binsMax : count);
				}
			}
    		if (this.isVisible()) {
    			this.loadFromCorpus();
    		}
        }, this);
        
        this.on('corpusSelected', function(src, corpus) {
    		if (src.isXType('corpusdocumentselector')) {
    			this.setMode(this.MODE_CORPUS);
    			this.setApiParams({docId: undefined, docIndex: undefined});
    			this.setCorpus(corpus);
        		this.loadFromCorpus();
    		}
    	});
        
        this.on('documentSelected', function(src, doc) {
        	var docId = doc.getId();
        	this.setApiParam('docId', docId);
        	this.loadFromDocumentTerms();
        }, this);
        
		this.on('query', function(src, query) {
        	var terms = this.getCurrentTerms();
        	terms.push(query);
        	this.setApiParams({query: terms, limit: terms.length, stopList: undefined});
        	if (this.getMode() === this.MODE_DOCUMENT) {
        		this.loadFromDocumentTerms();
        	} else {
        		this.loadFromCorpusTerms(this.getCorpus().getCorpusTerms());
        	}
        }, this);
		
        this.on('resize', this.resizeGraph, this);
        
        this.on('boxready', this.initGraph, this);
        
        me.callParent(arguments);
    },
    
    loadFromCorpus: function() {
    	var corpus = this.getCorpus();
		if (this.getApiParam('docId') || this.getApiParam('docIndex')) {
			this.loadFromDocumentTerms();
		} else if (corpus.getDocumentsCount() == 1) {
			this.loadFromDocument(corpus.getDocument(0));
		} else {
			this.loadFromCorpusTerms(corpus.getCorpusTerms());
		}
	},

    loadFromCorpusTerms: function(corpusTerms) {
    	var params = this.getApiParams(['limit','stopList','query','withDistributions','bins','categories']);
		// ensure that we're not beyond the number of documents
		if (params.bins && params.bins > this.getCorpus().getDocumentsCount()) {
			params.bins = this.getCorpus().getDocumentsCount();
		}
		corpusTerms.load({
		    callback: function(records, operation, success) {
		    	if (success) {
		    		this.setMode(this.MODE_CORPUS);
			    	this.loadFromRecords(records);
		    	} else {
					Voyant.application.showResponseError(this.localize('failedGetCorpusTerms'), operation);
		    	}
		    },
		    scope: this,
		    params: params
    	});
    },
    
    loadFromDocument: function(document) {
    	if (document.then) {
    		var me = this;
    		document.then(function(document) {me.loadFromDocument(document);});
    	} else {
    		var ids = [];
    		if (Ext.getClassName(document)=="Voyant.data.model.Document") {
        		this.setApiParams({
        			docIndex: undefined,
        			query: undefined,
        			docId: document.getId()
        		});
        		if (this.isVisible()) {
                	this.loadFromDocumentTerms();
        		}
    		}
    	}
    },
    
    loadFromDocumentTerms: function(documentTerms) {
    	if (this.getCorpus()) {
        	documentTerms = documentTerms || this.getCorpus().getDocumentTerms({autoLoad: false});
    		documentTerms.load({
    		    callback: function(records, operation, success) {
    		    	if (success) {
    		    		this.setMode(this.MODE_DOCUMENT);
    		    		this.loadFromRecords(records);
    		    	}
    		    	else {
    					Voyant.application.showResponseError(this.localize('failedGetDocumentTerms'), operation);
    		    	}
    		    },
    		    scope: this,
    		    params: this.getApiParams(['docId','docIndex','limit','stopList','query','withDistributions','bins','categories'])
        	});
    	}
    },
    
    loadFromRecords: function(records) {
    	var legendData = [];
    	var layers = [];
    	records.forEach(function(record, index) {
    		var key = record.getTerm();
    		var values = record.get('distributions');
    		for (var i = 0; i < values.length; i++) {
    			if (layers[i] === undefined) {
    				layers[i] = {};
    			}
    			layers[i][key] = values[i];
    		}
    		legendData.push({id: key, name: key, mark: this.getApplication().getColorForTerm(key, true), active: true});
    	}, this);
    	
    	this.setLayerData(layers);
    	
    	this.down('[xtype=legend]').getStore().loadData(legendData);

    	this.doLayout();
    },
    
    doLayout: function(layers) {
    	var layers = this.getLayerData();
    	if (layers !== undefined) {
    		var me = this;
    		
	    	var keys = [];
	    	this.down('[xtype=legend]').getStore().each(function(r) { keys.push(r.getId()); });
	    	
	    	var steps;
	    	if (this.getMode() === this.MODE_DOCUMENT) {
	    		steps = this.getApiParam('bins');
	    	} else {
	    		var bins = this.getApiParam('bins');
	    		var docsCount = this.getCorpus().getDocumentsCount();
	    		
	    		steps = bins < docsCount ? bins : docsCount;
	    	}
	    	
	    	this.getVisLayout().keys(keys);
	    	var processedLayers = this.getVisLayout()(layers);
	    	
	    	var width = this.body.down('svg').getWidth() - this.graphMargin.left - this.graphMargin.right;
	    	var x = d3.scaleLinear().domain([0, steps-1]).range([0, width]);
	    	
	    	var min = d3.min(processedLayers, function(layer) {
	    		return d3.min(layer, function(d) { return d[0]; });
	    	});
	    	var max = d3.max(processedLayers, function(layer) {
	    		return d3.max(layer, function(d) { return d[1]; });
	    	});
	    	
	    	var height = this.body.down('svg').getHeight() - this.graphMargin.top - this.graphMargin.bottom;
	    	var y = d3.scaleLinear().domain([min, max]).range([height, 0]);
	    	
	    	var area = d3.area()
		    	.x(function(d, i) { return x(i); })
			    .y0(function(d) { return y(d[0]); })
			    .y1(function(d) { return y(d[1]); })
			    .curve(d3.curveCatmullRom);
	    	
	    	var xAxis;
	    	if (this.getMode() === this.MODE_CORPUS) {
	    		var xAxisDomain = [];
	    		this.getCorpus().getDocuments().each(function(doc) {
	    			xAxisDomain.push(doc.getTinyLabel());
	    		});
	    		var xAxisScale = d3.scalePoint().domain(xAxisDomain).range([0, width]);    		
	    		xAxis = d3.axisBottom(xAxisScale);
	    	} else {
	    		xAxis = d3.axisBottom(x);
	    	}
	    	
	    	var yAxis = d3.axisLeft(y);
	    	
	    	var paths = this.getVis().selectAll('path').data(processedLayers, function(d) { return d; });
	    	
	    	paths
	    		.attr('d', function(d) { return area(d); })
		    	.style('fill', function(d) { return me.getApplication().getColorForTerm(d.key, true); })
				.select('title').text(function (d) { return d.key; });
	    	
	    	paths.enter().append('path')
				.attr('d', function(d) { return area(d); })
				.style('fill', function(d) { return me.getApplication().getColorForTerm(d.key, true); })
				.append('title').text(function (d) { return d.key; });
	    	
	    	paths.exit().remove();
	    	
	    	this.getVis().selectAll('g.axis').remove();
	    	
	    	this.getVis().append('g')
	    		.attr('class', 'axis x')
	    		.attr('transform', 'translate(0,'+height+')')
	    		.call(xAxis);
	    	
	    	var xAxisText;
	    	if (this.getMode() === this.MODE_CORPUS) {
	    		this.getVis().select('g.axis.x').selectAll('text').each(function() {
					d3.select(this)
						.attr('text-anchor', 'end')
						.attr('transform', 'rotate(-45)');
	    		});
	    		
	    		xAxisText = this.localize('documents');
	    	} else {
	    		xAxisText = this.localize('documentSegments');
	    	}
	    	this.getVis().select('g.axis.x').append("text")
				.attr('text-anchor', 'middle')
				.attr('transform', 'translate('+width/2+', '+(this.graphMargin.bottom-30)+')')
				.attr('fill', '#000')
				.text(xAxisText);
	    	
	    	this.getVis().append('g')
				.attr('class', 'axis y')
				.attr('transform', 'translate(0,0)')
				.call(yAxis);
	    	
	    	var yAxisText;
	    	if (this.getApiParam('withDistributions') === 'raw') {
	    		yAxisText = this.localize('rawFrequencies');
	    	} else {
	    		yAxisText = this.localize('relativeFrequencies');
	    	}
	    	this.getVis().select('g.axis.y').append("text")
				.attr('text-anchor', 'middle')
				.attr('transform', 'translate(-'+(this.graphMargin.left-20)+', '+height/2+') rotate(-90)')
				.attr('fill', '#000')
				.text(yAxisText);
    	}
    },
    
	getCurrentTerms: function() {
    	var terms = [];
    	this.down('[xtype=legend]').getStore().each(function(record) {
    		if (record.get('active')) {
    			terms.push(record.get('name'));
    		}
    	}, this);
    	return terms;
    },
	
    initGraph: function() {
    	if (this.getVisLayout() === undefined) {
	    	var el = this.getLayout().getRenderTarget();
	    	
	    	this.setVisLayout(d3.stack().offset(d3.stackOffsetWiggle).order(d3.stackOrderInsideOut));
			this.setVis(d3.select(el.dom).append('svg').attr('id',this.getGraphId()).append('g').attr('transform', 'translate('+this.graphMargin.left+','+this.graphMargin.top+')'));
			
			this.resizeGraph();
    	}
    },
    
    resizeGraph: function() {
    	var el = this.body;//getLayout().getRenderTarget();
    	var width = el.getWidth();
		var height = el.getHeight();
		
		d3.select(el.dom).select('svg').attr('width', width).attr('height', height);
		
		this.doLayout();
    }
});


/**
 * The Summary panel provides an overview of a corpus, and the content will
 * depend on whether the corpus includes one document or many.
 */
Ext.define('Voyant.panel.Summary', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.summary',
    statics: {
    	i18n: {
			readabilityIndex: 'Readability Index:',
			docsDensityTip: 'ratio of unique words in this document',
			avgWordsPerSentenceTip: 'average words per sentence in this document',
			readabilityTip: 'the Coleman-Liau readability index for this document'
    	},
    	api: {
    		
    		/**
    		 * @cfg {String} stopList A list of words to exclude.
    		 * 
    		 * Stopword lists can take one of several forms and they can be combined with commas:
    		 * 
    		 * * *auto*: automatically detect the language (this is recommended and the default so it doesn't need to be specified)
    		 * * specially named stopword lists including stop.ar.arabic-lucene.txt, stop.bg.bulgarian-lucene.txt, stop.br.breton-lucene.txt, stop.ca.catalan-lucene.txt, stop.ckb.kurdish-lucene.txt, stop.cn.chinese-lawrence.txt, stop.cz.czech-lucene.txt, stop.de.citelab.txt, stop.de.german.txt, stop.el.greek-lucene.txt, stop.en.glasgow.txt, stop.en.smart.txt, stop.en.taporware.txt, stop.es.spanish.txt, stop.eu.basque-luence.txt, stop.fa.farsi-lucene.txt, stop.fr.steffens.txt, stop.fr.veronis.txt, stop.ga.ga-irish.txt, stop.gl.galician-lucene.txt, stop.hi.hindi-lucene.txt, stop.hu.hungarian.txt, stop.hy.armenian-lucene.txt, stop.id.indonesian-lucene.txt, stop.it.italian.txt, stop.ja.japanese.txt, stop.lt.lithuanian-lucene.txt, stop.lv.latvian-lucene.txt, stop.mu.multi.txt, stop.nl.dutch.txt, stop.no.norwegian.txt, stop.ro.romanian-lucene.txt, stop.se.swedish-long.txt, stop.se.swedish-short.txt, stop.th.thai-lucene.txt, stop.tr.turkish-lucene.txt
    		 * * individual words to be excluded
    		 * * URLs that point to plain text UTF-8 files with one stopword per line (lines with leading hash symbols (#) are skipped)
    		 */
    		stopList: 'auto',
    		
    		
    		start: 0,
    		
    		
    		/**
    		 * @cfg {Number} limit The number of items to include in most lists (document length, vocabulary density, most frequent terms).
    		 */
    		limit: 5,
    		
    		/**
    		 * @cfg {Number} numberOfDocumentsForDistinctiveWords The number of items to include in the list of distinctive words (similar to the limit parameter but specific to distinctive words).
    		 */
    		numberOfDocumentsForDistinctiveWords: 10
    	},
		glyph: 'xf1ea@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}]
    },
    autoScroll: true,
    cls: 'corpus-summary',
    
    constructor: function(config ) {

    	Ext.apply(this, {
    		title: this.localize('title'),
    		items: {
    			itemId: 'main',
    			cls: 'main',
    			margin: 10
    		},
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			fieldLabel: this.localize('items'),
        			labelWidth: 40,
        			width: 120,
        			xtype: 'slider',
	            	increment: 5,
	            	minValue: 5,
	            	maxValue: 59,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam("limit"))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.loadSummary();
	            		},
	            		scope: this
	            	}
                }]
    		}]
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on("afterrender", function() {
        	this.body.addListener('click', function(e) {
    			var target = e.getTarget(null, null, true);
    			if (target && target.dom.tagName == 'A') {
    				if (target.hasCls('document-id')) {
    					var docId = target.getAttribute('val', 'voyant');
    					var doc = this.getCorpus().getDocuments().getById(docId);
    					this.dispatchEvent('documentsClicked', this, [doc]);
    				} else if (target.hasCls('corpus-type')) {
    					this.dispatchEvent('termsClicked', this, [target.getHtml()]);
    				} else if (target.hasCls('document-type')) {
    					this.dispatchEvent('documentIndexTermsClicked', this, [{
    						term: target.getHtml(),
    						docIndex: target.getAttribute("docIndex", 'voyant')
    					}]);
    				}
    			}
    		}, this);
    	})
    	
        // create a listener for corpus loading (defined here, in case we need to load it next)
    	this.on('loadedCorpus', function(src, corpus) {
    		if (this.rendered) {
    			this.loadSummary();
    		}
    		else {
    			this.on("afterrender", function() {
    				this.loadSummary();
    			}, this)
    		}

    	});
    	
    	// if we have a corpus, load it
    	if (config && config.corpus) {
    		this.fireEvent('loadedCorpus', this, config.corpus);
    	}
    	
    	this.on("resize", function() {
    		var available = this.getWidth()-200;
    		this.query("sparklineline").forEach(function(spark) {
    			if (spark.getWidth()>available) {
    				spark.setWidth(available);
    			}
    		})
    	}, this)
    },
    
    loadSummary: function() {
    	
    	var me = this;
    	
    	var main = this.queryById('main');
    	
    	main.removeAll();
    	main.add({
			cls: 'section',
    		html: this.getCorpus().getString()
    	});
    	
    	var docs = this.getCorpus().getDocuments().getRange();
    	var limit = this.getApiParam('limit');
    	
    	if (docs.length>1) {
    		
        	var docsLengthTpl = new Ext.XTemplate('<tpl for="." between="; "><a href="#" onclick="return false" class="document-id" voyant:val="{id}" data-qtip="{title}">{shortTitle}</a><span style="font-size: smaller"> (<span class="info-tip" data-qtip="{valTip}">{val}</span>)</span></a></tpl>')

        	var sparkWidth;
        	if (docs.length<25) {sparkWidth=docs.length*4;}
        	else if (docs.length<50) {sparkWidth=docs.length*2;}
        	else if (docs.length>100) {
        		var available  = main.getWidth()-200;
        		sparkWidth = available < docs.length ? docs.length : available;
        	}
        	
        	var numberOfTerms = this.localize('numberOfTerms');

			// document length
			docs.sort(function(d1, d2) {return d2.getLexicalTokensCount()-d1.getLexicalTokensCount()});
			main.add(this.showSparklineSection(
				function(doc) { return doc.getLexicalTokensCount(); },
				this.localize('docsLength'), this.localize('longest'), this.localize('shortest'),
				docs, limit, docsLengthTpl, sparkWidth, this.localize('numberOfTerms')
			));
        	
			// vocabulary density
    		docs.sort(function(d1, d2) {return d2.getLexicalTypeTokenRatio()-d1.getLexicalTypeTokenRatio()});
			main.add(this.showSparklineSection(
				function(doc) { return Ext.util.Format.number(doc.getLexicalTypeTokenRatio(),'0.000'); },
				this.localize('docsDensity'), this.localize('highest'), this.localize('lowest'),
				docs, limit, docsLengthTpl, sparkWidth, this.localize('docsDensityTip')
			));
 
        	// words per sentence
    		docs.sort(function(d1, d2) {return d2.getAverageWordsPerSentence()-d1.getAverageWordsPerSentence()});
			main.add(this.showSparklineSection(
				function(doc) { return Ext.util.Format.number(doc.getAverageWordsPerSentence(),'0.0'); },
				this.localize('averageWordsPerSentence'), this.localize('highest'), this.localize('lowest'),
				docs, limit, docsLengthTpl, sparkWidth, this.localize('avgWordsPerSentenceTip')
			));

    	} else { // single document, we can still show word density and average words per sentence
    		var doc = docs[0];
    		if (doc) {
            	main.add({
            		cls: 'section',
            		html:"<b>"+this.localize("docsDensity")+"</b> "+Ext.util.Format.number(doc.getLexicalTypeTokenRatio(),'0.000')
            	});    		
            	main.add({
            		cls: 'section',
            		html: "<b>"+this.localize("averageWordsPerSentence")+"</b> "+Ext.util.Format.number(doc.getAverageWordsPerSentence(),'0.0')
            	});    		
    		}
    	}

		// readability
		this.getCorpus().getReadability().then(function(data) {
			docs.forEach(function(doc) {
				var readDoc = data.find(function(dataDoc) {
					return dataDoc.docId === doc.getId();
				});
				if (readDoc) {
					doc.set('readability', readDoc.readability);
				}
			});

			var sectionIndex = main.items.length-2;
			if (docs.length>1) {
				docs.sort(function(d1, d2) {return d2.get('readability')-d1.get('readability')});
				main.insert(sectionIndex, me.showSparklineSection(function(doc) {
					return Ext.util.Format.number(doc.get('readability'),'0.000');
				}, me.localize('readabilityIndex'), me.localize('highest'), me.localize('lowest'), docs, limit, docsLengthTpl, sparkWidth, me.localize('readabilityTip')));
			} else {
				main.insert(sectionIndex, {
					cls: 'section',
					html: '<b>'+me.localize('readabilityIndex')+'</b> '+ Ext.util.Format.number(docs[0].get('readability'),'0.000')
				});
			}
		})
		
    	
    	main.add({
    		cls: 'section',
			items: [{
				html: this.localize("mostFrequentWords"),
				cls: 'header'
			},{
				cls: 'contents',
				html: '<ul><li></li></ul>'
			}],
    		listeners: {
    			afterrender: function(container) {
    				container.mask(me.localize("loading"));
    				me.getCorpus().getCorpusTerms().load({
    					params: {
    						limit: me.getApiParam('limit'),
    						stopList: me.getApiParam('stopList'),
    						forTool: 'summary'
    					},
    					callback: function(records, operation, success) {
    						if (success && records && records.length>0) {
    							container.unmask();
								var contentsEl = container.down('panel[cls~=contents]').getTargetEl().selectNode('li');
    							Ext.dom.Helper.append(contentsEl,
			   	        			 new Ext.XTemplate('<tpl for="." between="; "><a href="#" onclick="return false" class="corpus-type keyword" voyant:recordId="{id}">{term}</a><span style="font-size: smaller"> ({val})</span></tpl>')
			   	        		 		.apply(records.map(function(term) {
			   	        		 			return {
				   	        		 			id: term.getId(),
				   	        		 			term: term.getTerm(),
				   	        		 			val: term.getRawFreq()
			   	        		 			}
		   	        		 		}))
		   	        		 	)
    						}
    					}
    				})
    			}
    		}
    	})
    	
    	if (docs.length>1) {
        	main.add({
        		cls: 'section',
				items: [{
					html: this.localize("distinctiveWords"),
					cls: 'header'
				},{
					cls: 'contents',
					html: '<ol></ol>'
				}],
        		itemId: 'distinctiveWords',
        		listeners: {
        			afterrender: function(container) {
        				me.showMoreDistinctiveWords();
        			}
        		},
        		scope: this
        	})
    	}
    	
    },

	showSparklineSection: function(docDataFunc, headerText, topText, bottomText, docs, limit, docsLengthTpl, sparkWidth, valueTip) {
		var me = this;
		return {
			cls: 'section',
			items: [{
				layout: 'hbox',
				align: 'bottom',
				items: [{
					html: headerText,
					cls: 'header'
				}, {
					xtype: 'sparklineline',
					values: this.getCorpus().getDocuments().getRange().map(function(doc) {return docDataFunc.call(me, doc)}),
					tipTpl: new Ext.XTemplate('{[this.getDocumentTitle(values.x,values.y)]}', {
						getDocumentTitle: function(docIndex, len) {
							return '('+len+') '+this.panel.getCorpus().getDocument(docIndex).getTitle()
						},
						panel: me 
					}),
					height: 16,
					width: sparkWidth
				}]
			},{
				cls: 'contents',
				html: '<ul><li>'+topText+" "+docsLengthTpl.apply(docs.slice(0, docs.length>limit ? limit : parseInt(docs.length/2)).map(function(doc) {return {
					id: doc.getId(),
					shortTitle: doc.getShortTitle(),
					title: doc.getTitle(),
					val: docDataFunc.call(me, doc),
					valTip: valueTip
				}}))+'</li>'+
					'<li>'+bottomText+" "+docsLengthTpl.apply(docs.slice(-(docs.length>limit ? limit : parseInt(docs.length/2))).reverse().map(function(doc) {return {
						id: doc.getId(),
						shortTitle: doc.getShortTitle(),
						title: doc.getTitle(),
						val: docDataFunc.call(me, doc),
						valTip: valueTip
					}}))+'</li>'
			}]
		}
	},
     
    showMoreDistinctiveWords: function() {
    	var distinctiveWordsContainer = this.queryById('distinctiveWords');
    	var list = distinctiveWordsContainer.getTargetEl().selectNode("ol");
    	var count = Ext.dom.Query.select("li:not(.more)", list).length;
    	var numberOfDocumentsForDistinctiveWords = parseInt(this.getApiParam('numberOfDocumentsForDistinctiveWords'));
    	var range = this.getCorpus().getDocuments().getRange(count, count+numberOfDocumentsForDistinctiveWords-1);
    	if (range && Ext.isArray(range)) {
    		var docIndex = [];
    		range.forEach(function(doc) {
    			docIndex.push(doc.getIndex())
    		})
    		if (docIndex.length>0) {
    			this.getCorpus().getDocumentTerms().load({
    				addRecords: true,
    				params: {
    					docIndex: docIndex,
    					perDocLimit: parseInt(this.getApiParam("limit")),
    					limit: numberOfDocumentsForDistinctiveWords*parseInt(this.getApiParam("limit")),
						stopList: this.getApiParam('stopList'),
    					sort: 'TFIDF',
    					dir: 'DESC',
    					forTool: 'summary'
    				},
    				scope: this,
    				callback: function(records, operation, success) {
    					var docs = {};
    					if (success && records && Ext.isArray(records)) { // TODO: why wouldn't we have records here?
    						records.forEach(function(r, index, array) {
    							var i = r.getDocIndex();
    							if (!(i in docs)) {docs[i]=[]};
    							docs[i].push({
    								id: r.getId(),
    								docIndex: r.getDocIndex(),
    								type: r.getTerm(),
    								val: Ext.util.Format.number(r.get('rawFreq'),'0,000'),
    								docId: r.get('docId')
    							});

    						});
    						var len;
    						docIndex.forEach(function(index) {
    							if (docs[index]) {
        							var doc = this.getCorpus().getDocument(index);
        							len = docs[index].length; // declare for template
        		    				Ext.dom.Helper.append(list, {tag: 'li', 'voyant:index': String(index), html: 
        		    					'<a href="#" onclick="return false" class="document-id document-id-distinctive" voyant:val="'+doc.get('id')+'">'+doc.getShortTitle()+'</a>'+
        		    					this.localize('colon')+ " "+new Ext.XTemplate(this.localize('documentType')).apply({types: docs[index]})+'.'
        		    				});
    							}
    						}, this);
    						distinctiveWordsContainer.updateLayout()
    						len = numberOfDocumentsForDistinctiveWords;
    						remaining = this.getCorpus().getDocuments().getTotalCount() - count - docIndex.length;
    						if (remaining>0) {
        	    				var tpl = new Ext.Template(this.localize('moreDistinctiveWords'));
        						var more = Ext.dom.Helper.append(list, {tag: 'li', cls: 'more', html: tpl.apply([len>remaining ? remaining : len,remaining])}, true);
        						more.on("click", function() {
        							more.remove();
        							this.showMoreDistinctiveWords();
        						}, this)
    						}
    					}
    				}
    			});
    		}
    	}
    },

	// override because the doc sparklines are mostly useless as exports
	getExportVisualization: function() {
		return false;
	},

	getExtraDataExportItems: function() {
		return [{
			name: 'export',
			inputValue: 'dataAsTsv',
			boxLabel: this.localize('exportGridCurrentTsv')
		}];
	},

	exportDataAsTsv: function(panel, form) {
		var value = '';
		var sections = panel.query('panel[cls~=section]');
		sections.forEach(function(sp) {
			var sectionData = '';
			var header = sp.down('panel[cls~=header]');
			var contents = sp.down('panel[cls~=contents]');
			if (header) {
				sectionData += header.getEl().dom.textContent + "\n";
				if (contents) {
					contents.getEl().select('li').elements.forEach(function(li) {
						sectionData += li.textContent.replace(/:/, ":\t").replace(/\)[,;]/g, ")\t") + "\n";
					});
				}
			} else {
				sectionData = sp.getEl().dom.textContent + "\n";
			}
			value += sectionData + "\n";
		});
		Ext.Msg.show({
			title: panel.localize('exportDataTitle'),
			message: panel.localize('exportDataTsvMessage'),
			buttons: Ext.Msg.OK,
			icon: Ext.Msg.INFO,
			prompt: true,
			multiline: true,
			value: value
		});
	}
});

Ext.define('Voyant.panel.TextualArc', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.textualarc',
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @property stopList The stop list to use to filter results.
    		 * Choose from a pre-defined list, or enter a comma separated list of words, or enter an URL to a list of stop words in plain text (one per line).
    		 * @type String
    		 * @private
    		 */
    		stopList: 'auto',
    		
    		docIndex: 0,
    		
    		speed: 50,
    		
    		minRawFreq: 2
    			
    	},
    	glyph: 'xf06e@FontAwesome'
	},
	config: {
    	options: [{xtype: 'stoplistoption'},{
    		xtype: 'container',
    		items: {
    			xtype: 'numberfield',
	    		name: 'minRawFreq',
	    		minValue: 1,
	    		maxValue: 10,
	    		value: 2,
	    		labelWidth: 150,
	    		labelAlign: 'right',
	    		initComponent: function() {
	    			var panel = this.up('window').panel;
	    			this.fieldLabel = panel.localize(this.fieldLabel);
	    			this.on("afterrender", function(cmp) {
			        	Ext.tip.QuickTipManager.register({
			                 target: cmp.getEl(),
			                 text: panel.localize('minRawFreqTip')
			             });
	    			});
	    			this.on('beforedestroy', function(cmp) {
                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
                	});
	    			this.callParent(arguments);
	    		},
	    		fieldLabel: 'minRawFreq'
    		}
    	}],
    	perim: [],
    	diam: undefined
	},
	
	tokensFetch: 500,
	
    constructor: function() {

    	this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);
    	this.config.options[1].fieldLabel = this.localize(this.config.options[1].fieldLabel);
    	Ext.apply(this, {
    		title: this.localize('title'),
			html: '<canvas width="800" height="600"></canvas>',
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'combo',
                	itemId: 'search',
                	queryMode: 'local',
                	displayField: 'term',
                	valueField: 'term',
                	width: 90,
                	emptyText: this.localize('search'),
                	forceSelection: true,
                	disabled: true
                },{
	            	xtype: 'documentselectorbutton',
	            	singleSelect: true
	            },{
					xtype: 'slider',
					fieldLabel: this.localize('speed'),
					labelAlign: 'right',
					labelWidth: 40,
					width: 100,
					increment: 1,
					minValue: 0,
					maxValue: 100,
					value: 30,
					listeners: {
	                	render: function(cmp) {
	                		cmp.setValue(parseInt(this.getApiParam("speed")));
	    		        	Ext.tip.QuickTipManager.register({
	    		        		target: cmp.getEl(),
	   		                 	text: this.localize('speedTip')
	    		        	});
	                		
	                	},
	                	beforedestroy: function(cmp) {
	                		Ext.tip.QuickTipManager.unregister(cmp.getEl());
	                	},
	                    changecomplete: function(cmp, val) {
	                    	this.setApiParam('speed', val);
                    		this.isReading = val!==0
                    		this.draw();
	                    },
	                    scope: this
					}
				},{xtype: 'tbfill'}, {
	    			xtype: 'tbtext',
	    			html: this.localize('adaptation')
	    		}]
    		}]
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.on('boxready', function(cmp) {
			var canvas = this.getTargetEl().dom.querySelector("canvas");
	    	this.draw(canvas);

    		canvas.addEventListener('mousemove', function(evt) {
    			if (cmp.documentTerms) {
        			var rect = canvas.getBoundingClientRect(), x =  evt.clientX - rect.left, y = evt.clientY - rect.top;
        			
        			var currentTerms = {};
        			cmp.documentTerms.each(function(documentTerm) {
        				var dx = documentTerm.get('x'), dy = documentTerm.get('y');
        				if (dx>x-15 && dx<x+15 && dy>y-15 && dy<y+15) {
        					currentTerms[documentTerm.getTerm()] = true;
        					return false;
        				}
        			})
        			
        			// no need to do anything if there are no current terms and none found
        			if (Object.keys(cmp.currentTerms || {}).length==0 && Object.keys(currentTerms).length==0) {return;}

        			cmp.currentTerms = currentTerms;
        			cmp.draw(canvas); // otherwise redraw
    			}
    			
    	      }, false);
    	})
    	
    	this.on('loadedCorpus', function(src, corpus) {
			this.loadDocument();
    	}, this);
    	
    	this.on("documentselected", function(src, doc) {
    		this.setApiParam('docIndex', this.getCorpus().getDocument(doc).getIndex());
    		this.loadDocument();
    	});
    	
    	this.on("resize", function() {
    		var gutter = 20,
			availableWidth = this.getTargetEl().getWidth() - gutter - gutter,
			availableHeight = this.getTargetEl().getHeight() - gutter - gutter,
			diam = Math.max(availableWidth, availableHeight), rad = diam /2,
			ratio = Math.min(availableWidth, availableHeight) / diam,
			canvas = this.getTargetEl().dom.querySelector("canvas");
    		
			canvas.width = this.getTargetEl().getWidth();
			canvas.height = this.getTargetEl().getHeight();
			this.setDiam(diam);
			this.setPerim([]);
			var i = parseInt(diam*.75)
			while (this.getPerim().length<diam) {
	    		this.getPerim().push({
	    			x:  gutter+(availableWidth/2)+(rad * (availableWidth>availableHeight ? 1 : ratio) * Math.cos(2 * Math.PI * i / diam)),
	    			y:  gutter+(availableHeight/2)+(rad * (availableHeight>availableWidth ? 1 : ratio) * Math.sin(2 * Math.PI * i / diam))
	    		})
	    		if (i++==diam) {i=0;}
			}
			
			// TODO clear previous/current drawing
    	})
    },
    
    draw: function(canvas, ctx) {
    	canvas = canvas ||  this.getTargetEl().dom.querySelector("canvas");
    	ctx = ctx || canvas.getContext("2d");
    	ctx.clearRect(0,0,canvas.width,canvas.height);
		ctx.fillStyle = "rgba(0,0,0,.1)";
    	this.getPerim().forEach(function(p,i) {
    		if (i%3==0) {
        		ctx.fillRect(p.x-5,p.y,10,1)
    		}
    	})
    	if (this.documentTerms) {
        	this.drawTerms(canvas, ctx);
        	this.drawReading(canvas,ctx);
        	if (this.isReading) {
        		var me = this;
        		setTimeout(function() {
        			me.draw();
        		}, 10)
        	}
    	}
    },
    
    drawReading: function(canvas, ctx) {
    	ctx = ctx || this.getTargetEl().dom.querySelector("canvas").getContext("2d");
    	var delay = 2000-(parseInt(this.getApiParam('speed'))*1999/100);
    	if (this.isReading && this.documentTerms) {
    		var current = parseInt(this.readingIndex * this.getPerim().length / this.lastToken);
    		ctx.fillStyle = "purple";
    		ctx.fillRect(this.getPerim()[current].x,this.getPerim()[current].y, 5, 5)
			var first = this.readingStartTime == undefined;
			this.readingStartTime = this.readingStartTime || new Date().getTime();
			var delta = this.readingStartTime+delay-new Date().getTime();
    		if (this.sourceTerm && this.targetTerm) {
    			var maxTail = 10;
    			if (first || delta<=0) {
    				this.previousBeziers = this.previousBeziers || []; // this should be reset by tokens reader during first read
        			var sx = this.sourceTerm.get('x'), sy = this.sourceTerm.get('y'), tx = this.targetTerm.get('x'), ty = this.targetTerm.get('y'),
    					px = this.previousTerm ? this.previousTerm.get('x') : sx, py = this.previousTerm ? this.previousTerm.get('y') : sy,
    					round = 100, multiplier = .3;
    				
        			var ix, iy, xd = Math.max(round, Math.abs(sx-tx) * .5), yd = Math.max(round, Math.abs(sy-ty) * .5);
        			ix = sx > tx ? sx - xd : sx + xd;
        			iy = ty > sy ? sy + yd : sy - yd;
    				this.previousBeziers.unshift([sx,sy,ix,iy,tx,ty]);
    				if (this.previousBeziers.length>maxTail) {this.previousBeziers.pop()}
    			}
    			
    			for (var i=0; i<this.previousBeziers.length; i++) {
	        		ctx.strokeStyle="rgba(0,0,255,"+(1-(i*.1))+")";
    				var start = i+1 == this.previousBeziers.length ? 1-(delta/delay) : 0;
    				var end = i==0 ? 1-(delta/delay) : 1;
            		this.drawBezierSplit.apply(this, Ext.Array.merge([ctx], this.previousBeziers[i], [start], [end]));
    			}
    			if (delta<=0) {
        			this.readingStartTime = undefined;
        			this.read();
    			}
    		}
    		var nextReadingIndex = this.readingIndex+1;
    		for (var len=this.tokens.getCount(); nextReadingIndex<len; nextReadingIndex++) {
    			if (this.tokens.getAt(nextReadingIndex).getTerm().toLowerCase()==this.targetTerm.getTerm()) {
    				break;
    			}
    		}
    		var startReadingIndex = nextReadingIndex-parseInt(delta*(nextReadingIndex-this.readingIndex)/delay), count = this.tokens.getCount();
    		for (; startReadingIndex<nextReadingIndex; startReadingIndex++) {
    			if (startReadingIndex < count && this.tokens.getAt(startReadingIndex).isWord()) {
    				break;
    			}
    		}
    		var tokens = this.tokens.getRange(startReadingIndex, len=Math.min(this.readingIndex+50, this.tokens.getCount())).map(function(token) {
    			return token.getTerm();
    		})
	    	ctx.font = "14px sans-serif";
    		ctx.fillStyle = "rgba(0,0,0,.5)";
        	ctx.textAlign = "left";
    		ctx.fillText(tokens.join(""), canvas.width/4, canvas.height-5);
    		ctx.clearRect(canvas.width*.75, canvas.height-20, canvas.width, 30)
    	} else if (this.documentTerms && this.documentTerms.getCount()<this.documentTerms.getTotalCount()) {
    		var x = canvas.width / 4;
    		ctx.strokeStyle="rgba(0,0,0,.5)";
    		ctx.fillStyle = "rgba(0,0,0,.2)";
    		ctx.strokeRect(x,canvas.height-12,x*2,10);
    		ctx.fillRect(x,canvas.height-12,(this.documentTerms.getCount()*x*2)/this.documentTerms.getTotalCount(),10);
    	}
    },
    
    drawTerms: function(canvas, ctx) {
    	canvas = canvas || this.getTargetEl().dom.querySelector("canvas");
    	ctx = ctx || canvas.getContext("2d");
    	ctx.textAlign = "center";
    	if (this.documentTerms && this.getPerim().length > 0) {
    		this.documentTerms.each(function(documentTerm) {
    			var me = this, freq = documentTerm.getRawFreq(), term = documentTerm.getTerm(),
    				x = documentTerm.get('x'), y = documentTerm.get('y');
    			isCurrentTerm = me.currentTerms && (term in me.currentTerms);
    			isReadingTerm = this.sourceTerm && this.sourceTerm.getTerm() == term;
    	    	ctx.font = ((Math.log(freq)*(canvas.width*10/800)/Math.log(this.maxRawFreq))+(isCurrentTerm || isReadingTerm ? 10 : 5)) + "px sans-serif";
    	    	if (isCurrentTerm) {
    	    		ctx.fillStyle = "red";
    	    	} else if (isReadingTerm) {
    	    		ctx.fillStyle = "blue";
    	    	} else {
    	    		ctx.fillStyle = "rgba(0,0,0,"+((freq*.9/this.maxRawFreq)+.1)+")";
    	    	}
    	    	if (isCurrentTerm || isReadingTerm) {
    	    		ctx.strokeStyle = isCurrentTerm ? "rgba(255,0,0,.2)" : "rgba(0,255,0,.4)";
    	    		documentTerm.getDistributions().forEach(function(d, i) {
    	    			if (d>0 && this.getPerim()[i]) {
    	    				ctx.beginPath();
    	    				ctx.moveTo(x, y);
    	    				ctx.lineTo(this.getPerim()[i].x,this.getPerim()[i].y);
    	    				ctx.stroke();
    	    			}
    	    		}, this)
    	    	}
    			ctx.fillText(term, x, y);
    			
    		}, this)    		
    	}
    },
    
    read: function(index) {
    	if (Ext.isNumber(index)) {this.readingIndex=index;}
    	else {this.readingIndex++;}
    	if (this.sourceTerm) {this.previousTerm=this.sourceTerm;}
    	for (var i=this.readingIndex, len = this.tokens.getCount(); i<len; i++) {
    		var token = this.tokens.getAt(i), term = token.getTerm().toLowerCase();
    		if (term in this.termsMap) {
    			this.sourceTerm = this.termsMap[term];
    			if (this.sourceTerm.getRawFreq()>=1) {
        			this.readingIndex = i;
        			break
    			}
    		}
    	}
    	for (var i=this.readingIndex+1, len = this.tokens.getCount(); i<len; i++) {
    		var token = this.tokens.getAt(i), term = token.getTerm().toLowerCase();
    		if (term in this.termsMap) {
    			this.targetTerm = this.termsMap[term];
    			if (this.targetTerm.getRawFreq()>=1) {
        			break;
    			}
    		}
    	}
    	if (!this.tokensLoading && this.tokens.getCount()-this.readingIndex<this.tokensFetch) {
    		this.fetchMoreTokens();
    	}
    	this.draw();
    },
    
    
    loadDocument: function() {
    	if (this.documentTerms) {this.documentTerms.destroy();this.documentTerms=undefined;}
    	this.termsMap = {};
    	this.draw();
    	var doc =  this.getCorpus().getDocument(parseInt(this.getApiParam('docIndex')));
    	// if we're not in a tab panel, set the document title as part of the header
    	if (!this.up("tabpanel")) {
        	this.setTitle(this.localize('title') + " <span class='subtitle'>"+doc.getFullLabel()+"</span>");
    	}
    	this.lastToken = parseInt(doc.get('lastTokenStartOffset-lexical'));
    	this.documentTerms = doc.getDocumentTerms({
    		proxy: {
    			extraParams: {
    				stopList: this.getApiParam('stopList'),
    				bins: this.getDiam(),
    				withDistributions: 'raw',
    				minRawFreq: parseInt(this.getApiParam('minRawFreq'))
    			}
    		}
    	});
    	var search = this.queryById('search');
    	search.setDisabled(true);
    	search.setStore(this.documentTerms);
    	this.fetchMoreDocumentTerms();
    },
    
    fetchMoreDocumentTerms: function() {
    	if (!this.documentTerms) {this.loadDocument(); return;}
    	this.documentTerms.load({
    		params: {
    			start: this.documentTerms.getCount(),
    			limit: this.documentTerms.getCount() == 0 ? 10 : 250
    		},
    		callback: function(records) {
    			if (records.length>0) {
            		this.maxRawFreq = this.documentTerms.max('rawFreq');
            		records.forEach(function(documentTerm) {
            			var x = y = 0;
            			documentTerm.get('distributions').forEach(function(d, i) {
            				x += (this.getPerim()[i].x*d);
            				y += (this.getPerim()[i].y*d);
            			}, this)
            			documentTerm.set('x', x/documentTerm.getRawFreq());
            			documentTerm.set('y', y/documentTerm.getRawFreq());
            		}, this);
    				Ext.Function.defer(this.fetchMoreDocumentTerms, 0, this);
    				this.draw();
    			} else {
    				this.queryById('search').setDisabled(false);
    				this.termsMap = {};
    				this.documentTerms.each(function(documentTerm) {
    					this.termsMap[documentTerm.getTerm()] = documentTerm;
    				}, this)
    				if (this.tokens) {this.tokens.removeAll(true)}
    				this.fetchMoreTokens();
    			}
    		},
    		addRecords: true,
    		scope: this
    	})
    },
    
    fetchMoreTokens: function() {
		if (!this.tokens) {
			this.tokens = this.getCorpus().getDocument(parseInt(this.getApiParam('docIndex'))).getTokens({
				proxy: {
					extraParams: {
	    				stripTags: 'all'
					}
				}
			});
			this.noMoreTokens = false;
		} else if (this.noMoreTokens) {return;}
		
		var first = this.tokens.getCount() == 0;
		this.tokensLoading = true;
		var speed = parseInt(this.getApiParam('speed'));
    	this.tokens.load({
    		params: {
    			start: this.tokens.getCount(),
    			limit: speed==50 && first ? 200 : Math.pow(110-speed, 2)
    		},
    		callback: function(records) {
    			this.tokensLoading = false;
    			if (records.length>0) {
    				records.forEach(function(token) {
    					if (token.getTokenType()=='other') {
    						token.set('term', token.getTerm().replace(/\s+/g, " "))
    					}
    				})
        			if (first) {
        				this.previousBeziers = [];
        				// TODO
//        				if (this.getApiParam('speed') > 0) {
	        				this.isReading = true;
	        				this.read(0);
//        				}
        			}
    			} else {
    				this.noMoreTokens = true;
    			}
    		},
    		addRecords: true,
    		scope: this

    	});
    },
    
    /* The functions below adapted from http://www.pjgalbraith.com/drawing-animated-curves-javascript/ */
    
    /**
     * Animates bezier-curve
     * 
     * @param ctx       The canvas context to draw to
     * @param x0        The x-coord of the start point
     * @param y0        The y-coord of the start point
     * @param x1        The x-coord of the control point
     * @param y1        The y-coord of the control point
     * @param x2        The x-coord of the end point
     * @param y2        The y-coord of the end point
     * @param duration  The duration in milliseconds
     * @private
     */
    animatePathDrawing: function(ctx, x0, y0, x1, y1, x2, y2, duration) {
        var start = null;
        
        var step = function animatePathDrawingStep(timestamp) {
            if (start === null)
                start = timestamp;
            
            var delta = timestamp - start,
                progress = Math.min(delta / duration, 1);
            
            // Clear canvas
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // Draw curve
            drawBezierSplit(ctx, x0, y0, x1, y1, x2, y2, 0, progress);
            
            if (progress < 1) {
                window.requestAnimationFrame(step);
            }
        };
        
        window.requestAnimationFrame(step);
    },
    
    /**
     * Draws a splitted bezier-curve
     * 
     * @param ctx       The canvas context to draw to
     * @param x0        The x-coord of the start point
     * @param y0        The y-coord of the start point
     * @param x1        The x-coord of the control point
     * @param y1        The y-coord of the control point
     * @param x2        The x-coord of the end point
     * @param y2        The y-coord of the end point
     * @param t0        The start ratio of the splitted bezier from 0.0 to 1.0
     * @param t1        The start ratio of the splitted bezier from 0.0 to 1.0
     * @private
     */
    drawBezierSplit: function(ctx, x0, y0, x1, y1, x2, y2, t0, t1) {
        ctx.beginPath();
        
        if( 0.0 == t0 && t1 == 1.0 ) {
            ctx.moveTo( x0, y0 );
            ctx.quadraticCurveTo( x1, y1, x2, y2 );
        } else if( t0 != t1 ) {
            var t00 = t0 * t0,
                t01 = 1.0 - t0,
                t02 = t01 * t01,
                t03 = 2.0 * t0 * t01;
            
            var nx0 = t02 * x0 + t03 * x1 + t00 * x2,
                ny0 = t02 * y0 + t03 * y1 + t00 * y2;
            
            t00 = t1 * t1;
            t01 = 1.0 - t1;
            t02 = t01 * t01;
            t03 = 2.0 * t1 * t01;
            
            var nx2 = t02 * x0 + t03 * x1 + t00 * x2,
                ny2 = t02 * y0 + t03 * y1 + t00 * y2;
            
            var nx1 = this.lerp ( this.lerp ( x0 , x1 , t0 ) , this.lerp ( x1 , x2 , t0 ) , t1 ),
                ny1 = this.lerp ( this.lerp ( y0 , y1 , t0 ) , this.lerp ( y1 , y2 , t0 ) , t1 );
            
            ctx.moveTo( nx0, ny0 );
            ctx.quadraticCurveTo( nx1, ny1, nx2, ny2 );
        }
        
        ctx.stroke();
        ctx.closePath();
    },
    
    /**
     * Linearly interpolate between two numbers v0, v1 by t
     * @private
     */
    lerp: function(v0, v1, t) {
        return ( 1.0 - t ) * v0 + t * v1;
    }
    
    
    
});

// for mysterious reasons, Ext.require loads the scripts but produces a blank page, so use loadScript instead
/*
var twicPath = Ext.Loader.getPath("resources")+"/twic/current"
Ext.Loader.loadScript(twicPath+"/css/twic.css")
Ext.Loader.loadScript(twicPath+"/lib/queue.min.js")
Ext.Loader.loadScript(twicPath+"/lib/textFlow.js")
Ext.Loader.loadScript(twicPath+"/lib/svg_helper_functions.js")
Ext.Loader.loadScript(twicPath+"/lib/class_syntax.js")
Ext.Loader.loadScript(twicPath+"/js/twic_level.js")
Ext.Loader.loadScript(twicPath+"/js/twic_panel.js")
Ext.Loader.loadScript(twicPath+"/js/twic_datashape.js")
*/


Ext.define('Voyant.panel.TopicContexts', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.topiccontexts',
    statics: {
    	i18n: {
    	},
    	api: {
    	},
		glyph: 'xf06e@FontAwesome'
    },
    
    constructor: function(config) {

    	Ext.apply(this, {
    		title: this.localize('title'),
    		cls: 'twic_body'
    	});

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);

    },
    
    listeners: {
    	loadedCorpus: function(src, corpus) {		
    		this.loadFromCorpus(corpus);
    	}
    	
    },
    
    loadFromCorpus: function(corpus) {
    	var url = Ext.Loader.getPath("resources")+"/twic/current/data/input/json"
        var twicLevel = TWiC.Level.prototype.Instance();
        twicLevel.LoadJSON(url+"/twic_corpusinfo.json", url+"/twic_corpusmap.json");
        var panel = this;

        // Once JSON has loaded, create and start the level
        twicLevel.m_queue.await(function(){

            // Create components
            var graphViews = [];
            var infoViews = [];
            var divName = "dickinson"; // NOTE: This needs to be added to twic_corpusinfo.json from serverside

            // Topic bar setup
            var topicBar = new TWiC.TopicBar({x:0, y:635}, // Position
                                             {width:1280, height:165}, // Size
                                             divName, // Name
                                             twicLevel, []); // Level and linked view(s)
            infoViews.push(topicBar);

            // Document info bar setup
            var docBar = new TWiC.DocumentBar({"x":1055, "y":0}, // Position
                                              {"width":225, "height":635}, // Size
                                              divName,  // Name
                                              twicLevel, []); // Level and linked view(s)
            infoViews.push(docBar);

            // Graph setup
            var corpusClusterView = new TWiC.CorpusClusterView({ "x":0, "y":0 }, // Position
                                                               { "width":1055, "height":635}, // Size
                                                               divName, // Name
                                                               twicLevel, [topicBar, docBar]); // Level and linked view(s)
            graphViews.push(corpusClusterView);

            // Link the corpus cluster view to the topic bar as well
            topicBar.m_linkedViews.push(corpusClusterView);

            var body = panel.getLayout().getRenderTarget();

            // Initialize the level
            twicLevel.Initialize([0,0], // Position
                                 {width: body.getWidth(), height: body.getHeight()}, // Size
                                 divName, // Name
                                 graphViews, infoViews, // TWiC graph and information panels
                                 '#'+body.getId()
            );

            // Startup the level
            twicLevel.Start();
        }.bind(twicLevel));

    }
    
})
Ext.define('Voyant.panel.TermsBerry', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.termsberry',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		context: 2,
        	numInitialTerms: 75,
    		query: undefined,
    		docIndex: undefined,
    		docId: undefined,
    		categories: undefined
    	},
		glyph: 'xf1db@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	
    	mode: undefined,
    	
    	scalingFactor: 3,
    	
    	minRawFreq: undefined,
    	maxRawFreq: undefined,
    	maxCollocateValue: undefined,
    	minFillValue: undefined,
    	maxFillValue: undefined,
    	
    	currentData: {},
    	blacklist: {},
    	
    	visLayout: undefined,
    	vis: undefined,
    	visInfo: undefined,
    	visId: undefined,
    	
    	currentNode: undefined,
    	
    	tip: undefined,
    	contextMenu: undefined
	},
    
	MODE_TOP: 'top',
    MODE_DISTINCT: 'distinct',
    
    MIN_TERMS: 5,
    MAX_TERMS: 500,
    
    COLLOCATES_LIMIT: 1000000, // a very large number so we get all of them
    
    MIN_SCALING: 1,
    MAX_SCALING: 5,
    
    MIN_STROKE_OPACITY: 0.1,
	MAX_STROKE_OPACITY: 0.3,
	
    layout: 'fit',
    
    constructor: function(config) {
    	this.setMode(this.MODE_TOP);
    	
    	this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
    	this.setVisId(Ext.id(null, 'termspack_'));
    },
    
    initComponent: function() {
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                   xtype: 'querysearchfield',
                   clearOnQuery: true
                },{
                	xtype: 'button',
                	text: this.localize('strategy'),
                	menu: {
	                	items: [{
	                		xtype: 'menucheckitem',
	                		group: 'strategy',
	                		checked: this.getMode() === this.MODE_TOP,
	                		text: this.localize('topTerms'),
	                		checkHandler: function(item, checked) {
	                			if (checked) {
	                				this.setMode(this.MODE_TOP);
	                				this.doLoad();
	                			}
	                		},
	                		scope: this
	                	},{
	                		xtype: 'menucheckitem',
	                		group: 'strategy',
	                		checked: this.getMode() === this.MODE_DISTINCT,
	                		text: this.localize('distinctTerms'),
	                		checkHandler: function(item, checked) {
	                			if (checked) {
	                				this.setMode(this.MODE_DISTINCT);
	                				this.doLoad();
	                			}
	                		},
	                		scope: this
	                	}]
                	}
                },{
	                fieldLabel: this.localize('numTerms'),
	    			labelWidth: 50,
	    			labelAlign: 'right',
	    			width: 120,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: this.MIN_TERMS,
	            	maxValue: this.MAX_TERMS,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam('numInitialTerms')));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParam("numInitialTerms", newvalue);
	            			this.doLoad();
	            		},
	            		scope: this
	            	}
                },{
	                fieldLabel: this.localize('context'),
	    			labelWidth: 50,
	    			labelAlign: 'right',
	    			width: 120,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: 1,
	            	maxValue: 30,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam('context'));
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({context: newvalue});
	            			this.doLoad();
	            		},
	            		scope: this
	            	}
                },{
	                fieldLabel: this.localize('scaling'),
	    			labelWidth: 50,
	    			labelAlign: 'right',
	    			width: 120,
	    			xtype: 'slider',
	            	increment: 1,
	            	minValue: this.MIN_SCALING,
	            	maxValue: this.MAX_SCALING,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getScalingFactor());
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			// use the inverse of the value since it'll make more sense to the user
	            			var value = Math.abs(newvalue-(this.MAX_SCALING+1));
	            			this.setScalingFactor(value);
	            			this.reload();
	            		},
	            		scope: this
	            	}
                }
                ]
    		}]
    	});
    	
    	this.setContextMenu(Ext.create('Ext.menu.Menu', {
			renderTo: Ext.getBody(),
			items: [{
				xtype: 'box',
				itemId: 'label',
				margin: '5px 0px 5px 5px',
				html: ''
			},{
		        xtype: 'menuseparator'
			},{
				xtype: 'button',
				text: 'Remove',
				style: 'margin: 5px;',
				handler: function(b, e) {
					var node = this.getCurrentNode();
					if (node !== undefined) {
						delete this.getCurrentData()[node.data.term];
						this.getBlacklist()[node.data.term] = true;
						this.setCurrentNode(undefined);
					}
					this.getContextMenu().hide();
					this.reload();
				},
				scope: this
			}]
		}));
    	
    	this.on('query', function(src, query) {
    		if (query.length > 0) {
    			this.doLoad(query);
    		}
		}, this);
    	
    	this.callParent(arguments);
    },
    
    listeners: {
    	boxready: function() {
			this.initVisLayout();
    	},
    	
    	resize: function(panel, width, height) {
    		if (this.getVisLayout() && this.getCorpus()) {
    			var el = this.getLayout().getRenderTarget();
    	    	width = el.getWidth();
    			height = el.getHeight();
    			
    			el.down('svg').set({width: width, height: height});
    			
    			this.getVisLayout().size([width, height]);
    			
    			this.reload();
    		}
    	},
    	
    	loadedCorpus: function(src, corpus) {
    		if (this.isVisible()) {
        		this.doLoad();
    		}
    	},
    	activate: function() {
    		if (this.getCorpus()) {
    			this.doLoad();
    		}
    	}
    },
    
    doLoad: function(query) {
		this.resetVis();
		if (query === undefined) {
			this.resetMinMax();
			this.setCurrentData({});
		}
    	if (this.getMode() === this.MODE_DISTINCT) {
    		this.getDistinctTerms(query);
    	} else {
    		this.getTopTerms(query);
    	}
    },
    
    reload: function() {
    	var data = this.processCollocates([]);
		if (data.length > 0) {
			this.resetVis();
			this.buildVisFromData(data);
		}
    },
    
    resetMinMax: function() {
    	this.setMinRawFreq(undefined);
    	this.setMaxRawFreq(undefined);
    	this.setMaxCollocateValue(undefined);
    	this.setMinFillValue(undefined);
    	this.setMaxFillValue(undefined);
    },
    
    resetVis: function() {
    	var vis = this.getVis();
    	if (vis) {
        	vis.selectAll('.node').remove();
    	}
    },
    
    getTopTerms: function(query) {
    	var limit = parseInt(this.getApiParam('numInitialTerms'));
    	var stopList = this.getApiParam('stopList');
		var categories = this.getApiParam('categories');
    	if (query !== undefined) {
    		limit = undefined;
    		stopList = undefined;
    	}
    	this.getCorpus().getCorpusTerms().load({
    		params: {
    			query: query,
				categories: categories,
 				limit: limit,
 				stopList: stopList
 			},
		    callback: function(records, operation, success) {
		    	if (success) {
		    		this.loadFromRecords(records);
		    	}
		    },
		    scope: this
    	});
    },
    
    getDistinctTerms: function(query) {
    	var limit = parseInt(this.getApiParam('numInitialTerms'));
    	var stopList = this.getApiParam('stopList');
		var categories = this.getApiParam('categories');
    	if (query !== undefined) {
    		limit = undefined;
    		stopList = undefined;
    	}
    	var perDocLimit = Math.ceil(parseInt(this.getApiParam('numInitialTerms')) / this.getCorpus().getDocumentsCount()); // ceil ensures there's at least 1 per doc
    	this.getCorpus().getDocumentTerms().load({
			params: {
				query: query,
				categories: categories,
				limit: limit,
				perDocLimit: perDocLimit,
				stopList: stopList,
				sort: 'TFIDF',
				dir: 'DESC'
			},
			callback: function(records, operation, success) {
				if (success) {
					this.loadFromRecords(records);
				}
			},
			scope: this
    	});
    },
    
    loadFromQuery: function(query) {
    	this.getCorpus().getCorpusTerms().load({
    		params: {
 				query: query
 			},
		    callback: function(records, operation, success) {
		    	if (success) {
		    		this.loadFromRecords(records);
		    	}
		    },
		    scope: this
    	});
    },
    
    loadFromRecords: function(records) {
    	if (Ext.isArray(records) && records.length>0) {
    		var maxFreq = this.getMaxRawFreq();
    		var minFreq = this.getMinRawFreq();
    		var minFillVal = this.getMinFillValue();
    		var maxFillVal = this.getMaxFillValue();
    		var terms = [];
    		records.forEach(function(r) {
    			var term = r.getTerm();
    			if (!this.getBlacklist()[term]) {
	    			var rawFreq = r.getRawFreq();
	    			var fillVal = this.getMode() === this.MODE_DISTINCT ? r.get('tfidf') : r.getInDocumentsCount();
	    			
	    			if (maxFreq === undefined || rawFreq > maxFreq) maxFreq = rawFreq;
	    			if (minFreq === undefined || rawFreq < minFreq) minFreq = rawFreq;
	    			
	    			if (maxFillVal === undefined || fillVal > maxFillVal) maxFillVal = fillVal;
	    			if (minFillVal === undefined || fillVal < minFillVal) minFillVal = fillVal;
	    			
	    			this.getCurrentData()[term] = {
	    				term: term,
	    				rawFreq: rawFreq,
	    				relativeFreq: r.get('relativeFreq'),//r.getRelativeFreq(),
	    				fillValue: fillVal,
	    				collocates: []
	    			};
	    			
	    			terms.push(term);
    			}
    		}, this);
    		
    		this.setMaxRawFreq(maxFreq);
    		this.setMinRawFreq(minFreq);
    		this.setMinFillValue(minFillVal);
    		this.setMaxFillValue(maxFillVal);
    		
    		this.getCollocatesForQuery(terms);
    	}
    },
    
    getCollocatesForQuery: function(query) {
    	var whitelist = [];
    	for (var term in this.getCurrentData()) {
    		whitelist.push(term);
    	}
    	 
    	this.setApiParams({
    		mode: 'corpus'
    	});
    	var params = this.getApiParams();
    	this.getCorpus().getCorpusCollocates().load({
    		params: Ext.apply(Ext.clone(params), {query: query, collocatesWhitelist: whitelist, limit: this.COLLOCATES_LIMIT}),
    		callback: function(records, op, success) {
    			if (success) {
    				this.buildVisFromData(this.processCollocates(records));
    			}
    		},
    		scope: this
    	});
    },
    
    processCollocates: function(records) {
    	var currentTerms = this.getCurrentData();

    	var maxCol = this.getMaxCollocateValue();
    	
    	for (var i=0; i<records.length; i++) {
    		var r = records[i];
    		var term = r.getTerm();
			var contextTerm = r.getContextTerm();
			var contextFreq = r.getContextTermRawFreq();
			
			if (maxCol === undefined || contextFreq > maxCol) {
				maxCol = contextFreq;
			}
			
			if (currentTerms[term] === undefined) {
				// should not be here
			} else {
	    		if (term != contextTerm) {
	    			currentTerms[term].collocates.push({
	    				term: contextTerm, value: contextFreq
	    			});
	    		}
			}
    	}
    	
    	this.setMaxCollocateValue(maxCol);
    	
    	var data = [];
    	for (var term in currentTerms) {
//    		if (currentTerms[term].collocates.length > 0) {
    			data.push(currentTerms[term]);
//    		}
    	}
    	return data;
    },
    
    buildVisFromData: function(data) {
    	var me = this;
    	
    	if (!this.getVis()) {return;} // not initialized
    	
    	var rootId = '$$$root$$$';
    	data.push({term: rootId, collocates:[], rawFreq:1});
    	var root = d3.stratify()
    		.id(function(d) { return d.term; })
    		.parentId(function(d) {
    			if (d.term !== rootId) return rootId;
				else return '';
			})(data)
			.sort(function(a, b) { return a.rawFreq < b.rawFreq ? 1 : a.rawFreq > b.rawFreq ? -1 : 0; })
			.sum(function(d) { return Math.pow(d.rawFreq, 1/me.getScalingFactor()); });
    	this.getVisLayout()(root);
    	
    	// join nodes with data
    	var nodes = this.getVis().selectAll('.node').data(root.descendants());
    	
    	// update
    	nodes.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; });
    	nodes.selectAll('circle').attr('r', function(d) { return d.r; });
    	
    	var idGet = function(term) {
    		return term.replace(/\W/g, '_'); // remove non-word characters to create valid DOM ids
    	};
    	
    	var collocateFill = d3.scalePow().exponent(1/3)
			.domain([0,this.getMaxCollocateValue()]).range(['#fff', '#bd3163']);
    	
    	var defaultFill;
    	if (this.getMode() === this.MODE_DISTINCT) {
    		defaultFill = d3.scalePow().exponent(1/5)
    			.domain([this.getMinFillValue(), this.getMaxFillValue()]).range(['#dedede', '#fff']);
    	} else {
    		defaultFill = d3.scaleLinear()
				.domain([this.getMaxFillValue(), this.getMinFillValue()]).range(['#dedede', '#fff']);
    	}
    	
    	// roughly calculate font size based on available area and number of terms
    	var size = this.getVisLayout().size();
    	var layoutRadius = Math.min(size[0], size[1]) / 2;
    	var layoutArea = Math.PI*(layoutRadius*layoutRadius);
    	var totalTerms = data.length;
    	var termArea = layoutArea / totalTerms;
    	var termRadius = Math.sqrt(termArea / Math.PI);
    	var minFontSize = termRadius / 3;
    	var scalingInverse = Math.abs(this.getScalingFactor()-(this.MAX_SCALING+1));
    	scalingInverse = Math.max(1, scalingInverse-1); // substract one to avoid too large fonts
    	var maxFontSize = minFontSize * scalingInverse;

    	var textSizer = d3.scaleLinear()//pow().exponent(1/2)
    		.domain([this.getMinRawFreq(),this.getMaxRawFreq()]).range([minFontSize, maxFontSize]);
    	
    	// enter
    	var node = nodes.enter().append('g')
    		.attr('class', 'node')
    		.style('visibility', function(d) { return d.depth > 0 ? 'visible' : 'hidden'; }) // hide root
    		.attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
    		.on('click', function(d) {
    			me.dispatchEvent('termsClicked', me, [d.data.term]);
    		})
    		.on('mouseover', function(d, i) {
    			me.setCurrentNode(d);
    			
    			me.getVis().selectAll('circle')
    				.style('stroke-width', 1)
    				.style('stroke', '#111')
        			.style('fill', function(d) { return defaultFill(d.data.fillValue); });
    			
    			d3.select(this).select('circle')
    				.style('fill', '#89e1c2')
    				.style('stroke', '#26926c')
    				.style('stroke-opacity', me.MAX_STROKE_OPACITY);
    			
    			var fillLabel;
    			if (me.getMode() === me.MODE_DISTINCT) {
    				fillLabel = me.localize('tfidf');
    			} else {
    				fillLabel = me.localize('inDocs');
    			}
    			
    			if (!me.getContextMenu().isVisible()) {
	    			var info = '<b>'+d.data.term+'</b> ('+d.data.rawFreq+')<br/>'+fillLabel+': '+d.data.fillValue;
					var tip = me.getTip();
					tip.update(info);
					tip.show();
    			}
				
				for (var i = 0; i < d.data.collocates.length; i++) {
					var collocate = d.data.collocates[i];
					var match = me.getVis().selectAll('.node').filter(function(d) { return d.data.term === collocate.term; });
					match.select('circle')
						.style('fill', function(d) { return collocateFill(collocate.value); })
						.style('stroke', '#bd3163')
						.style('stroke-opacity', me.MAX_STROKE_OPACITY);
					match.select('tspan.value').text(function(d) { return collocate.value; });
				}
			})
			.on('mousemove', function() {
				me.getTip().setPosition(d3.event.pageX+5, d3.event.pageY-50);
			})
			.on('mouseout', function() {
				if (!me.getContextMenu().isVisible()) {
					me.setCurrentNode(undefined);
				}
				
				me.getVis().selectAll('circle').style('stroke-opacity', me.MIN_STROKE_OPACITY).style('stroke', '#111')
	    			.style('fill', function(d) { return defaultFill(d.data.fillValue); });
				me.getVis().selectAll('tspan.value').text('');
				me.getTip().hide();
//				me.getVisInfo().text('');
			})
			.on('contextmenu', function(d, i) {
				d3.event.preventDefault();
				me.getTip().hide();
				var menu = me.getContextMenu();
				menu.queryById('label').setHtml(d.data.term);
				menu.showAt(d3.event.pageX+5, d3.event.pageY-50);
			});
    	
    	node.append('circle')
    		.attr('id', function(d) {
    			return idGet(d.data.term);
			})
			.attr('r', function(d) { return d.r; })
			.style('fill', function(d) { return defaultFill(d.data.fillValue); })
			.style('stroke', '#111')
			.style('stroke-opacity', me.MIN_STROKE_OPACITY)
			.style('stroke-width', 1);
    	
    	node.append('clipPath').attr('id', function(d) { return 'clip-' + idGet(d.data.term); })
    		.append('use').attr('xlink:href', function(d) { return '#' + idGet(d.data.term); });
		
    	var text = node.append('text')
    		.attr('clip-path', function(d) { return 'url(#clip-' + idGet(d.data.term) + ')'; })
    		.style('font-family', function(d) { return me.getApplication().getCategoriesManager().getFeatureForTerm('font', d.data.term); })
			.style('text-anchor', 'middle')
			.style('cursor', 'default');
		text.append('tspan')
			.attr('class', 'term')
			.attr('font-size', function(d) { return textSizer(d.data.rawFreq); })
			.attr('x', 0)
			.attr('y', function(d) { return textSizer(d.data.rawFreq)/4; })
			.text(function(d) { return d.data.term; });
		text.append('tspan')
			.attr('class', 'value')
			.attr('font-size', function(d) { return textSizer(d.data.rawFreq)*0.75; })
			.attr('x', 0)
			.attr('y', function(d) { return textSizer(d.data.rawFreq)+1; });
		
		// exit
    	nodes.exit().remove();
		
    },
    
    initVisLayout: function() {
    	var el = this.getLayout().getRenderTarget();
		el.update(''); // make sure to clear existing contents (especially for re-layout)
    	var width = el.getWidth();
		var height = el.getHeight();

		var me = this;
		this.setVisLayout(
			d3.pack().size([width, height]).padding(1.5)
		);
		
		var svg = d3.select(el.dom).append('svg').attr('id',this.getVisId()).attr('width', width).attr('height', height);
		this.setVis(svg.append('g'));
		
		this.setVisInfo(svg.append('text').attr('x', 10).attr('y', 10));
		
		if (this.getTip() === undefined) {
			this.setTip(Ext.create('Ext.tip.Tip', {}));
		}
    }
});
/**
 * Terms Radio tool, a visualization for term distributions.
 * 
 * <iframe src="../?corpus=austen&view=termsradio" style="max-width: 600px; height: 600px"></iframe>
 * 
 * The typical use is not to instantiate this class directly, but to embed the tool from a corpus.
 * 
 * 		var austen;
 * 		new Corpus("austen").then(function(corpus) {
 * 			austen = corpus;
 * 			austen.embed('TermsRadio'); // simply embed
 * 			austen.embed('TermsRadio', {visibleBins: 8}); // embed with parameter
 * 		});
 * 
 * @class Voyant.panel.TermsRadio
 * @author Mark Turcato
 * @author Andrew MacDonald
 */
Ext.define('Voyant.panel.TermsRadio', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.termsradio',
	config: {
		/**
		 * @private
		 */
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
		/**
		 * @private
		 */
		speed: 50,
		/**
		 * @private
		 */
		termsRadio: undefined
	},
    statics: {
    	i18n: {
    	},
    	api: {
    		/**
    		 * @private (this shouldn't be modified but it needs to be part of the parameters)
    		 */
    		withDistributions: true,

    		/**
    		 * @cfg {Number} bins How many document segments to show if the corpus has a single document (default is 10); otherwise, the number of bins corresponds to the number of documents in the corpus.
    		 * 
    		 * Note that this often works in parallel with the {@link #bins} value.
    		 */
    		bins: 5
    	
    		/**
    		 * @cfg {Number} visibleBins How many segments or documents to show at once (default is 5).
    		 * 
    		 * Note that this often works in parallel with the {@link #bins} value.
    		 */
    		,visibleBins: 5
    		
    		/**
    		 * @property docIdType The document type(s) to restrict results to.
    		 * @type String|Array
    		 * @default null
    		 * @private
    		 */
    		,docIdType: null
    		
    		/**
    		 * @cfg {Number} limit Determine the number of terms to show (larger numbers may make the graph unusable).
    		 */
    		,limit: 50
    	
    		/**
        	 * @property mode What mode to operate at, either document or corpus.
        	 * @choices document, corpus
    		 * @private
        	 */
    		,mode: null
    		
    		/**
        	 * @property position The current shifted position of the visualization.
        	 * @type Integer
        	 * @default 0
    		 * @private
        	 */
    		,position: 0
    		
    		/**
    		 * @property selectedWords The words that have been selected.
    		 * @type String|Array
    		 * @default null
    		 * @private
    		 */
    		,selectedWords: []
    		
			/**
			 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
			 * 
			 *  By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
			 *  
			 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
			 */
    		,stopList: 'auto'
    		
    		/**
    		 * @property query The corpus type(s) to restrict results to.
    		 * @type String
    		 * @default null
    		 * @private
    		 */
    		,query: null
    		
    		/**
    		 * @property yAxisScale The scale for the y axis.
    		 * @type String
    		 * @default log
    		 * @private
    		 */
    		,yAxisScale: 'log'
    			
    		,speed: 50
    		
    		/**
    		 * @property slider Whether to show the slider
    		 * @type Boolean
    		 * @default true
    		 */
    		,slider: undefined
    	},
    	glyph: 'xf201@FontAwesome'
    }
	
	/**
	 * @private
	 */
	,constructor: function(config) {
		
		var onLoadHandler = function(mode, store, records, success, operation) {
			this.setApiParams({mode: mode});

			this.getTermsRadio().loadRecords(records);
			
			var query = this.getApiParam('query');
			// check for no results
			if (query) {
				if (records.length==0 || (records.length==1 && records[0].getRawFreq()==0)) {
					this.toastInfo({
						html: this.localize("termNotFound"),
						align: 'bl'
					});
				} else {
					this.getTermsRadio().highlightQuery(query, true);
				}
			}
		};
		
		this.corpusStore = Ext.create("Voyant.data.store.CorpusTerms", {
			listeners : {
				load: {
					fn : onLoadHandler.bind(this, 'corpus'),
					scope : this
				}
			}
		});
		
		this.documentStore = Ext.create("Voyant.data.store.DocumentTerms", {
			listeners : {
				load: {
					fn : onLoadHandler.bind(this, 'document'),
					scope : this
				}
			}
		});
		
		Ext.apply(config, {
			title: this.localize('title'),
			legendMenu: Ext.create('Ext.menu.Menu', {
				items: [
        			{text: '', itemId: 'remove', glyph: 'xf068@FontAwesome'}
        		]
        	}),
			tbar: new Ext.Toolbar({
                overflowHandler: 'scroller',
				items: {
					xtype: 'legend',
					store: new Ext.data.JsonStore({
						fields : ['name', 'mark', 'selector']
					}),
					listeners: {
						itemclick: function(view, record, el, index) {
							var term = record.get('name');
							if (this.getTermsRadio().isTermSelected(term)) {
								this.getTermsRadio().doTermDeselect(term);
							} else {
								this.getTermsRadio().doTermSelect(term);
							}
						},
						itemcontextmenu: function(view, record, el, index, event) {
							event.preventDefault();
			            	var xy = event.getXY();
			            	
			            	var term = record.get('name');
			            	var text = (new Ext.Template(this.localize('removeTerm'))).apply([term]);
		            		this.legendMenu.queryById('remove').setText(text);
		            		
		            		this.legendMenu.on('click', function(menu, item) {
		            			if (item !== undefined) {
		            				this.getTermsRadio().doTermDeselect(term, true);
		            			}
		            		}, this, {single: true});
		            		this.legendMenu.showAt(xy);
						},
						scope: this
					}
				}
			}),
			bbar: {
                overflowHandler: 'scroller',
	            items: [{
	            	xtype: 'querysearchfield'
	            },{
	    			glyph: 'xf04b@FontAwesome', // start with play button, which means we're paused
	    			itemId: 'play',
	    			handler: function(btn) {
	    				var playing = btn.glyph=="xf04c@FontAwesome";
	    				if (playing) {
	    					this.getTermsRadio().continueTransition = false;
	    					this.mask(this.localize("completingTransition"))
	    					btn.setPlaying(false)
	    				}
	    				else {
	    					this.getTermsRadio().toggleRightCheck();
	    					btn.setPlaying(true);
	    				}
	    			},
	    			scope: this,
	    			setPlaying: function(bool) {
	    				this.setGlyph(bool ? "xf04c@FontAwesome" : "xf04b@FontAwesome")
	    			}
	    		},{
	    			glyph: 'xf0e2@FontAwesome',
//	    			text: this.localize('reset')
	    			tooltip : this.localize('resetTip'),
	    			listeners : {
	    				click : {fn : function() {
	    					this.queryById("play").setPlaying(false);
							this.getTermsRadio().shiftCount = 0;
							this.getTermsRadio().prepareData();
							this.getTermsRadio().redraw();
    					}				
	    					,scope : this
	    				}
	    			}
	    		},{
	    			xtype: 'label',
	    			forId: 'terms',
	    			text: this.localize('terms')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'terms',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 5,
	    			minValue : 5,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("limit")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.loadStore();
	            		},
	            		scope: this
	            	}
	    		},{
	    			xtype: 'label',
	    			forId: 'speed',
	    			text: this.localize('speed')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'speed',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 5,
	    			minValue : 5,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("speed")))
	            			this.setSpeed(slider.getValue())
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({speed: newvalue});
	            			this.setSpeed(newvalue)
	            		},
	            		scope: this
	            	}
	    		},{
	    			xtype: 'label',
	    			itemId: 'visibleSegmentsLabel',
	    			forId: 'visibleBins',
	    			text: this.localize('visibleSegments')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'visibleBins',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 1,
	    			minValue : 1,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("visibleBins")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({visibleBins: newvalue});
							this.numVisPoints = newvalue;
							this.loadStore();
							
							if (this.numVisPoints == this.getCorpus().getDocumentsCount()) {
								this.getTermsRadio().hideSlider();
							} else if (this.getApiParam("slider") != 'false'){
								this.getTermsRadio().showSlider();
							}
	            		},
	            		scope: this
	            	}
	    		},{
	    			xtype: 'label',
	    			itemId: 'segmentsLabel',
	    			forId: 'segments',
	    			text: this.localize('segments')
	    		},{
	    			xtype: 'slider',
	    			itemId: 'segments',
	    			hideLabel: true,
	    			width : 60,
	    			increment : 1,
	    			minValue : 1,
	    			maxValue : 100,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(parseInt(this.getApiParam("bins")))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({bins: newvalue});
							this.numDataPoints = newvalue;
							this.loadStore();
							var visibleBins = this.queryById('visibleBins');
							visibleBins.setMaxValue(newvalue) // only relevant for doc mode
	            		},
	            		scope: this
	            	}
	    		}]
			}
		});
		
		// need to add option here so we have access to localize
		this.config.options.push({
			xtype: 'combo',
			queryMode : 'local',
			triggerAction : 'all',
			forceSelection : true,
			editable : false,
			fieldLabel : this.localize('yScale'),
			labelAlign : 'right',
			name : 'yAxisScale',
			valueField : 'value',
			displayField : 'name',
			store: new Ext.data.JsonStore({
				fields : ['name', 'value'],
				data   : [{
					name : this.localize('linear'),   value: 'linear'
				},{
					name : this.localize('log'),  value: 'log'
				}]
			}),
			listeners: {
				afterrender: function(combo) {
					combo.setValue(this.getApiParam('yAxisScale'));
				},
				scope: this
			}
		});
		
		this.callParent(arguments);
		this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
		
		this.on('boxready', function(component) {
			var sliderParam = this.getApiParam('slider');
			var showSlider = sliderParam === undefined ? true : sliderParam === 'true';
			var config = {
				parent: this,
				container: this.body,
				showSlider: showSlider
			};
			this.setTermsRadio(new TermsRadio(config));
		}, this);
		
		/**
		 * @event corpusTypesSelected
		 * @type listener
		 * @private
		 */
		this.addListener('corpusTermsClicked', function(src, terms){
			if (this.getCorpus().getDocumentsCount() > 1) {
        		terms.forEach(function(term) {
        			var t = term.getTerm();
        			this.setApiParams({query: t});
        			this.loadStore();
        		}, this);
			}
		});
		
		this.addListener('documentTermsClicked', function(src, terms){
			if(src && src.xtype==this.xtype) {return false;}
			
			terms.forEach(function(term) {
    			var t = term.getTerm();
    			this.setApiParams({query: t});
    			this.loadStore();
    		}, this);
		});
		
		this.on('query', function(src, query){
			this.fireEvent("termsClicked", src, query);
	    });
		
		this.on("termsClicked", function(src, terms) {
			// TODO load term distribution data
			terms.forEach(function(term) {
				var queryTerm;
    			if (Ext.isString(term)) {queryTerm = term;}
    			else if (term.term) {queryTerm = term.term;}
    			else if (term.getTerm) {queryTerm = term.getTerm();}
    			
    			// TODO handling for multiple terms
    			this.setApiParams({query: queryTerm});
    			this.loadStore();
    		}, this);
    	});
		
		this.on("loadedCorpus", function(src, corpus) {
    		this.documentStore.setCorpus(corpus);
    		this.corpusStore.setCorpus(corpus);
    		
    		var params = this.getApiParams();
			if (params.type) {
				delete params.limit;
			}
			var store;
			
			var docsCount = this.getCorpus().getDocumentsCount();
			var segments = this.queryById("segments");
			var visibleBins = this.queryById("visibleBins");
			if (params.mode=='document' || docsCount == 1) {
				this.setApiParam("mode", "document");
				store = this.documentStore;
				visibleBins.setMaxValue(segments.getValue())
			} else {
				this.setApiParam("mode", "corpus");
				delete params.bins;
				store = this.corpusStore;
				segments.hide();
				this.queryById("segmentsLabel").hide();
				var visibleBins = this.queryById("visibleBins");
				visibleBins.setMaxValue(docsCount);
				if (parseInt(this.getApiParam("visibleBins")>docsCount)) {
					visibleBins.setValue(docsCount);
				}
			}
			
			// select top 3 words
			store.on('load', function(store, records) {
				for (var i = 0; i < 3; i++) {
					var r = records[i];
					if (r) {
						this.getTermsRadio().highlightRecord(r, true);
					}
				}
			}, this, {single: true});
			store.load({params: params});
    	}, this);		
	}
	
    ,loadStore: function () {
    	this.queryById('play').setPlaying(false);
		var params = this.getApiParams();
		if(this.getApiParam('mode') === 'document') { 
			this.documentStore.load({params: params});
		}
		if(this.getApiParam('mode') === 'corpus') {
			delete params.bins;
			this.corpusStore.load({params: params});
		}
	}
    
});

/**
 * Trends tool, a line graph that shows term distributions.
 * 
 * <iframe src="../?corpus=austen&view=trends" style="max-width: 500px; height: 300px"></iframe>
 * 
 * The typical use is not to instantiate this class directly, but to embed the tool from a corpus.
 * 
 * 		var austen;
 * 		new Corpus("austen").then(function(corpus) {
 * 			austen = corpus;
 * 			austen.embed('Trends'); // simply embed
 * 			austen.embed('Trends', {query: '^lov*'}); // embed with query
 * 		});
 */
Ext.define('Voyant.panel.Trends', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	requires: ['Voyant.data.store.Documents'],
	alias: 'widget.trends',
	config: {
	    /**
	     * @private
	     */
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'},

    		{
    			name: 'bins',
		    	xtype: 'slider',
		    	labelAlign: 'right',
		    	width: 200,
		    	minValue: 2,
		    	maxValue: 100,
	        	listeners: {
	        		afterrender: function(slider) {
	        			var trends = slider.up("window").panel;
	        			slider.setFieldLabel(trends.localize("segmentsSlider"));
	        		}
	        	}    		
    		},{
                xtype: 'radiogroup',
		    	labelAlign: 'right',
                columns: 3,
                vertical: true,
                name: 'withDistributions',
                items: [{
                    boxLabel: 'raw',
                    name: 'withDistributions',
                    inputValue: 'raw'
                },{
                    boxLabel: 'relative',
                    name: 'withDistributions',
                    inputValue: 'relative',
                    style: 'margin-left: 1em;'
                }],
	        	listeners: {
	        		afterrender: function(radiogroup) {
	        			var panel = this.up("window").panel;
	        			this.setFieldLabel("frequencies");
	        			var val = panel.getApiParam("withDistributions");
	        			radiogroup.getBoxes().forEach(function(item) {
	        				item.setBoxLabel(panel.localize(item.inputValue));
	        				item.checked = item.inputValue==val;
	        			});
	        			this.setValue({withDistributions: val});
	        		}
	        	}
    		},{xtype: 'colorpaletteoption'}]
	},
    statics: {
    	i18n: {
			displayTip: 'Chart display options',
			labelsTip: 'Toggle term labels',
			areaTip: 'Area chart',
			barTip: 'Columns chart',
			lineTip: 'Line chart',
			stackedTip: 'Stacked bar chart',
			barlineTip: 'Line and stacked bar chart'
    	},
    	api: {
    		
    		/**
    		 * @cfg {Number} limit Determine the number of terms to show (larger numbers may make the graph unusable).
    		 */
    		limit: 5,
    		
    		/**
    		 * @cfg {String} stopList A comma-separated list of words, a named list or a URL to a plain text list, one word per line.
    		 * 
    		 *  By default this is set to 'auto' which auto-detects the document's language and loads an appropriate list (if available for that language). Set this to blank to not use the default stopList.
    		 *  
    		 * For more information see the <a href="#!/guide/search">Stopwords documentation</a>.
    		 */
    		stopList: 'auto',
    		
    		/**
    		 * @cfg {String/String[]} query A query or array of queries (queries can be separated by a comma).
    		 * 
    		 * For query syntax, see the <a href="#!/guide/search">search documentation</a>.
    		 */
    		query: undefined,
    		
    		/**
    		 * @cfg {String} withDistributions Determine whether to show "raw" or "relative" frequencies (those are the two valid values).
    		 * 
    		 * The default value is "relative" (unless there's only one document in the corpus, in which case raw frequencies are shown).
    		 */
    		withDistributions: 'relative',
    		
    		/**
    		 * @cfg {Number} bins The number of segments to use.
    		 * 
    		 * The default value will depend on the nature of the corpus:
    		 * 
    		 * - corpus has one document: the default number of bins is 10
    		 * - corpus has multiple documents:
    		 *   - corpus has up to 100 documents: the default number is the size of the corpus
    		 *   - corpus has more than 1000 documents: the default number is 100
    		 */
    		bins: 10,
    		
    		/**
    		 * @cfg {Number/Number[]/String} docIndex The index of one or more documents, as a number, or numbers separated by commas or in an array.
    		 * 
    		 * The first document's index is 0 and so on.
    		 */
    		docIndex: undefined,
    		
    		/**
    		 * @cfg {String/String[]} docId The document ID of one or more documents, as a string, or strings separated by commas or in an array.
    		 */
    		docId: undefined,
    		
    		/**
    		 * @cfg {String} mode Force the mode to be either "corpus" (distribution of terms across documents) or "document" (distribution of terms within a document); usually this is correctly set by default according to whether the corpus has one document ("document") or more than one ("corpus").
    		 */
    		mode: "corpus",
    		
    		chartType: 'barline',
    		
    		labels: false
    	},
		glyph: 'xf201@FontAwesome'
    },
    
    layout: 'fit',
    documentTermsStore: undefined,
    //segments: undefined,
    
    /**
     * @private
     */
    constructor: function(config) {
    	this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // we need api
    	Ext.apply(this, {
    		title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                    xtype: 'querysearchfield'
                },{
                	itemId: 'reset',
                	text: this.localize("reset"),
                	tooltip: this.localize("resetTip"),
                	handler: function(btn) {
                		this.setApiParams({
                			docIndex: undefined,
                			mode: undefined,
                			query: undefined
                		});
                		this.loadCorpusTerms();
                	},
                	scope: this
				},{
					text: this.localize('display'),
					tooltip: this.localize('displayTip'),
					glyph: 'xf013@FontAwesome',
					menu: {
						listeners: {
							afterrender: function(menu) {
								var val = this.getApiParam("chartType");
								menu.items.each(function(item) {
									if (item.getItemId()==val) {
										item.addCls(item.activeCls);
									}
								})
							},
							scope: this
						},
	                    defaults: {
	                        xtype: 'menuitem',
	                        handler: function(item, checked) {
	                        	if (item.xtype=="menucheckitem") { // labels
		                        	this.setApiParam("labels", item.checked);
	                        	} else {
		                        	this.setApiParam("chartType", item.getItemId());
	                        	}
	                        	this.loadCorpusTerms();
	                        },
	                        scope: this
	                    },
	                    items: [{
	                    	xtype: 'menucheckitem',
	                    	text: this.localize('labels'),
	                        tooltip: this.localize('labelsTip'),
	                        checked: this.getApiParam("labels")===true || this.getApiParam("labels")=="true"
	                    },'-',{
	                        itemId: 'area',
	                        text: this.localize('area'),
	                        tooltip: this.localize('areaTip'),
	                        glyph: 'xe76b@Sencha-Examples'
	                    },{
	                        itemId: 'bar',
	                        text: this.localize('bar'),
	                        tooltip: this.localize('barTip'),
	                        glyph: 'xe768@Sencha-Examples'
	                    },{
	                        itemId: 'line',
	                        text: this.localize('line'),
	                        tooltip: this.localize('lineTip'),
	                        glyph: 'xe773@Sencha-Examples'
	                    },{
	                        itemId: 'stacked',
	                        text: this.localize('stacked'),
	                        tooltip: this.localize('stackedTip'),
	                        glyph: 'xe6c8@Sencha-Examples'
	                    },{
	                        itemId: 'barline',
	                        text: this.localize('barline'),
	                        tooltip: this.localize('barlineTip'),
	                        glyph: 'xe779@Sencha-Examples'
	                    }]
					}
				}]
            }]
    	});
        this.callParent(arguments);
    },
    
    listeners: {
    	loadedCorpus: function(src, corpus) {
    		this.loadCorpusTerms();
    	},
    	termsClicked: function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (Ext.isString(term)) {queryTerms.push(term);}
    			else if (term.term) {queryTerms.push(term.term);}
    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
    		});
    		this.setApiParam("query", queryTerms && queryTerms.length>0 ? queryTerms : undefined);
    		this.loadCorpusTerms();
    	},
    	corpusTermsClicked: function(src, terms) {
    		this.setApiParam("query", terms.map(function(term) {return term.getTerm()}));
    		this.loadCorpusTerms();
    	},
    	documentSelected: function(src, document) {
			this.setApiParam("docIndex", this.getCorpus().getDocument(document).getIndex());
    		this.loadDocumentTerms();
    	},
    	documentsClicked: function(src, documents) {
    		if (documents.length==1) {
    			this.fireEvent("documentSelected", this, documents[0])
    		}
    	},
    	query: function(src, query) {
			this.fireEvent("termsClicked", this, query)
    	}
    },
    
    loadCorpusTerms: function(params) {
    	// if our corpus only has one document or if we have docIndex defined
    	if (
    		this.getCorpus().getDocumentsCount()<2 || // only one document
    		this.getApiParam("mode")=="document" || // in document mode
    		Array.from(this.getApiParam("docIndex") || "").length>0 // we have a docIndex defined
    		) {
    		return this.loadDocumentTerms();
    	}
    	if (!this.getApiParam("query")) {
        	this.getCorpus().getCorpusTerms().load({
        		params: {
        			limit: this.getApiParam('limit'),
        			stopList: this.getApiParam("stopList")
        		},
        		callback: function(records, operation, success) {
        			if (records.length==0) {
        				if (operation && operation.error) {
        					this.showError(this.localize("noResults")+"<p style='color: red'>"+operation.error+"</p>")
        				} else {
        					this.showError(this.localize("noResults"))
        				}
        			} else {
            			this.setApiParam("query", records.map(function(r) {return r.getTerm()}))
            			this.loadCorpusTerms();
        			}
        		},
        		scope: this
        	})
    		return;
    	}
    	params = params || {};
    	//this.segments.hide();
    	var withDistributions = this.getApiParam("withDistributions");
    	Ext.applyIf(params, {
    		bins: this.getCorpus().getDocumentsCount(),
			limit: 100, // should have query, so no limit 
	    	stopList: "" // automatic queries should be stopped already
    	});
    	var docLabels = [];
		var docLabelsFull = [];
		this.getCorpus().each(function(doc) {
			docLabels.push(doc.getTinyTitle());
			docLabelsFull.push(doc.getTitle());
		})
    	if (Ext.Array.unique(docLabels).length<docLabels.length) { // we have duplicates, add index
    		docLabels = docLabels.map(function(doc,i) {return (i+1)+")"+ doc})
    	}
    	Ext.applyIf(params, this.getApiParams());
    	this.getCorpus().getCorpusTerms().load({
    		params: params,
    		callback: function(records, operation, success) {
    			var data = [], series = [], chartType = this.getApiParam('chartType');
    			records.forEach(function(record, index) {
    	    		var term = record.get('term');
    	    		var color = this.getApplication().getColorForTerm(term, true);
    	    		record.get('distributions').forEach(function(r, i) {
    	    			if (!data[i]) {
    	    				data[i] = {"index": docLabels[i], "docTitle": docLabelsFull[i]};
    	    			}
    	    			data[i]["_"+index] = withDistributions=='relative' ? r.toFixed(7) : r;
    	    			data[i]["term"+index] = term;
    	    		}, this);
    	    		
    	    		
    	    		if (chartType!='bar') {
    	    			var kinds = chartType=='barline' ? ["bar","line"] : [chartType];
    	    			kinds.forEach(function(kind) {
    	    	        	series.push({
    	    	        		type: kind=='stacked' ? 'bar' : kind,
    	    	    			title: term,
    	    	    			xField: 'index',
    	    	    			yField: '_'+index,
    	    	    			term: term,
    	    	    			colors: [color],
    	    	    			label: chartType=='barline' && kind=='bar' ? {
    	    	    				display: 'none'
    	    	    			} : {
    	    	    				field: "term"+index
    	    	    			}
    	    	        	})
    	    			}, this);
    	    		}
    			}, this);
    			
    			var terms = records.map(function(r) {return r.getTerm()})
    			var colors = terms.map(function(term) {
	    			return  this.getApplication().getColorForTerm(term, true);
	    		}, this);
	    		if (chartType=='bar') {
		    		series.push({
		    			type:'bar',
		    			title: terms,
			    		colors: colors,
		    			xField: 'index',
		    			yField: data.length>0 ? Object.keys(data[0]).filter(function(field) {return field.charAt(0)=="_"}) : undefined,
    	    			label: {
    	    				field: records.map(function(r,i) {return "term"+i;})
    	    			}
		    		})
	    		}
	    		
    	    	var store = Ext.create('Ext.data.JsonStore', {
    	    		fields: data.length>0 ? Object.keys(data[0]) : undefined,
    	    		data: data
    	    	});
    	    	
    			this.buildChart({
        			store: store,
        			series: series,
        			axes: [{
                		type: 'numeric',
                		position: 'left',
                		increment: 1,
                		title: {
                			text: this.localize(this.getApiParam("withDistributions")+"Title")
                		}
        			},{
        				type: 'category',
                		position: 'bottom',
                		title: {
                			text: this.localize("corpusTitle")
                		}
                		
        			}]
    			})
    		},
    		scope: this
    	});
  
    },   

    loadDocumentTerms: function(params) {
    	if (!this.getApiParam("query")) {
        	this.getCorpus().getCorpusTerms().load({
        		params: {
        			limit: this.getApiParam('limit'),
        			stopList: this.getApiParam("stopList")
        		},
        		callback: function(records, operation, success) {
        			this.setApiParam("query", records.map(function(r) {return r.getTerm()}))
        			this.loadDocumentTerms();
        		},
        		scope: this
        	})
    		return;
    	}
    	//this.segments.show();
    	this.setApiParam("mode", "document"); // just to be sure
    	params = params || {};
    	var withDistributions = this.getApiParam("withDistributions");
    	Ext.applyIf(params, {
			limit: 0, // always have query, so no limit, no stopList
			sort: 'termasc',
			stopList: undefined
    	});
    	var singleDoc;
    	if (this.getCorpus().getDocumentsCount()==1) {
    		singleDoc=this.getCorpus().getDocument(0)
    	}
    	else {
    		singleDoc=this.getCorpus().getDocument(this.getApiParam("docIndex"))
    	}
    	Ext.applyIf(params, this.getApiParams());
    	
    	this.getCorpus().getDocumentTerms().load({
    		params: params,
    		callback: function(records, operation, success) {
    			var data = [], series = [],  chartType = this.getApiParam('chartType');
    			if (!singleDoc) { // legend is easier to read if sorted by term then doc
        			records.sort(function(a,b) {
        				if (a.getTerm()==b.getTerm()) {
        					return a.getDocIndex() - b.getDocIndex()
        				}
        				return a.getTerm().localeCompare(b.getTerm())
        			})
    			}
    			records.forEach(function(record, index) {
    	    		var term = record.get('term');
    	    		var docIndex = record.get('docIndex');
    	    		var color = singleDoc ? this.getApplication().getColorForTerm(term, true) : this.getApplication().getColor(docIndex, true);
    	    		record.get('distributions').forEach(function(r, i) {
    	    			if (!data[i]) {
    	    				data[i] = {index: (i+1)};
    	    			}
    	    			data[i]["_"+index+"_"+docIndex] = withDistributions=='relative' ? r.toFixed(7) : r;
    	    			data[i]["term"+index] = term;
    	    		}, this);

    	    		if (chartType!='bar') {
    	    			var kinds = chartType=='barline' ? ["bar","line"] : [chartType];
    	    			kinds.forEach(function(kind) {
    	    	        	series.push({
    	    	        		type: kind=='stacked' ? 'bar' : kind,
    	    	    			title: singleDoc ? term : (docIndex+1)+") "+term,
    	    	    			xField: 'index',
    	    	    			yField: '_'+index+"_"+docIndex,
    	    	    			term: term,
    	    	    			colors: [color],
    	    	    			label: chartType=='barline' && kind=='bar' ? {
    	    	    				display: 'none'
    	    	    			} : {
    	    	    				field: "term"+index
    	    	    			}
    	    	        	})
    	    			}, this);
    	    		}
    	    		
    			}, this);
    			
	    		if (chartType=='bar') {
	    			var isOneTerm = Ext.Array.unique(records.map(function(r) {return r.getTerm()})).length;
	    			var terms = records.map(function(r) {return (1+r.get("docIndex"))	+") "+r.getTerm()})
	    			var colors = records.map(function(r) {
		    			return  isOneTerm ? this.getApplication().getColor(r.get("docIndex"), true) : this.getApplication().getColorForTerm(r.getTerm(), true);
		    		}, this);

		    		series.push({
		    			type:'bar',
		    			title: terms.length>0 ? terms : this.localize("noResults"),
			    		colors: colors,
		    			xField: 'index',
		    			yField: data.length>0 ? Object.keys(data[0]).filter(function(field) {return field.charAt(0)=="_"}) : undefined,
		    			label: {
		    				field: terms
		    			}
		    		})
	    		}

    			
    	    	var store = Ext.create('Ext.data.JsonStore', {
    	    		fields: data.length>0 ? Object.keys(data[0]) : undefined,
    	    		data: data
    	    	});

    			this.buildChart({
        			store: store,
        			series: series,
        			axes: [{
                		type: 'numeric',
                		position: 'left',
                		title: {
                			text: this.localize(this.getApiParam("withDistributions")+"Title")
                		}
        			},{
        				type: 'category',
                		position: 'bottom',
                		title: {
                			text: this.localize("segmentsTitle") + (singleDoc ? " ("+singleDoc.getTitle()+")" : "")
                		}
                		
        			}]
    			})
    		},
    		scope: this
    	});
  
    },
	    
    getItemToolTip: function (toolTip, record, ctx) {
    	var parts = ctx.field.split("_"),
    		docIndex = parts.length==2 ? ctx.index : parts[2],
    		pos = parseInt(parts[1]),
    		title = ctx.series.getTitle(),
    		term = Ext.isArray(title) ? title[pos] : title,
    		colors = ctx.series.getColors(),
    		color = colors.length==1 ? colors[0] : colors[pos];
        var html = "<span class='x-legend-item-marker' style='background:"+color+
        		"; left: 2px;'></span> <span style='padding-left: 1.2em; font-weight: bold;'>"+
        		term+"</span>: "+record.get(ctx.field)+
    			"<br/><i>"+this.getCorpus().getDocument(docIndex).getShortTitle()+"</i>"
		if (this.getApiParam("mode")=="corpus") {
    		html+="<div style='font-size: smaller'>"+this.localize('dblClickItem')
		} else {
			html+="<br/>"+this.localize('segment')+" "+(ctx.index+1)
		}
    	toolTip.setHtml(html);
    },
    
    buildChart: function(config) {
    	var chartType = this.getApiParam('chartType'), labels = false;
    	if (this.getApiParam("labels")===true || this.getApiParam("labels")=="true") {labels=true}
    	
    	Ext.applyIf(config, {
    		cls: this.getApiParam("mode")
    	});

    	config.series.forEach(function(serie) {
    		Ext.applyIf(serie, {
				stacked: serie.type=='bar' ? false : true,
				showInLegend: chartType=='barline' && serie.type=='line' ? false : true,
    			smooth: true,
    			showMarkers: serie.type=='bar' ? false : true,
    			marker: chartType=='barline' && serie.type=='line' ? null : {
    			    type: 'circle',
    			    radius: 2
    			},
                style: {
                    lineWidth: 1,
                    fillOpacity: chartType=='barline' && serie.type=='bar' ? .01 : 1,
                    strokeOpacity: chartType=='barline' && serie.type=='bar' ? .1 : 1
                },
                highlight: true,
                highlightCfg: {
                	scaling: serie.type=="bar" ? 1.1 : 2
                },
    			label: {
//    				display: 'none'
    			},
    			tooltip: {
                    trackMouse: true,
                    renderer: this.getItemToolTip,
                    scope: this
    			},
                listeners: {
                	itemclick: function(chart,item,event,eOpts ) {
            			if (this.clickTimer) {clearTimeout(this.clickTimer);}
            			if (this.blockClick) {return;} // set by dblclick to avoid menu disappearing
            			this.blockClick = true // block other clicks within a sec
            			Ext.defer(function() {
            				this.blockClick = false;
            			}, 1000, this);
                		if (this.getApiParam("mode")=="document") {
                			var parts = item.field.split("_"),
                				docIndex = parseInt(parts[2]),
                				doc = this.getCorpus().getDocument(docIndex),
                				tokens = doc.get('tokensCount-lexical'),
                				position = parseInt(item.index  * tokens / parseInt(this.getApiParam("bins")))
                			this.dispatchEvent("documentIndexTermsClicked", this, [{
                    			term: item.series.term,
                    			docIndex: docIndex,
                    			position: position
                    		}]);
                		} else {
                			if (this.clickTimer) {clearTimeout(this.clickTimer);}
                			var me = this;
                			this.clickTimer = setTimeout(function() {
                    			me.dispatchEvent("documentIndexTermsClicked", me, [{
                        			term: item.series.term,
                        			docIndex: item.index
                        		}]);
                			}, 300)
                			
                		}
                	},
                	itemdblclick: function(chart,item,event,eOpts )  {
            			if (this.clickTimer) {clearTimeout(this.clickTimer);}
            			// block future single clicks to allow menu to appear
            			this.blockClick = true
            			Ext.defer(function() {
            				this.blockClick = false;
            			}, 1000, this);
            			// block future clicks
                		if (this.getApiParam("mode")!="document") {
                			var m = Ext.create('Ext.menu.Menu', {
                				items: [{
                	    				text: this.localize("drillTerm"),
                	    				tooltip: this.localize("drillTermTip"),
//                	    				glyph: 'xf02d@FontAwesome',
                	    				handler: function() {
                	    					this.setApiParams({
                	    						mode: 'document',
                	    						query: item.series.term
                	    					});
                	    					this.loadDocumentTerms();
                	    				},
                	    				scope: this
                					},{
                	    				text: this.localize("drillDocument"),
                	    				tooltip: this.localize("drillDocumentTip"),
//                	    				glyph: 'xf02d@FontAwesome',
                	    				handler: function() {
                	    					this.setApiParams({
                	    						mode: 'document',
                	    						docIndex: item.index
                	    					});
                	    					this.loadDocumentTerms();
                	    				},
                	    				scope: this
                					}],
                					listeners: {
                						hide: function(m) {
                							// defer hiding otherwise click handler not called
                							Ext.defer(function() {this.destroy()}, 200, m)
                						},
                						scope: this
                					}
                			}).showAt(event.pageX, event.pageY) 
                		}
                	},
                	scope: this
                }
    		})
    		Ext.applyIf(serie.label, {
                display: 'over',
                field: 'index',
                fontSize: 11,
                translateY: chartType=='line' ? 9 : undefined
    		});
    		if (!labels) {serie.label.display="none";} // hide label 
    	}, this)
    	Ext.applyIf(config, {
    		animation: true,
    	    plugins: {
    	        ptype: 'chartitemevents',
    	        moveEvents: true
    	    },
    		legend: {
    			docked:'top',
    			listeners: {
    				itemclick: function(legend, record, dom, index) {
    					// make sure to hide related series
    					if (legend.getStore().getCount()<legend.chart.series.length && this.getApiParam("chartType")=="barline") {
        					var term = record.get("name"), disabled = record.get("disabled");
        					legend.chart.series.forEach(function(serie) {
        						if (serie.getTitle()==term) {
        							serie.setHidden(disabled);
        							
        						}
        					})
        					legend.chart.redraw(); // not working?
    					}
    				},
    				scope: this
    			}
    		},
    		interactions: ['itemhighlight','crosszoom'],
    	    listeners: {}
    	});
    	Ext.applyIf(config.listeners, {
	        itemhighlightchange: function (chart, item) {
	            chart.el.dom.style.cursor = item ? 'pointer' : '';
	        },
	        afterrender : function() {
	        	return // TODO: this seems to cause problems, perhaps not destroying properly?
	        	Ext.defer(function() { // seem to need to defer
		        	Ext.tip.QuickTipManager.register({
		        		target: this.getTargetEl().down(".x-legend-container"),
	                 	text: this.localize("toggleTip")
		        	});
	        	},1, this)
	        	
	        },
	        scope: this
    	})
    	config.axes.forEach(function(axis) {
    		Ext.applyIf(axis, {
    			title: {},
    			label: {}
    		})
    		Ext.applyIf(axis.title, {scaling: .75});
    		Ext.applyIf(axis.label, {scaling: .75});
    		if (axis.type=='category') {
    			var titles = "";
    			config.store.each(function(r) {titles+=r.get("index")})
    			if (titles.length>this.getTargetEl().getWidth()/9) {
            		Ext.applyIf(axis.label, {rotate: {degrees:-30}});
    			}
        		Ext.applyIf(axis, {
        			labelInSpan: true
        		})
    		}
    	}, this)
    	    	
    	// remove existing chart
    	this.query('chart').forEach(function(chart) {this.remove(chart, true);}, this);
    	
    	// create new chart
		var chart = Ext.create("Ext.chart.CartesianChart", config);
    	this.add(chart);
    },
    
    reloadFromChart: function() {
    	var chart = this.down('chart');
    	if (chart) {
    		var terms = [];
    		chart.series.forEach(function(serie) {
    			terms.push(serie.getTitle());
    		});
    		this.fireEvent("termsClicked", this, terms);
    	}
    },

	getExtraDataExportItems: function() {
		return [
			{
				name: 'export',
				inputValue: 'dataAsTsv',
				boxLabel: this.localize('exportGridCurrentTsv')
			}
		]
	},

	exportDataAsTsv: function(panel, form) {
		var value = '';

		var chart = panel.down('chart');
		var store = chart.getStore();
		var firstModel = store.first();
		var data = firstModel.getData();

		var fields = ['Index'];
		
		var termKeys = Object.keys(data).filter(function(key) {
			return key.indexOf('term') === 0;
		}).sort();
		var terms = [];
		termKeys.forEach(function(termKey) {
			terms.push(data[termKey]);
		});
		
		fields = fields.concat(terms);
		value += fields.join("\t")+"\n";

		var valueKeys = Object.keys(data).filter(function(key) {
			return key.indexOf('_') === 0;
		}).sort();

		store.each(function(model) {
			data = model.getData();
			var entry = [];
			if (data['docTitle'] !== undefined) {
				entry.push(data['docTitle']);
			} else {
				entry.push(data['index']);
			}
			valueKeys.forEach(function(valueKey) {
				entry.push(data[valueKey]);
			});
			value += entry.join("\t")+"\n";
		}, panel);

		Ext.Msg.show({
			title: panel.localize('exportDataTitle'),
			message: panel.localize('exportDataTsvMessage'),
			buttons: Ext.Msg.OK,
			icon: Ext.Msg.INFO,
			prompt: true,
			multiline: true,
			value: value
		});
	}
 });
Ext.define('Voyant.panel.NoTool', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.notool',
    statics: {
    	i18n: {
    	},
    	api: {
    		tool: undefined
    	}
    },
    config: {
    	html: undefined,
    	notYetImplemented: ["Centroid","DocumentInputAdd","DocumentTypeCollocateFrequenciesGrid","EntitiesBrowser","Equalizer","FeatureClusters","Flowerbed","KwicsTagger","Lava","Mandala","MicroSearch","NetVizApplet","PaperDrill","RezoViz","Sunburst","Termometer","Ticker","TokensViz","ToolBrowser","ToolBrowserLarge","VoyeurTagline","WordCloud","VoyeurTagline","WordCountFountain"]
    },
    constructor: function() {
    	Ext.apply(this, {
    		title: this.localize('title')
    	});
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
	listeners: {
		boxready: function(container, width, height) {
			var tool = this.getApiParam("notool");

			if (tool) {
				if (Ext.isArray(tool)) {tool=tool[0]}
				
				var msg = "";
				
				// check to see if this is a tool that's recognized but not implemented
				var oldTools = this.getNotYetImplemented();
				for (var i=0, len=oldTools.length; i<len; i++) {
					if (tool==oldTools[i]) {
						return Ext.Msg.show({
						    title: this.localize('error'),
						    message: new Ext.Template(this.localize('notImplemented')).applyTemplate([tool]),
						    buttons: Ext.Msg.YESNO,
							buttonText: {yes: this.localize("currentButton"), no: this.localize("oldButton")},
						    icon: Ext.Msg.ERROR,
						    scope: this,
						    fn: function(btn) {
						    	var url;
						    	if (btn=='yes') {
						    		url = this.getNewUrl();
						    	}
						    	else {
						    		url = "http://voyant-tools.org/tool/"+tool+"/";
							    	var query = Ext.Object.fromQueryString(document.location.search)
							    	delete query['tool']
							    	queryString = Ext.Object.toQueryString(query);
							    	if (queryString) {
								    	url += "?"+queryString
							    	}
						    	}
						    	window.location.replace(url);
						    }
						});
					}
				}

				Ext.Msg.show({
				    title: this.localize('error'),
				    message: new Ext.Template(this.localize('badToolSpecified')).applyTemplate([tool]),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR,
				    scope: this,
				    fn: function(btn) {
				    	window.location.replace(this.getNewUrl());
				    }
				});
				
			}
			
			// no tool specified, so just redirect
			else if (!this.config.html) {
				Ext.Msg.show({
				    title: this.localize('error'),
				    message: this.localize('noToolSpecified'),
				    buttons: Ext.Msg.OK,
				    icon: Ext.Msg.ERROR,
				    scope: this,
				    fn: function(btn) {
				    	window.location.replace(this.getNewUrl());
				    }
				});
			}
		}
	},
	getNewUrl: function() {
    	var query = Ext.Object.fromQueryString(document.location.search)
    	delete query['tool']
    	queryString = Ext.Object.toQueryString(query);
    	return this.getApplication().getBaseUrl()+(queryString ? "?"+queryString : "")
	}
});
Ext.define('Voyant.panel.VoyantFooter', {
	extend: 'Ext.container.Container',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.voyantfooter',
    statics: {
    	i18n: {
    	}
    },
	height: 18,
	cls: 'x-tab-bar-default voyant-footer',
	listeners: {
		boxready: function(container, width, height) {
			var parts = [
				"<a href='"+container.getBaseUrl()+"docs/' target='voyantdocs'>"+container.localize('voyantTools')+"</a> ",
				", <a href='https://csdh-schn.org/stefan-sinclair-in-memoriam/'>St&eacute;fan Sinclair</a> &amp; <a href='https://geoffreyrockwell.com'>Geoffrey Rockwell</a>",
				" (<a href='https://creativecommons.org/licenses/by/4.0/' target='_blank'><span class='cc'>c</span></a> "+ new Date().getFullYear() +")",
				" <a class='privacy' href='"+this.getBaseUrl()+"docs/#!/guide/about-section-privacy-statement' target='top'>"+container.localize('privacy')+"</a>",
				" v. <a href='https://github.com/voyanttools/VoyantServer/releases/tag/"+Voyant.application.getVersion()+"' target='_blank'>"+Voyant.application.getVersion()+"</a>"
			];
			var footer = '';
			var footerWidth = 0;
			var partWidth;
			var el = container.getEl();
			for (var i=0;i<parts.length;i++) {
				partWidth = el.getTextWidth(parts[i].replace(/data-qtip.+?-->/,">").replace(/<.+?>/g, ""));
				if (footerWidth+partWidth < width) {
					footer += parts[i];
					footerWidth += partWidth;
				}
			}
			container.update(footer);
        	Ext.tip.QuickTipManager.register({
                target: container.getTargetEl().dom.querySelector(".privacy"),
                text: this.localize('privacyMsg')
            });
		},
		beforedestroy: function(container) {
    		Ext.tip.QuickTipManager.unregister(container.getTargetEl().dom.querySelector(".privacy"));
    	}
	}
});
Ext.define('Voyant.panel.VoyantHeader', {
	extend: 'Ext.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.voyantheader',
    statics: {
    	i18n: {
    	}
    },
    constructor: function(config) {
    	Ext.apply(this, {
    		id: 'voyantheader',
    		title: '',
    		layout : 'fit',
    		html: '<div id="logo-container"></div>',
    		collapseMode : undefined,
			collapsible: true,
			animCollapse: false,
			titleCollapse: false,
			floatable: false,
			header: true,
			hideCollapseTool: true,
			listeners: {
				collapse: this.onCollapse
			},
			titleAlign: 'center'
    	});
        this.callParent(arguments);
        
        Ext.applyIf(config, {
    		moreTools: ['corpusset','scatterplot','termsradio'],
			includeTools: {
				save: true,
				plus: true,
				help: true,
				language: this.getLanguageToolMenu(),
				home: {
					type: 'home',
					tooltip: this.localize("homeTip"),
					xtype: 'toolmenu',
	                glyph: 'xf015@FontAwesome',
	        		handler: function(btn) {
	        			var panel = this.up("panel")
	        			Ext.Msg.confirm(panel.localize('home'), panel.localize('homeConfirm'), function(buttonId) {
	        				if (buttonId=='yes') {
	        					document.location.href = panel.getBaseUrl()
	        				}
	        			}, this);
	        		}
				}
			}
        })
        
    	this.mixins['Voyant.panel.Panel'].constructor.call(this, config);
    },
    
    onCollapse: function(panel) {
    	// the title may be in flux when collapsing, so call defer setting of title
    	Ext.defer(function() {this.setTitle("<img src='"+this.getBaseUrl()+"resources/images/voyant-logo-tiny.png' style='vertical-align: middle' alt='Voyant Tools' /> "+this.localize('title'))}, 10, panel)
    }
});

Ext.define('Voyant.panel.CorpusSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.VoyantTabPanel','Voyant.panel.Cirrus', 'Voyant.panel.Summary', 'Voyant.panel.CorpusTerms', 'Voyant.panel.Reader', 'Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts', 'Voyant.panel.Phrases', 'Voyant.panel.DocumentTerms','Voyant.panel.CorpusCollocates','Voyant.panel.CollocatesGraph','Voyant.panel.StreamGraph','Voyant.panel.TermsBerry'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.corpusset',
	isConsumptive: true,
	statics: {
		i18n: {
		},
		api: {
			panels: undefined
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'border',
	header: false,
	items: [{
    	region: 'west',
    	flex: 3,
    	layout: 'fit',
        moreTools: ['cirrus','corpusterms'],
        xtype: 'voyanttabpanel',
    	split: {width: 5},
    	tabBarHeaderPosition: 0,
    	items: [{
	    	xtype: 'cirrus'
    	},{
	    	xtype: 'corpusterms'
    	}, {
    		xtype: 'collocatesgraph'
    	}]
    },{
        region: 'center',
        flex: 3,
        layout: 'fit',
        xtype: 'voyanttabpanel',
    	tabBarHeaderPosition: 0,
        items: [{
	        xtype: 'reader' // termsradio added and set to default during loadedCorpus below when in non-consumptive mode
        },{
	        xtype: 'termsberry'
        }]
    }, {
    	region: 'east',
    	flex: 3,
    	layout: 'fit',
        xtype: 'voyanttabpanel',
    	split: {width: 5},
    	tabBarHeaderPosition: 0,
    	moreTools: ['trends','collocatesgraph'],
        items: [{
	    	xtype: 'trends'
        },{
	    	xtype: 'documentterms'
        }]
    }, {
    	region: 'south',
    	flex: 2,
    	split: {width: 5},
    	layout: 'border',
//    	layout: {
//    		type: 'hbox',
//    		align: 'stretch'
//    	},
    	items: [{
				layout: 'fit',
				region: 'center',
    			flex: 1,
    	        xtype: 'voyanttabpanel',
    	    	split: {width: 5},
    	    	tabBarHeaderPosition: 0,
    			moreTools: ['summary','documents','phrases'],
    			items: [{
	    			xtype: 'summary'
    			},{
	    			xtype: 'documents'
    			},{
	    			xtype: 'phrases'
    			}]
    		},{
				layout: 'fit',
				region: 'east',
    			flex: 1,
    	        xtype: 'voyanttabpanel',
    	    	split: {width: 5},
    	    	tabBarHeaderPosition: 0,
    			moreTools: ['contexts','documentterms','correlations'],
    			items: [{
	    			xtype: 'contexts'
    			},{
	    			xtype: 'bubblelines' // is set to default during loadedCorpus below when in non-consumptive mode
    			},{
	    			xtype: 'corpuscollocates'
    			}]
    	}]
    }],
    listeners: {
    	boxready: function() {
    		var panelsString = this.getApiParam("panels");
    		if (panelsString) {
    			var panels = panelsString.toLowerCase().split(",");
    			var tabpanels = this.query("voyanttabpanel");
    			for (var i=0, len=panels.length; i<len; i++) {
    				var panel = panels[i];
    				if (panel && Ext.ClassManager.getByAlias('widget.'+panel) && tabpanels[i]) {
    					var tabpanel = tabpanels[i];
    					if (tabpanel.getActiveTab().isXType(panel)) {continue;} // already selected
    					tabpanel.items.each(function(item, index) {
    						if (item.isXType(panel)) {
    							this.setActiveTab(index)
    							return false
    						}
    					}, tabpanel)
    					if (tabpanel.getActiveTab().isXType(panel)) {continue;} // already switched
    					tabpanel.getActiveTab().replacePanel(panel); // switch to specified panel
    				}
    			}
    		}
    		// add an easter egg
    		var cirrus = this.down('cirrus');
    		var me = this;
    		if (cirrus) {
				var imageBaseUrl = this.getApplication().getBaseUrl()+'resources/images/';
    			var toolbar = cirrus.down('toolbar');
    			toolbar.add({xtype: 'tbfill'})
    			toolbar.add({
    				text: ' ',
    				listeners: {
    					click: {
    						fn: function() {
	        					me.add({
	        						region: 'north',
	        						width: '100%',
	    							html: '<div align="center"><table><tr><td><img src="'+imageBaseUrl+'stefan.jpg" style="height: 60px"></td><td style="text-align: center; padding-left: 2em; padding-right: 2em;">By Athena, you found us hidden<br>up here between the panels!</td><td><img src="'+imageBaseUrl+'geoffrey.jpg" style="height: 60px"></td></tr></table></div>'
	        					})
	        				}, single: true
    					},
    					render: function(b) {
    						b.getTargetEl().dom.className=''
    					}
    				}
    			});
    		}
    		
    	},
    	loadedCorpus: function(src, corpus) {
    		if (this.hasCorpusAccess(corpus)==false && !this.getApiParam('panels')) {
    			var tabpanels = this.query("voyanttabpanel");
//    			tabpanels[1].add({xtype: 'termsradio'}); // reader
    			tabpanels[1].setActiveTab(1); // reader
    			tabpanels[1].getActiveTab().fireEvent("loadedCorpus", src, corpus); // make sure to load corpus
    			tabpanels[4].setActiveTab(1); // contexts
    		}
    		if (corpus.getDocumentsCount()>30) {
    			var bubblelines = this.down('bubblelines');
    			if (bubblelines) {
    				bubblelines.up('voyanttabpanel').remove(bubblelines)
    			}
    		}
    	},
    	panelChange: function(src) {
    		var panels = [];
    		this.query("voyanttabpanel").forEach(function(item) {
    			panels.push(item.getActiveTab().xtype)
    		})
    		this.getApplication().setApiParam('panels', panels.join(','))
    	}
    }
})
Ext.define('Voyant.panel.ScatterSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.ScatterPlot','Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.scatterset',
	statics: {
		i18n: {
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'hbox',
	header: false,
	items: [{
    	flex: 3,
    	height: '100%',
        xtype: 'scatterplot'
    },{
    	split: {width: 5},
        flex: 1,
    	height: '100%',
        layout: 'vbox',
        defaults: {
        	width: '100%',
        	flex: 1
        },
        items: [{
        	xtype: 'documents',
        	collapsible: true
        },{
        	xtype: 'trends',
        	collapsible: true
        },{
        	xtype: 'contexts',
        	collapsible: true
        }]
    }]
})
Ext.define('Voyant.panel.Subset', { 
	
	
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel','Voyant.util.Downloadable'],
	alias: 'widget.subset',
	isConsumptive: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		documentFilename: ['pubDate','title'],
    		documentFormat: 'SOURCE'
    	},
		glyph: 'xf0ce@FontAwesome'
    },
    config: {
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
		inDocumentsCountOnly: false,
		stopList: 'auto',
		store: undefined
    },
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);    	
    },
    
    
    initComponent: function(config) {
        var me = this;

        Ext.applyIf(me, {
        	introHtml: '',
        	fieldItems: [{
	        		xtype: 'querysearchfield',
	        		fieldLabel: this.localize('titleLabel'),
	        		tokenType: 'title'
        		},{
	        		xtype: 'querysearchfield',
	        		fieldLabel: this.localize('authorLabel'),
	        		tokenType: 'author'
        		},{
	        		xtype: 'querysearchfield',
	        		fieldLabel: this.localize('lexicalLabel')
        	}],
        	fieldColumns: 2
        });
        
        Ext.applyIf(me, {
        	intro: {
        		margin: '5 0 5 0',
        		layout: 'center',
        		items: {
        			itemId: 'intro',
            		html: me.introHtml
        		}
        	},
        	fields: {
				xtype: 'container',
        		layout: 'center',
        		items: {
    				xtype: 'container',
        			maxWidth: 1200,
        			layout: {
        				type: 'table',
        				columns: me.fieldColumns
        			},
        			// wrap in another container otherwise the tip won't work
        			items: me.fieldItems.map(function(item) {return {
        				xtype: 'container',
            			defaults: {
            				margin: '5 10 5 10',
                    		inDocumentsCountOnly: me.getInDocumentsCountOnly(),
                    		stopList: me.getStopList(),
                    		showAggregateInDocumentsCount: true,
                    		isDocsMode: true,
                    		flex: 1,
                    		maxWidth: 800,
                    		labelAlign: 'right'
            			},
        				items: Ext.applyIf(item, {
        					fieldLabel: me.localize((item.tokenType ? item.tokenType : 'lexical')+'Label')
        				})
        			}}, this)
        		}
        	},
        	foot: {
        		layout: 'center',
        		margin: '20 0 0 0',
        		items: {
        			xtype: 'container',
        			layout: {
        				type: 'hbox',
        				align: 'middle'
        			},
        			defaults: {
    	        		margin: '0 5 0 5',
//    	        		scale: 'large',
    	        		width: 200
        			},
        			items:  [{
    	        		xtype: 'button',
    	        		itemId: 'export',
	                    glyph: 'xf08e@FontAwesome',
    	        		text: this.localize('sendToVoyantButton'),
    	        		handler: me.handleSendToVoyant,
    	        		scope: me
            		},{
    	        		xtype: 'button',
				    	glyph: 'xf019@FontAwesome',
    	        		itemId: 'download',
    	        		text: this.localize('downloadButton'),
    	        		handler: me.handleExport,
    	        		scope: me
            		},{
            			xtype: 'container',
            			hidden: true,
            			itemId: 'statuscontainer',
            			layout: 'vbox',
            			items: [{
            				itemId: 'status',
            				bodyStyle: 'text-align: center',
            				width: 200
            			},{
            				xtype: 'container',
            				width: 200,
            				items: {
            	    			xtype: 'sparklineline',
            	    			chartRangeMin: 0,
            	    			itemId: 'sparkline',
            	    			margin: '0 0 0 10',
            	    			values: [1,1],
            	    			height: 20,
            	    			width: 200
            				}
            			}]
            		}]
        		}
        	}
        })

        Ext.applyIf(me, {
        	items: [me.intro, me.fields, me.foot]
        });
        
    	me.on('loadedCorpus', function(src, corpus) {
    		me.getStore().setCorpus(corpus);
    		if (me.getInitialConfig('introHtml')==undefined && me.getInitialConfig('intro')==undefined) {
    			 me.queryById('intro').setHtml(corpus.getString())
    		}
    	}, me);
    	
    	me.on('query', function(src, queries) {
    		this.performAggregateQuery(this.getAggregateQuery());
    	});
    	
    	me.setStore(Ext.create('Voyant.data.store.DocumentQueryMatches'))
        me.callParent([config]);
        
    },
    
    handleSendToVoyant: function() {
    	if (!this.getStore().lastOptions || !this.getStore().lastOptions.params.query) {
    		// there's currently no query, so give the option of opening the current corpus in a new window
    		Ext.Msg.alert(this.localize('sendToVoyantButton'), new Ext.XTemplate(this.localize('sendToVoyantNoQuery')).apply([this.getBaseUrl()+"?corpus="+this.getStore().getCorpus().getId()]))
    	} else {
    		// try spawning a new corpus with the query
    		var me = this;
        	this.mask("Creating corpus…");
        	this.getStore().load({
        		params: {
        			query: this.getStore().lastOptions.params.query,
        			createNewCorpus: true
        		},
        		callback: function(records, operation, success) {
        			me.unmask();
        			if (success && records && records.length==1) {
            			var corpus = operation.getProxy().getReader().metaData;
        				var url = me.getBaseUrl()+"?corpus="+corpus;
        				me.openUrl(url);
        			}
        		}
        	})
    	}
    },
    
    handleExport: function() {
    	if (!this.getStore().lastOptions || !this.getStore().lastOptions.params.query) {
    		this.downloadFromCorpusId(this.getStore().getCorpus().getId());
    	} else {
    		var record = this.getStore().getAt(0);
    		if (this.getStore().lastOptions.params.query && record && record.getCount()==0) {
    			this.showMsg({message: this.localize('noMatches')})
    		} else {
    	    	this.getStore().load({
    	    		params: {
    	    			query: this.getStore().lastOptions.params.query,
    	    			createNewCorpus: true,
    	    			temporaryCorpus: true
    	    		},
    	    		callback: function(records, operation, success) {
    	    			if (success && records && records.length==1) {
    	    	    		this.downloadFromCorpusId(operation.getProxy().getReader().metaData);
    	    			}
    	    		},
    	    		scope: this
    	    	})
    		}
    	}
    },
    
    openDownloadCorpus: function(corpus) {
		var url = this.getTromboneUrl()+"?corpus="+corpus+"&tool=corpus.CorpusExporter&outputFormat=zip"+
			"&zipFilename=DownloadedVoyantCorpus-"+corpus+".zip"+
			(this.getApiParam("documentFormat") ? "&documentFormat="+this.getApiParam("documentFormat") : '')+
			(this.getApiParam("documentFilename") ? "&documentFilename="+this.getApiParam("documentFilename") : '')
		this.openUrl(url)
    },

    performAggregateQuery: function(query) {
    	var me = this, statuscontainer = me.queryById('statuscontainer'), status = me.queryById('status'), spark = me.queryById('sparkline');
		if (statuscontainer) {statuscontainer.show();}
		if (status) {status.setHtml(new Ext.XTemplate('{0:plural("documents")} matching.').apply([0]))}
		if (spark) {spark.setValues([0,0]);}
    	if (query) {
        	var docsCount = this.getStore().getCorpus().getDocumentsCount();
        	this.getStore().load({
        		params: {
        			query: query,
        			withDistributions: true,
        			bins: docsCount > 100 ? 100 : docsCount 
        		},
        		callback: function(records, operation, success) {
        			var exp = me.queryById('export');
        			var spark = me.queryById('sparkline');
        			if (success && records && records.length==1) {
        				if (status) {
        					status.setHtml(new Ext.XTemplate('{0:plural("document")} matching.').apply([records[0].getCount()]))
        				}
        				if (spark) {
            				spark.setValues(records[0].getDistributions())
        				}
        			}
        		}
        	})
    	} else if (this.getStore().lastOptions) { // set query to undefined so that send/export buttons work properly
    		this.getStore().lastOptions.params.query = undefined
    	}
    },
    
    getAggregateQuery: function() {
		var aggregateQueries = [];
		Ext.ComponentQuery.query('field', this).forEach(function(field) {
			if (field.getTokenType && field.getValue) {
				var tokenType = field.getTokenType();
				var vals = Ext.Array.from(field.getValue());
				if (vals.length>0) {
					if (vals.length>0) {
        				aggregateQueries.push("+("+vals.map(function(val) {
        					return tokenType+":"+val
        				}).join("|")+")");
					}
				}
			}
		})
		return aggregateQueries.join(" ");
    }
})

Ext.define('Voyant.panel.CollocatesSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.ScatterPlot','Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.collocatesset',
	statics: {
		i18n: {
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'vbox',
	header: false,
	items: [{
		layout: 'hbox',
		align: 'stretch',
		width: '100%',
		height: '100%',
		flex: 2,
        defaults: {
        	width: '100%',
        	height: '100%',
        	flex: 1,
        	frame: true,
        	border: true
        },
        items: [{
        	xtype: 'corpusterms'
        },{
        	xtype: 'documentterms'
        },{
        	xtype: 'corpuscollocates'
        }]
    },{
    	width: '100%',
    	height: '100%',
    	split: {width: 5},
		layout: 'hbox',
		flex: 3,
        defaults: {
        	width: '100%',
        	height: '100%',
        	flex: 1,
        	frame: true,
        	border: true
        },
        items: [{
        	xtype: 'contexts'
        },{
        	xtype: 'collocatesgraph'
        }]
    }]
})
Ext.define('Voyant.panel.BubblelinesSet', {
	extend: 'Ext.panel.Panel',
    requires: ['Voyant.panel.Bubblelines','Voyant.panel.Contexts', 'Voyant.panel.Reader'],
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.bubblelinesset',
	statics: {
		i18n: {
		},
		glyph: 'xf17a@FontAwesome'
	},
	constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},
	layout: 'vbox',
	header: false,
	items: [{
		width: '100%',
		height: '100%',
    	xtype: 'bubblelines',
    	flex: 5
    },{
    	width: '100%',
    	height: '100%',
    	split: {width: 5},
		layout: 'hbox',
		flex: 4,
        defaults: {
        	width: '100%',
        	height: '100%',
        	flex: 1,
        	frame: true,
        	border: true
        },
        items: [{
        	xtype: 'contexts'
        },{
        	xtype: 'reader'
        }]
    }]
})
Ext.define('Voyant.panel.CustomSet', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
    alias: 'widget.customset',
	statics: {
		i18n: {
		},
		api: {
			layout: undefined,
			tableLayout: undefined
		},
		glyph: 'xf17a@FontAwesome'
	},
	header: false,
	height: '100%',
	width: '100%',
	
    constructor: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments); // force api load
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
		if (this.getApiParam('layout')) {
			Ext.apply(this,{
				layout: 'border',
				items: []
			})
		} else if (this.getApiParam('tableLayout')) {
			this.initTableLayout();
		}
		this.callParent()
    },
	
	listeners: {
		loadedCorpus: function(src, corpus) {
			if (this.getApiParam('layout')) { // not sure why, but we seem to need to fire event for child panels
				this.query("panel").forEach(function(p) {
					p.fireEvent("loadedCorpus", src, corpus);
				})
			}
		},
		boxready: function(panel) {
			if (this.getApiParam('layout')) {
				this.initBorderLayoutComponents();
			} else if (this.getApiParam('tableLayout')) {
		    	this.doTableSizing();
		    	this.on('resize', function(panel, newwidth, newheight, oldwidth, oldheight) {
					if (oldwidth !== undefined && oldheight !== undefined) {
			        	var widthRatio = newwidth/oldwidth;
			        	var heightRatio = newheight/oldheight;
			        	this.doTableSizing(widthRatio, heightRatio);
					}
				}, this);
			} else {
				this.showError(this.localize('noLayoutSpecified'))
			}
		}
		
	},
	
	initBorderLayoutComponents: function() {
        var layoutString = decodeURI(this.getApiParam('layout'))
        	.replace(/r1/g, 'region')
	        .replace(/i1/g, 'items')
	        .replace(/s1/g, 'split')
	        .replace(/c1/g, 'collapsible')
	        .replace(/c2/g, 'collapsed')
	        .replace(/w1/g, 'width')
	        .replace(/h1/g, 'height')
	        .replace(/p1/g, '%')
	        .replace(/"x1":"/g, '"xtype":"')
	        .replace(/c3/g, 'center')
	        .replace(/n1/g, 'north')
	        .replace(/e1/g, 'east')
	        .replace(/s2/g, 'south')
	        .replace(/w2/g, 'west')
	    	.replace(/"xtype":"(\w+)"/g, function(match, tool) {
            	if (!Ext.ClassManager.getByAlias("widget."+tool.toLowerCase())) {
		            if (tool=="Links") {tool="CollocatesGraph";}
		            else if (tool=="CorpusGrid") {tool="Documents";}
		            else if (tool=="CorpusSummary") {tool="Summary";}
		            else if (tool=="CorpusTypeFrequenciesGrid") {tool="CorpusTerms";}
		            else if (tool=="DocumentInputAdd") {tool="CorpusTerms";}
		            else if (tool=="DocumentTypeCollocateFrequenciesGrid") {tool="CorpusTerms";}
		            else if (tool=="DocumentTypeFrequenciesGrid") {tool="DocumentTerms";}
		            else if (tool=="DocumentTypeKwicsGrid") {tool="Contexts";}
		            else if (tool=="TypeFrequenciesChart") {tool="Trends";}
		            else if (tool=="VisualCollocator") {tool="CollocatesGraph";}
		            else {tool="NoTool"}
            	}
            	return '"xtype":"'+tool.toLowerCase()+'"'+(tool=="NoTool" ? ',"html":"'+new Ext.Template(panel.localize('noSuchTool')).applyTemplate([tool])+'"' : '')
		    })
        
        var items;
        try {
            items = Ext.decode(layoutString);
        } catch (e) {
            items = {region: 'center', html: '<div>Error constructing layout:'+e+'</div>'};
        }
        
        if (items == null) {
        	items = {region: 'center', html: '<div>Error: no layout information found.</div>'}
        }
        
        this.addBorderLayouts(items);

        this.on("add", function(custom, cmp) {
        	cmp.on("boxready", function(cmp) {
//        		cmp.query("panel").forEach(function(p) {
//        			custom;
////        			debugger
//        		})
        	})
        })
        this.add(items);
//        .on("boxready", function() {
//        	debugger
//            if (this.getCorpus()) { // we may have loaded the corpus after the layout, so refire the event
//            	this.getApplication().dispatchEvent("loadedCorpus", this.getApplication(), corpus);
//            }
//        })
        
	},
	
	addBorderLayouts: function(items) {
    	var size = Ext.getBody().getSize();
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (Ext.isString(item.width)) {
            	item.width = Math.round(size.width * parseInt(item.width) / 100);
            } else if (Ext.isString(item.height)) {
            	item.height = Math.round(size.height * parseInt(item.height) / 100);
            }
            if (item.items && item.items.length > 1) {
                item.layout = 'border';
                this.addBorderLayouts(item.items);
            } else {
                item.layout = 'fit';
            }
        }
	},
	
	initTableLayout: function() {
    	Ext.suspendLayouts();
    	var tableLayout = decodeURI(this.getApiParam('tableLayout'));

    	if (tableLayout && tableLayout.charAt(0)!="{" && tableLayout.charAt(0)!="[") {
    		var cells = [];
    		tableLayout.replace(/;/g,",").split(/,\s*/).forEach(function(cell) {
    			cells.push(/^"'/.test(cell) ? cell : '"'+cell+'"');
    		});
    		tableLayout = "["+cells.join(",")+"]"; // treat as simple comma-separated string
    	}
    	var layout = Ext.decode(tableLayout);
    	if (Ext.isArray(layout)) {
    		layout = {
        		cells: layout
        	};
    	}
    	if (!layout.numCols && layout.cells && Ext.isArray(layout.cells)) {
    		if (layout.cells.length < 3) {
    			layout.numCols = layout.cells.length;
    		} else if (layout.cells.length < 5) {
    			layout.numCols = Math.ceil(layout.cells.length / 2);
    		} else {
    			layout.numCols = Math.ceil(layout.cells.length / 3);
    		}
    	}
        if (layout.numCols != null && layout.cells && Ext.isArray(layout.cells)) {
        	var items = [];
        	for (var i = 0; i < layout.cells.length; i++) {
        		var cell = layout.cells[i];
        		if (Ext.isObject(cell)) {
        			cell.cellWidth = parseFloat(cell.width) || undefined;
        			cell.cellHeight = parseFloat(cell.height) || undefined;
        			delete cell.width;
        			delete cell.height;
            		items.push(cell);
        		} else if (Ext.isArray(cell)) {
        			var colspan = 1, rowspan = 1; xtype = undefined;
        			if (cell[0] && Ext.isNumber(cell[0])) {
        				colspan = cell[0];
        				cell.shift();
        			}
        			if (cell[0] && Ext.isString(cell[0])) {
        				xtype = cell[0].toLowerCase();
        				cell.shift();
        			}
        			if (cell[0] && Ext.isNumber(cell[0])) {
        				rowspan = cell[0];
        			}
        			if (xtype) {
        				items.push({
        					colspan: colspan,
        					rowspan: rowspan,
        					xtype: xtype
        				})
        			}
        		} else if (Ext.isString(cell)) {
        			items.push({
        				xtype: cell.toLowerCase(),
        				colspan: 1,
        				rowspan: 1
        			})
        		}
        	}
        	Ext.apply(this, {
        		layout: {
        			type: 'table',
        			width: '100%',
    				height: '100%',
        			columns: layout.numCols,
        			tableAttrs: {
            			style: {
            				width: '100%',
            				height: '100%'
            			}
            		},
            		tdAttrs: {
            			style: {
            				padding: '0px',
            				verticalAlign: 'top'
            			}
            		}
        		},
        		defaults: { // place holder values to ensure that the children are rendered
            		width: 10,
            		height: 10,
            		border: true
            	},
        		items: items
        	});
        } else {
        	this.showError("badTableLayoutDefinition")
        }
    	
    	Ext.resumeLayouts();		
	},
	doTableSizing: function(widthRatio, heightRatio) {
    	var sizeMap = {};
    	
    	var table = this.getTargetEl().down(".x-table-layout");
    	var tableSize = table.getSize(false);
    	
    	var rows = table.dom.rows;
    	for (var i=0; i<rows.length; i++) {
    		var cells = rows[i].cells;
    		for (var j=0; j<cells.length; j++) {
    			var cell = cells[j];
    			var cellEl = Ext.get(cell);
    			var panelEl = cellEl.down('.x-panel');
    			var cmpId = panelEl.id;
    			
    			var size;
    			if (widthRatio !== undefined && heightRatio !== undefined) {
    				size = panelEl.getSize(false);
    				size.width = size.width * widthRatio;
            		size.height = size.height * heightRatio;
            		// FIXME multiple resize calls gradually reduce size
    			} else {
    				var sizeObj = cellEl.getSize(false);
    				
    				var cmp = Ext.getCmp(cmpId);
    				var widthPercent = cmp.initialConfig.cellWidth;
    				var heightPercent = cmp.initialConfig.cellHeight;
    				
    				if (widthPercent !== undefined) {
    					sizeObj.width = tableSize.width * (widthPercent/100);
    					cellEl.setWidth(sizeObj.width);
    				}
    				if (heightPercent !== undefined) {
    					sizeObj.height = tableSize.height * (heightPercent/100);
    					cellEl.setHeight(sizeObj.height);
    				}
    				
    				size = sizeObj; 
    			}
    			
    			sizeMap[cmpId] = size;
    		}
    	}
    	
    	for (var id in sizeMap) {
    		var size = sizeMap[id];
    		Ext.getCmp(id).setSize(size);
    	}

    	this.updateLayout();
	}
})
Ext.define('Voyant.panel.Veliza', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
    xtype: 'veliza',
	autoScroll: true,
    statics: {
    	i18n: {
    	},
    	api: {
    		script: '',
    		message: undefined
    	},
		glyph: 'xf0e6@FontAwesome'
    },
    config: {
    	previous: []
    },
    
    constructor: function() {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    	
        var me = this;
        Ext.apply(this, {
    		title: this.localize('title'),
    		glyph: 'xf0e6@FontAwesome',
    	    layout: {
    	        type: 'border',
    	        align: 'stretch'
    	    },
    		items: [{
    			itemId: 'chat',
	    		html: "<form class='chat'></form>",
	    		region: 'center',
	    		flex: 2,
	    		autoScroll: true
    		},{
    			itemId: 'script',
    			xtype: 'form',
    			region: 'east',
    			split: true,
    			title: this.localize('scriptEditor'),
        	    layout: {
        	        type: 'vbox',
        	        align: 'stretch'
        	    },
    			items: [{
    				html: new Ext.XTemplate(this.localize('scriptIntro')).apply([me.getBaseUrl()+"docs/#!/guide/veliza"])
    			},{
    				xtype: 'textarea',
    				name: 'editor',
    				fieldStyle: "white-space: pre",
    				value: me.getApiParam('script'),
    				flex: 1,
    				listeners: {
    					afterrender: function(editor) {
    						var corpus = me.getApiParam('corpus');
    						if (!corpus) {return}
    						editor.mask(me.localize('loadingScript'));
    						Ext.Ajax.request({
    							url: me.getTromboneUrl(),
    							params: {
    								tool: 'corpus.Veliza',
    								script: me.getApiParam('script'),
    								corpus: corpus
    							}
    						}).then(function(response) {
    							var obj = Ext.decode(response.responseText);
    							if (obj && obj.veliza && obj.veliza.script) {
    								editor.setValue(obj.veliza.script);
    								editor.resetOriginalValue();
    							} else if (obj && obj.veliza && obj.veliza.id) {
    								me.setApiParam('script', obj.veliza.id);
    							} else {
    								me.showError(me.localize('unableFetchScript'));
    							}
    							editor.unmask()
    						}, function(response) {
    							me.showError(response)
    						})
    					},
    					scope: this
    				}
    			}],
    			collapsed: true,
    			collapsible: true,
    			flex: 1
    		}],
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			xtype: 'textfield',
        			itemId: 'chatfield',
        			emptyText: this.localize("typeAndEnter"),
        			flex: 1,
        			listeners: {
                        specialkey: function(field, e){
                            if (e.getKey() == e.ENTER) {
                            	me.handleUserSentence(field.getValue())
                            	field.setValue("");
                            }
                        }
                    }
                },{
        			xtype: 'button',
        			text: this.localize('send'),
        			handler: function() {
        				var tf = this.up("toolbar").down('textfield');
        				me.handleUserSentence(tf.getValue(), false);
        				tf.setValue('');
        			}
        		},{
        			xtype: 'button',
        			text: this.localize('fromCorpus'),
        			handler: function() {
        				me.handleUserSentence("", true)
        			}
        		}]
    		}]
        })
             
        this.callParent();
        
    	this.on('boxready', function(cmp) {
    		cmp.addSentence("fromThem", "Hello, I'm Veliza, and I'm here to talk to you about your texts (you may know my sister <a href='https://en.wikipedia.org/wiki/ELIZA' target='_blank'>Eliza</a> she's a famous psychotherapist). I'm just learning to talk about text documents, but please, let me know about any anxieties you're feeling about your texts. Type a message in the box below and hit enter. Or, if you're feeling playful, hit the <i>from text</i> bottom in the lower right-hand corner to fetch a sentence from the corpus.");
    		this.sendApiParamMessage();
    	})

    }, 
    
    sendApiParamMessage: function() {
		if (this.getApiParam('message')) {
			if (this.getCorpus()) {
				var sentences = Ext.Array.from(this.getApiParam('message'));
				var sentence = sentences.shift();
				if (sentence) {
					if (sentences) {
						this.setApiParam("message", sentences);
					}
					this.handleUserSentence(sentence, undefined, true)
					
				}
			} else {
				// try to wait for the corpus to be loaded
				Ext.defer(this.sendApiParamMessage, 100, this, [true])
			}
		}
    },
    
    
    handleUserSentence: function(sentence, fromCorpus, noScroll) {
    	sentence = sentence.trim();
    	if (sentence || fromCorpus) {
    		if (sentence) {
    	    	this.addSentence("myMessage", sentence);
    		}
	    	this.mask();
    		var me = this;
    		var editor = this.getComponent('script').down('textarea');
    		Ext.Ajax.request({
    			url: this.getApplication().getTromboneUrl(),
    			params: {
    				corpus: me.getCorpus() ? me.getCorpus().getId() : undefined,
    				tool: 'corpus.Veliza',
    				sentence: sentence,
    				//previous: this.getPrevious(),
    				fromCorpus: fromCorpus ? true : false,
    				script: editor.isDirty() ? editor.getValue() : this.getApiParam('script'),
    				noCache: Ext.id()
    			},
    		    success: function(response, opts) {
    		    	me.unmask();
    		    	var response = Ext.decode(response.responseText);
    		    	if (response.veliza.id) {
    		    		me.setApiParam('script', response.veliza.id);
    		    		editor.resetOriginalValue();
    		    	}
    		    	var veliza = response.veliza.response;
    		    	var hidden = veliza.match(/<\!-- (.+?) -->/);
    		    	if (hidden) {
    		    		var json =  Ext.decode(hidden[1]);
    		    		for (key in json.params) {
    		    			json.params[key] = json.params[key].trim();
    		    		}
    		    		veliza += "<br/><iframe width='"+(json.width ? json.width : '100%')+"' height='"+(json.height ? json.height : '250px')+"' src='"+me.getApplication().getBaseUrl()+'tool/'+json.tool+'/?corpus='+me.getCorpus().getId()+'&minimal=true&'+Ext.Object.toQueryString(json.params)+"'></iframe>"
    		    	}
    		    	var sentence = response.veliza.sentence;
    		    	me.setPrevious(response.veliza.previous);

    		    	if (fromCorpus) {
    		    		meta = response.veliza.docIndex > -1 ? me.getCorpus().getDocument(response.veliza.docIndex).getShortLabel() : undefined;
    		    		me.addSentence("myMessage", sentence, meta);
        			    	Ext.Function.defer(function() {
                		    	this.addSentence("fromThem", veliza);
                		    	if (!noScroll) {
                    		    	this.body.scroll('b', Infinity)                		    		
                		    	}
        			    	}, 500, me);
    		    	} else {
        		    	me.addSentence("fromThem", veliza);
        		    	if (!noScroll) {
            		    	me.body.scroll('b', Infinity)                		    		
        		    	}
    		    	}
    		    	if (me.getApiParam("message")) { // any more messages to show?
    		    		me.sendApiParamMessage();
    		    	}
    		    },
    		    failure: function(response, opts) {
    		    	me.showResponseError("Unable to get response from Veliza.", response);
    		    }
    		})
    	}
    },

    addSentence: function(speaker, sentence, meta) {
    	var body = this.getComponent('chat').body;
    	var el = body.down("form").insertHtml('beforeEnd', '<div class="message"><div class="'+speaker+'"><p>'+sentence+'</p>'+(meta ? "<date>"+meta+"</date>" : "")+'</div></div>', true);
    	body.scroll('b', Infinity);
    }
});
Ext.define('Voyant.panel.WordTree', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.wordtree',
    statics: {
    	i18n: {
    	},
    	api: {
    		query: undefined,
    		docId: undefined,
    		docIndex: undefined,
    		stopList: 'auto',
    		context: 10,
    		limit: 100
    	},
		glyph: 'xf0e8@FontAwesome'
    },
    
    config: {
    	tree: undefined,
    	kwicStore: undefined,
    	options: [{xtype: 'stoplistoption'},{xtype: 'categoriesoption'}],
    	numBranches: 5,
    	lastClick: 1
    },
    
    doubleClickDelay: 300,
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
                	xtype: 'querysearchfield'
                },
                	'<span data-qtip="'+this.localize('poolTip')+'" class="info-tip">'+this.localize('pool')+"</span>"
                , {
                	xtype: 'slider',
                	itemId: 'poolSlider',
                	minValue: 10,
                	value: 100,
                	maxValue: 1000,
                	increment: 5,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getApiParam('limit'));
                		},
                		changecomplete: function(slider, newValue) {
                			this.setApiParam('limit', slider.getValue());
                			this.reload();
                		},
                		scope: this
                	}
                }, 
                	'<span data-qtip="'+this.localize('branchesTip')+'" class="info-tip">'+this.localize('branches')+"</span>"
    			,{
                
                	xtype: 'slider',
                	itemId: 'branchesSlider',
                	minValue: 2,
                	value: 5,
                	maxValue: 15,
                	increment: 1,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getNumBranches());
                		},
                		changecomplete: function(slider, newValue) {
                			this.setNumBranches(slider.getValue());
                			this.reload();
                		},
                		scope: this
                	}
                },
            	'<span data-qtip="'+this.localize('contextTip')+'" class="info-tip">'+this.localize('context')+"</span>"
            	, {
                	xtype: 'slider',
                	itemId: 'contextSlider',
                	minValue: 3,
                	value: 10,
                	maxValue: 20,
                	increment: 2,
                	width: 50,
                	listeners: {
                		render: function(slider) {
                			slider.setValue(this.getApiParam('context'));
                		},
                		changecomplete: function(slider, newValue) {
                			this.setApiParam('context', slider.getValue());
                			this.reload();
                		},
                		scope: this
                	}
                }]
    		}]
        });
        
        this.setKwicStore(Ext.create('Voyant.data.store.Contexts', {
        	parentPanel: this,
        	proxy: {
        		extraParams: {
                	stripTags: 'all'            			
        		}
        	},
        	listeners: {
        		load: function(store, records, success, operation) {
        			if (success) {
        				this.parseRecords(records);
        			}
        		},
        		scope: this
        	}
        }));
        
        this.on('loadedCorpus', function(src, corpus) {
        	var corpusTerms = corpus.getCorpusTerms({autoLoad: false});
    		corpusTerms.load({
    		    callback: function(records, operation, success) {
    		    	if (success && records.length>0) {
    		    		var firstTerm = records[0].getTerm();
    		    		this.setRoot(firstTerm);
    		    	}
    		    },
    		    scope: this,
    		    params: {
    				limit: 1,
    				query: this.getApiParam('query'),
    				stopList: this.getApiParam('stopList'),
					categories: this.getApiParam('categories')
    			}
        	});
        }, this);
        
        this.on('query', function(src, query) {
    		if (query !== undefined && query != '') {
    			this.setRoot(query);
    		}
        }, this);
        
        this.on('termsClicked', function(src, terms) {
        	var queryTerms = [];
    		terms.forEach(function(term) {
    			if (Ext.isString(term)) {queryTerms.push(term);}
    			else if (term.term) {queryTerms.push(term.term);}
    			else if (term.getTerm) {queryTerms.push(term.getTerm());}
    		});
    		this.setRoot(queryTerms);
		}, this);
        
        this.on('documentTermsClicked', function(src, terms) {
    		var queryTerms = [];
    		terms.forEach(function(term) {
    			if (term.getTerm()) {queryTerms.push(term.getTerm());}
    		});
    		this.setRoot(queryTerms);
    	}, this);
        
        this.on('resize', function(panel, width, height) {
        	var tree = this.getTree();
        	if (tree !== undefined) {
        		tree.visWidth(width).visHeight(height);
        		// TODO preserve expanded branches
        		tree.redraw();
        	}
		}, this);
        
        this.on('boxready', this.initGraph, this);
        
        this.callParent(arguments);
    },
    
    parseRecords: function(records) {
    	var parsedRecords = [];
		for (var i = 0; i < records.length; i++) {
			var r = records[i];
			var pr = {
				id: i,
				prefix: r.getLeft().trim().split(/\s+/),
				hit: r.getMiddle(),
				suffix: r.getRight().trim().split(/\s+/)
			};
			parsedRecords.push(pr);
		}
		
		// find top tokens and sort records by them
		var prefixTokenCounts = {};
		var suffixTokenCounts = {};
		for (var i = 0; i < parsedRecords.length; i++) {
			var pr = parsedRecords[i];
			var prefixToken = pr.prefix[pr.prefix.length-1];
			var suffixToken = pr.suffix[0];
			if (prefixTokenCounts[prefixToken]) {
				prefixTokenCounts[prefixToken]++;
			} else {
				prefixTokenCounts[prefixToken] = 1;
			}
			if (suffixTokenCounts[suffixToken]) {
				suffixTokenCounts[suffixToken]++;
			} else {
				suffixTokenCounts[suffixToken] = 1;
			}
		}
		
		var sortableTokens = [];
		for (var i = 0; i < parsedRecords.length; i++) {
			var pr = parsedRecords[i];
			var prefixToken = pr.prefix[pr.prefix.length-1];
			var suffixToken = pr.suffix[0];
			
			sortableTokens.push({
				suffix: suffixToken, suffixCount: suffixTokenCounts[suffixToken],
				prefix: prefixToken, prefixCount: prefixTokenCounts[prefixToken]
			});
			
		}
		
		var prioritizeSuffix = false;
		// multi-sort
		sortableTokens.sort(function(a, b) {
			var s1 = a.suffixCount;
			var s2 = b.suffixCount;
			
			var p1 = a.prefixCount;
			var p2 = b.prefixCount;
			
			if (prioritizeSuffix) {
				if (s1 > s2) return -1;
				if (s1 < s2) return 1;
				if (p1 > p2) return -1;
				if (p1 < p2) return 1;
			} else {
				if (p1 > p2) return -1;
				if (p1 < p2) return 1;
				if (s1 > s2) return -1;
				if (s1 < s2) return 1;
			}
			
			return 0;
		});
		
		var len = Math.min(this.getNumBranches(), sortableTokens.length);
		var topSuffixTokens = [];
		var topPrefixTokens = [];
		for (var i = 0; i < len; i++) {
			topSuffixTokens.push(sortableTokens[i].suffix);
			topPrefixTokens.push(sortableTokens[i].prefix);
		}
		
		// use top tokens to limit results
		var prefixes = [], hits = [], suffixes = [], ids = [];
		for (var i = 0; i < parsedRecords.length; i++) {
			var parsedRecord = parsedRecords[i];
			if (topSuffixTokens.indexOf(parsedRecord.suffix[0]) != -1 || topPrefixTokens.indexOf(parsedRecord.suffix[0]) != -1) {
				prefixes.push(parsedRecord.prefix);
				hits.push(parsedRecord.hit);
				suffixes.push(parsedRecord.suffix);
				ids.push(parsedRecord.id);
			}
		}
		
		var caseSensitive = false;
		var fieldNames = ["token", "POS"];
		var fieldDelim = "/";
		var distinguishingFieldsArray = ["token", "POS"];
		this.getTree().setupFromArrays(prefixes, hits, suffixes, ids, caseSensitive, fieldNames, fieldDelim, distinguishingFieldsArray);
		
		if (!this.getTree().succeeded()) {
			this.toastInfo({
   				html: this.localize("emptyText"),
   				align: 'bl'
   			});
		}
    },
    
    initGraph: function() {
    	var el = this.getLayout().getRenderTarget();
    	var w = el.getWidth();
    	var h = el.getHeight();
    	
    	var dt = new doubletree.DoubleTree();
    	dt.init('#'+el.getId())
    		.visWidth(w).visHeight(h)
    		.handlers({
    			click: this.clickHandler.bind(this)
    		});
    	
    	this.setTree(dt);
    	
    	// explicitly set dimensions
//    	el.setWidth(el.getWidth());
//    	el.setHeight(el.getHeight());
    },
    
    clickHandler: function(node) {
    	var now = new Date().getTime();
    	if (this.getLastClick() && now-this.getLastClick()<this.doubleClickDelay) {
    		this.setLastClick(1);
    		var terms = [], parent = node;
        	while (parent != null) {
        		terms.push(parent.name);
        		parent = parent.parent;
        	}
        	this.getApplication().dispatchEvent('termsClicked', this, [terms.reverse().join(" ")]);
    	} else {
    		this.setLastClick(now);
    	}
    },
    
//    doubleClickHandler: function(node) {
//// dispatch phrase click instead of recentering (which can be done with search)
////    	this.setRoot(node.name);
//    },
//    
    setRoot: function(query) {
    	this.setApiParam('query', this.stripPunctuation(query));
		this.getKwicStore().load({params: this.getApiParams()});
    },
    
    reload: function() {
    	var query = this.getApiParam('query');
    	if (query !== undefined) {
    		this.setRoot(query);
    	}
    },
    
    stripPunctuation: function(value) {
    	if (Ext.isString(value)) return value.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '');
    	else {
    		var values = [];
    		value.forEach(function(v) {
    			values.push(v.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, ''));
    		});
    		return values;
    	}
    	return '';
    }
});


Ext.define('Voyant.panel.WordWall', {
    extend: 'Ext.panel.Panel',
    mixins: ['Voyant.panel.Panel','Voyant.util.DiacriticsRemover'],
    alias: 'widget.wordwall',
    statics: {
        i18n: {
        },
        api: {
            limit: 500,
            stopList: 'auto'
        },
        glyph: 'xf1e0@FontAwesome'
    },
    
    config: {
        visId: undefined,
        vis: undefined,
        simulation: undefined, // force layout
        nodes: undefined, // svg nodes
        tempNodes: undefined, // used to calculate text size and bounding boxes
        zoom: undefined,

        terms: undefined,
        segments: undefined,

        filterOutUniqueTerms: true, // whether to remove terms that don't appear in all segments

        currentSegment: undefined,
        segmentTerms: undefined,
        segmentTermsQueue: [],

        segmentDelay: 5000, // delay before displaying new segment data
        segmentDelayTimer: undefined,
        
        webWorker: undefined,
        isSimulating: false, // are we running a webworker simulation?
        
        transitionTime: 2000, // time to transition between old and new nodes
        isTransitioning: false, // are we transitioning between nodes?
        

        minFreq: undefined,
        maxFreq: undefined,
        letterDistribution: undefined,
        
        frequencyScale: undefined,

        xForceStrength: 0.2,
        yForceStrength: 0.1,
        
        chargeStrength: -75,
        chargeDistance: 100,

        minFontSize: 7,
        maxFontSize: 60
    },

    count: 0,

    MIN_TERMS: 10,
    MAX_TERMS: 2000,
    
    MIN_SCALING: 1,
    MAX_SCALING: 20,
    
    debugMsg: false,

    constructor: function(config) {
        this.mixins['Voyant.util.DiacriticsRemover'].constructor.apply(this, arguments);

        this.setVisId(Ext.id(null, 'wordwall_'));

        this.callParent(arguments);
        this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function() {
        Ext.apply(this, {
            title: this.localize('title'),
            dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [this.localize('terms'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: this.MIN_TERMS,
                    maxValue: this.MAX_TERMS,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getApiParam('limit'));
                        },
                        changecomplete: function(slider, newValue) {
                            this.setApiParam('limit', slider.getValue());
                            this.initLoad();
                        },
                        scope: this
                    }
                },this.localize('delay'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 1,
                    maxValue: 60,
                    increment: 1,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getSegmentDelay()/1000);
                        },
                        changecomplete: function(slider, newValue) {
                            this.setSegmentDelay(slider.getValue()*1000);
                            this.restartSegmentTimer();
                        },
                        scope: this
                    }
                },this.localize('transition'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 100,
                    maxValue: 5000,
                    increment: 1,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getTransitionTime());
                        },
                        changecomplete: function(slider, newValue) {
                            this.setTransitionTime(slider.getValue());
                        },
                        scope: this
                    }
                },this.localize('xStrength'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 0,
                    maxValue: 1000,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getXForceStrength()*1000);
                        },
                        changecomplete: function(slider, newValue) {
                            this.setXForceStrength(slider.getValue()/1000);
                        },
                        scope: this
                    }
                },this.localize('yStrength'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 0,
                    maxValue: 1000,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getYForceStrength()*1000);
                        },
                        changecomplete: function(slider, newValue) {
                            this.setYForceStrength(slider.getValue()/1000);
                        },
                        scope: this
                    }
                },this.localize('chargeStrength'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: -1000,
                    maxValue: 0,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getChargeStrength());
                        },
                        changecomplete: function(slider, newValue) {
                            this.setChargeStrength(slider.getValue());
                        },
                        scope: this
                    }
                },this.localize('chargeDistance'),{
                    width: 50,
                    xtype: 'slider',
                    minValue: 0,
                    maxValue: 1000,
                    increment: 10,
                    listeners: {
                        render: function(slider) {
                            slider.setValue(this.getChargeDistance());
                        },
                        changecomplete: function(slider, newValue) {
                            this.setChargeDistance(slider.getValue());
                        },
                        scope: this
                    }
                },{
                    xtype: 'button',
                    text: this.localize('stop'),
                    handler: function(b) {
                        if (b.getText() === this.localize('stop')) {
                            clearInterval(this.getSegmentDelayTimer());
                            b.setText(this.localize('start'))
                        } else {
                            this.restartSegmentTimer();
                            b.setText(this.localize('stop'));
                        }
                    },
                    scope: this
                },{
                    itemId: 'status',
                    xtype: 'tbtext',
                    text: ''
                }]
            }]
        });
        
        this.on('loadedCorpus', function(src, corpus) {
            if (this.isVisible()) {
                this.initLoad();
            }
        }, this);
        
        this.on('resize', function(panel, width, height) {
            var vis = Ext.get(this.getVisId());
            if (vis) {
                var el = this.body;//this.getLayout().getRenderTarget();
                var elHeight = el.getHeight();
                var elWidth = el.getWidth();
                
                vis.el.dom.setAttribute('width', elWidth);
                vis.el.dom.setAttribute('height', elHeight);
//                this.getSimulation()
//                    .force('x', d3.forceX(elWidth/2))
//                    .force('y', d3.forceY(elHeight/2));
            }
        }, this);
        
        this.callParent(arguments);
    },
    
    initVis: function() {
        var el = this.getLayout().getRenderTarget();
        el.update('');
        var width = el.getWidth();
        var height = el.getHeight();

        var svg = d3.select(el.dom).append('svg').attr('id',this.getVisId()).attr('class', 'wordWall').attr('width', width).attr('height', height);
        var g = svg.append('g');
        this.setVis(g);
        
        this.setNodes(g.append('g').attr('class', 'nodes').selectAll('.node'));

        this.setTempNodes(g.append('g').attr('class', 'tempNodes').selectAll('text'));

        if (this.getWebWorker() === undefined) {
            this.setWebWorker(new Worker(this.getBaseUrl()+'resources/d3/WordWallWorker.js'));
            this.getWebWorker().onmessage = this.handleWebWorkerMessage.bind(this);
        }
    },

    initLoad: function() {
        this.initVis();
        
        this.count = 0;

        var params = this.getApiParams();
        params.tool = 'corpus.CorpusSegmentTerms';
        
        Ext.Ajax.request({
            url: this.getTromboneUrl(),
            params: params,
            success: function(response) {
                var data = Ext.decode(response.responseText);
                this.setSegments(data.corpusSegmentTerms.segments);

                var terms = data.corpusSegmentTerms.terms;
                if (this.getFilterOutUniqueTerms()) {
                    terms = terms.filter(function(el, index) { return el.rawFreqs.indexOf(0) == -1 });
                }

                this.setTerms(terms);
                
                this.setCurrentSegment(this.getSegments().length);
                this.getNextSegment();

                this.restartSegmentTimer();
            },
            failure: function(response) {
                if (this.debugMsg) console.log('failed', response);
            },
            scope: this
        })
    },

    restartSegmentTimer: function() {
        clearInterval(this.getSegmentDelayTimer());

        this.setSegmentDelayTimer(setInterval(function() {
            this.updateNodePositions();
        }.bind(this), this.getSegmentDelay()));
    },

    getNextSegment: function() {
        var index = this.getCurrentSegment();
        index++;
        if (index >= this.getSegments().length) {
            index = 0;
        }
        this.setCurrentSegment(index);
        if (this.debugMsg) console.log('getNextSegment', index);
        this.processTermsForSegment(this.getCurrentSegment());
    },

    processTermsForSegment: function(segmentIndex) {
        var min = Number.MAX_VALUE;
        var max = Number.MIN_VALUE;
        var letterDistMap = {a:0,b:0,c:0,d:0,e:0,f:0,g:0,h:0,i:0,j:0,k:0,l:0,m:0,n:0,o:0,p:0,q:0,r:0,s:0,t:0,u:0,v:0,w:0,x:0,y:0,z:0};

        this.getTerms().forEach(function(d) {
            d.id = this.idGet(d.term);
            // d.value = d.rawFreqs.reduce(function(sum, value) {
            //     return sum+value;
            // });
            d.value = d.rawFreqs[segmentIndex];
            if (d.value > 0) {
                if (d.value < min) {
                    min = d.value;
                }
                if (d.value > max) {
                    max = d.value;
                }

                d.title = d.term+' ('+d.value+')';

                var firstLetter = this.removeDiacritics(d.term.charAt(0)).toLowerCase();
                d.letter = firstLetter;
                if (letterDistMap[firstLetter] === undefined) {
                    letterDistMap[firstLetter] = 0;
                }
                letterDistMap[firstLetter]++;
            }
        }, this);

        this.setSegmentTerms(this.getTerms().filter(function(d) {
            return d.value > 0;
        }));

        this.setMinFreq(min);
        this.setMaxFreq(max);

        var letterDist = [];
        for (var letter in letterDistMap) {
            var count = letterDistMap[letter];
            var percent = count / this.getTerms().length;
            letterDist.push({letter: letter, percent: percent});
        }
        letterDist.sort(function(a, b) {
            if (a.letter < b.letter) return -1;
            if (a.letter > b.letter) return 1;
            return 0;
        });
        this.setLetterDistribution(letterDist);

        this.calculateNodeSizes(this.getSegmentTerms());
        this.runSimulation(this.getSegmentTerms());
    },

    // determine each node's font size and bounding box and store them for later use
    calculateNodeSizes: function(terms) {
        var nodes = this.getTempNodes().data(terms, function(d) { return d.id; });
        
        var fontSizer = function(value) {
            var t = Math.min(1, terms.length / this.MAX_TERMS);
            var exponent = t*2+1;
            value = this.getFrequencyScale()(value);
            var val = d3.scalePow().exponent(exponent).domain([0, 1]).range([this.getMinFontSize(), this.getMaxFontSize()])(value);
            return val;
        }.bind(this);

        var bboxTotal = 0;

        nodes.enter().append('text')
            .attr('fill-opacity', 0)
            .attr('font-family', function(d) { return 'Arial'; })//return me.getApplication().getCategoriesManager().getFeatureForTerm('font', d.term); })
            .attr('font-size', function(d) {
                var fontSize = fontSizer(d.value);
                d.fontSize = fontSize;
                return fontSize;
            })
            .text(function(d) { return d.term; })
            .each(function(d) {
                var bbox = this.getBBox();
                d.bbox = {};
                d.bbox.x = bbox.x;
                d.bbox.y = bbox.y;
                d.bbox.width = bbox.width;
                d.bbox.height = bbox.height;

                bboxTotal += bbox.width*bbox.height;
            })
            .remove();

        var el = this.getLayout().getRenderTarget();
        var width = el.getWidth();
        var height = el.getHeight();

        // adapt font size to available space
        var availableSpace = width*height;
        if (bboxTotal > availableSpace*0.6) {
            this.setMaxFontSize(this.getMaxFontSize()*0.9);
            this.setMinFontSize(this.getMinFontSize()*0.9);
            this.calculateNodeSizes(terms);
        } else if (bboxTotal < availableSpace*0.5) {
            this.setMaxFontSize(this.getMaxFontSize()*1.1);
            this.setMinFontSize(this.getMinFontSize()*1.1);
            this.calculateNodeSizes(terms);
        }
    },

    runSimulation: function(terms) {
        this.setIsSimulating(true);

        var el = this.getLayout().getRenderTarget();
        var width = el.getWidth();
        var height = el.getHeight();

        // pass all the info to the worker
        if (this.debugMsg) console.time("runSim");
        this.getWebWorker().postMessage({
            terms: terms,
            width: width,
            height: height,
            minFreq: this.getMinFreq(),
            maxFreq: this.getMaxFreq(),
            xForceStrength: this.getXForceStrength(),
            yForceStrength: this.getYForceStrength(),
            chargeDistance: this.getChargeDistance(),
            chargeStrength: this.getChargeStrength(),
            letterDistribution: this.getLetterDistribution()
        });
    },

    handleWebWorkerMessage: function(event) {
        switch (event.data.type) {
            case "progress":
                var t = event.data.progress;
                var percent = parseInt(t * 100);
                this.getDockedItems()[1].getComponent('status').update(percent+'%');
                break;
            case "msg":
                if (this.debugMsg) console.log(event.data.msg);
                break;
            case "end":
                if (this.debugMsg) console.timeEnd("runSim");
                // TODO adjust segment delay if it's less than the runSim time
                this.getDockedItems()[1].getComponent('status').update('');
                this.setIsSimulating(false);
                this.getSegmentTermsQueue().push(event.data.nodes);
                break;
        }
    },

    updateNodePositions: function() {
        if (this.getIsTransitioning()) {
            Ext.Function.defer(this.updateNodePositions, 100, this);
        } else {
            this.count++;
            var nodes = this.getSegmentTermsQueue().shift();
            if (this.debugMsg) console.log('queue length', this.getSegmentTermsQueue().length);
            if (nodes === undefined) {
                if (this.debugMsg) console.log('no nodes', this.count);
                if (this.getIsSimulating() === false) {
                    this.getNextSegment();
                }
            } else {
                this.setIsTransitioning(true);
                if (this.getSegmentTermsQueue().length == 0) {
                    this.getNextSegment();
                }
                
                var nodeUpdate = this.getNodes().data(nodes, function(d) { return d.id; });

                nodeUpdate.transition().duration(this.getTransitionTime()).attr('transform', function(d) {
                    var x = d.x;
                    var y = d.y;
                    return 'translate('+x+','+y+')';
                });

                var nodeEnter = nodeUpdate.enter().append('g')
                    .attr('class', 'node')
                    .attr('id', function(d) { return d.id; })
                    .attr('transform', function(d) {
                        var x = d.x;
                        var y = d.y;
                        return 'translate('+x+','+y+')';
                    })
                    .attr('fill-opacity', 0);

                nodeEnter.append('title').text(function(d) { return d.title; });

                nodeEnter.append('text')
                    .attr('font-family', function(d) { return 'Arial'; })//return me.getApplication().getCategoriesManager().getFeatureForTerm('font', d.term); })
                    .attr('font-size', function(d) { return d.fontSize; })
                    .attr('fill', function(d) { return this.getApplication().getCategoriesManager().getFeatureForTerm('color', d.term); }.bind(this))
                    .style('cursor', 'pointer')
                    .style('user-select', 'none')
                    .attr('alignment-baseline', 'middle')
                    .text(function(d) { return d.term; });

                nodeEnter.transition().duration(this.getTransitionTime()).attr('fill-opacity', 1);

                var allNodes = nodeEnter.merge(nodeUpdate);

                allNodes.select('text').transition().duration(this.getTransitionTime())
                    .attr('font-size', function(d) { return d.fontSize; });

                nodeUpdate.exit().transition().duration(this.getTransitionTime()).attr('fill-opacity', 0).remove();

                setTimeout(function() {
                    this.setIsTransitioning(false);
                }.bind(this), this.getTransitionTime());

                this.setNodes(allNodes);
            }
        }
    },

    updateMinFreq: function() {
        this.setFrequencyScale(d3.scaleLog().domain([this.getMinFreq(), this.getMaxFreq()]).range([0, 1]));
    },

    updateMaxFreq: function() {
        this.setFrequencyScale(d3.scaleLog().domain([this.getMinFreq(), this.getMaxFreq()]).range([0, 1]));
    },

    zoomToFit: function(paddingPercent, transitionDuration) {
    	var bounds = this.getVis().node().getBBox();
    	var width = bounds.width;
    	var height = bounds.height;
    	var midX = bounds.x + width/2;
    	var midY = bounds.y + height/2;
    	var svg = this.getVis().node().parentElement;
    	var fullWidth = svg.clientWidth;
    	var fullHeight = svg.clientHeight;
    	var scale = (paddingPercent || 0.8) / Math.max(width/fullWidth, height/fullHeight);
    	var translate = [fullWidth/2 - scale*midX, fullHeight/2 - scale*midY];
 
    	d3.select(svg)
    		.transition()
    		.duration(transitionDuration || 500)
    		.call(this.getZoom().transform, d3.zoomIdentity.translate(translate[0],translate[1]).scale(scale));
    },
    
    idGet: function(term) {
        return term.replace(/\W/g, '_');
    }
    
});
Ext.define('Voyant.panel.Topics', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.topics',
	statics: {
		i18n: {
			topics: 'Topics',
			documents: 'Documents',
			topicWeight: 'Topic weight'
		},
		api: {
			stopList: 'auto',
			topics: 10,
			termsPerTopic: 10,
			iterations: 100,
			perDocLimit: 1000,
			seed: 0
		},
		glyph: 'xf1ea@FontAwesome'
	},
	config: {
		/**
		 * @private
		 */
		options: [{xtype: 'stoplistoption'},{
			xtype: 'numberfield',
			name: 'perDocLimit',
			fieldLabel: 'maximum words per document',
			labelAlign: 'right',
			value: 1000,
			minValue: 1,
			step: 100,
			listeners: {
				afterrender: function(field) {
					var win = field.up("window");
					if (win && win.panel) {
						field.setValue(parseInt(win.panel.getApiParam('perDocLimit')))
						field.setFieldLabel(win.panel.localize("perDocLimit"))
					}
				},
				change: function(field, val) {
					var win = field.up("window");
					if (val>5000 && win && win.panel) {
						win.panel.toastInfo({
							html: win.panel.localize("perDocLimitHigh"),
							anchor: win.getTargetEl(),
							align: 'tr',
							maxWidth: 400
						})
					}
				}
			}
		},{
			xtype: 'numberfield',
			name: 'iterations',
			fieldLabel: 'iterations per run',
			labelAlign: 'right',
			value: 100,
			minValue: 50,
			maxValue: 1000,
			step: 50,
			listeners: {
				afterrender: function(field) {
					var win = field.up("window");
					if (win && win.panel) {
						field.setValue(parseInt(win.panel.getApiParam('iterations')))
						field.setFieldLabel(win.panel.localize("iterations"))
					}
				}
			}
		},{
			xtype: 'textfield',
			name: 'seed',
			fieldLabel: 'Random Seed',
			labelAlign: 'right',
			value: 0
		}],
		
		currentTopics: [],
		currentDocument: undefined,

		corpus: undefined
	},
	
	constructor: function(config) {
		var me = this;
		Ext.apply(this, {
			title: this.localize('title'),
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'begin',
				padding: '10px'
			},
			defaultType: 'dataview',
			items: [{
				itemId: 'topicsView',
				flex: 2,
				padding: '0 5px 0 0',
				margin: '0 5px 0 0',
				height: '100%',
				scrollable: 'y',
				store: Ext.create('Ext.data.ArrayStore',{
					fields: ['index', 'terms', 'weight', 'diagnostics']
				}),
				selectionModel: {
					type: 'dataviewmodel',
					mode: 'MULTI'
				},
				itemSelector: 'div.topicItem',
				tpl: new Ext.XTemplate(
					'<div style="font-weight: bold">{[this.localize("topics")]}</div><tpl for=".">',
						'<div class="topicItem" style="background-color: {[this.getColor(values.index)]}">',
							'<div class="data weight" data-qtip="{[this.localize("topicWeight")]}">{[fm.number(values.weight*100, "00.0")]}%</div>',
							'<span class="term">{[values.terms.join("</span> <span class=\\"term\\">")]}</span>',
							'<div class="data diagnostics">{[this.processDiagnostics(values.diagnostics)]}</div>',
						'</div>',
					'</tpl>',
					{
						getColor: function(index) {
							var rgb = me.getColorForTopic(index);
							return 'rgba('+rgb.join(',')+',.33);'
						},
						localize: function(key) {
							return me.localize(key);
						},
						processDiagnostics: function(obj) {
							var string = '';
							for (var key in obj) {
								string += '<div><div class="key">'+key+'</div><div class="value">'+obj[key]+'</div></div>';
							}
							return string;
						}
					}
				),
				listeners: {
					selectionchange: function(sel, selected) {
						sel.view.removeCls('showWeight');
						me.setCurrentDocument(undefined);
						me.setCurrentTopics(selected.map(function(item) { return item.get('index') }));

						me.down('#docsView').getSelectionModel().deselectAll(true);
						me.down('#docsView').refresh();
					}
				}
			},{
				itemId: 'docsView',
				flex: 1,
				height: '100%',
				scrollable: 'y',
				store: Ext.create('Ext.data.JsonStore',{
					fields: ['docId', 'weights']
				}),
				selectionModel: {
					type: 'dataviewmodel',
					mode: 'SINGLE',
					allowDeselect: true,
					toggleOnClick: true
				},
				itemSelector: 'div.topicItem',
				tpl: new Ext.XTemplate(
					'<div style="font-weight: bold">{[this.localize("documents")]}</div><tpl for=".">',
						'<div class="topicItem">',
							'{[this.getDocTitle(values.docId)]}',
							'<div class="chart">{[this.getChart(values.docId, values.weights)]}</div>',
						'</div>',
					'</tpl>',
					{
						getDocTitle: function(docId) {
							return me.getCorpus().getDocument(docId).getTitle();
						},
						getChart: function(docId, weights) {
							var chart = '';
							var topicStore = me.down('#topicsView').getStore();
							topicStore.each(function(item) {
								var index = item.get('index');
								var weight = weights[index];
								var rgb = me.getColorForTopic(index);
								var alpha = me.getCurrentDocument() === docId ? '1' : me.getCurrentTopics().length === 0 ? '.33' : me.getCurrentTopics().indexOf(index) !== -1 ? '1' : '.15';
								var color = 'rgba('+rgb.join(',')+','+alpha+')';
								chart += '<div style="width: '+(weight*100)+'%; background-color: '+color+'"> </div>';
							});
							return chart;
						},
						localize: function(key) {
							return me.localize(key);
						}
					}
				),
				listeners: {
					selectionchange: function(sel, selected) {
						me.setCurrentTopics([]);
						
						var docId = selected[0] ? selected[0].get('docId') : undefined;
						me.setCurrentDocument(docId);
						
						var topicStore = me.down('#topicsView').getStore();
						if (docId) {
							me.down('#topicsView').addCls('showWeight').getSelectionModel().deselectAll(true);
							topicStore.beginUpdate();
							sel.view.getStore().query('docId', docId).each(function(item) {
								var weights = item.get('weights');
								weights.forEach(function(weight, index) {
									topicStore.findRecord('index', index).set('weight', weight);
								});
							});
							topicStore.endUpdate();
							topicStore.sort('weight', 'DESC');
						} else {
							me.down('#topicsView').removeCls('showWeight').getSelectionModel().deselectAll(true);
							topicStore.sort('index', 'ASC');
						}

						sel.view.refresh();
					}
				}
					
			}],
			dockedItems: {
				dock: 'bottom',
				xtype: 'toolbar',
				overflowHandler: 'scroller',
				items:[
					   '<span class="info-tip" data-qtip="'+this.localize('searchTip')+'">'+this.localize('search')+'</span>'
					,{
					xtype: 'textfield',
					name: 'searchField',
					hideLabel: true,
					width: 80,
					listeners: {
						change: {
							fn: me.onQuery,
							scope: me,
							buffer: 500
						}
					}
				},
					'<span class="info-tip" data-qtip="'+this.localize('limitTermsTip')+'">'+this.localize('limitTerms')+'</span>'
				,{ 
					width: 60,
					hideLabel: true,
					xtype: 'numberfield',
					minValue: 1,
					maxValue: 100,
					listeners: {
						afterrender: function(slider) {
							slider.setValue(parseInt(this.getApiParam("termsPerTopic")))
						},
						change: function(slider, newvalue) {
							this.setApiParams({termsPerTopic: newvalue});
						},
						scope: this
					}
				},
					'<span class="info-tip" data-qtip="'+this.localize('numTopicsTip')+'">'+this.localize('numTopics')+'</span>'
				,{ 
					width: 60,
					hideLabel: true,
					xtype: 'numberfield',
					minValue: 1,
					maxValue: 100,
					listeners: {
						afterrender: function(slider) {
							slider.setValue(parseInt(this.getApiParam("topics")))
						},
						change: function(slider, newvalue) {
							this.setApiParams({topics: newvalue});
						},
						scope: this
					}
				},{
					text: 'Run',//new Ext.Template(this.localize('runIterations')).apply([100]),
					itemId: 'iterations',
					glyph: 'xf04b@FontAwesome',
					tooltip: this.localize('runIterationsTip'),
					handler: this.runIterations,
					scope: this
				},{
					text: 'Toggle diagnostics',
					itemId: 'diagnostics',
					glyph: 'xf129@FontAwesome',
					handler: function(btn) {
						me.down('#topicsView').toggleCls('showDiagnostics');
					}
				}]
			}
		});

		this.callParent(arguments);
		

		this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
		
		// create a listener for corpus loading (defined here, in case we need to load it next)
		this.on('loadedCorpus', function(src, corpus) {
			this.setCorpus(corpus);
			if (this.rendered) {
				this.initialize();
			}
			else {
				this.on("afterrender", function() {
					this.initialize();
				}, this)
			}

		});
	},
	
	runIterations: function() {
		var params = this.getApiParams();
		params.tool = 'analysis.TopicModeling';
		params.corpus = this.getCorpus().getAliasOrId();
		params.noCache = 1;

		var iterations = this.getApiParam('iterations');
		var msg = Ext.MessageBox.progress({
			title: this.localize("runningIterations"),
			message: new Ext.Template(this.localize('runningIterationsCount')).apply([iterations])
		});

		Ext.Ajax.request({
			url: this.getTromboneUrl(),
			params: params,
			success: function(response, req) {
				msg.close();

				var data = JSON.parse(response.responseText);
				
				var topicsStore = this.down('#topicsView').getStore();
				topicsStore.loadData(data.topicModeling.topics.map(function(topic, i) {
					var words = topic.words.map(function(w) {
						return w.word;
					});
					var diagnostics = Object.assign({}, topic);
					delete diagnostics.words;
					return [i, words, 0, diagnostics];
				}));

				data.topicModeling.topicDocuments.sort(function(a, b) {
					var docIndexA = this.getCorpus().getDocument(a.docId).getIndex();
					var docIndexB = this.getCorpus().getDocument(b.docId).getIndex();
					return docIndexA-docIndexB;
				}.bind(this));
				this.down('#docsView').getStore().loadData(data.topicModeling.topicDocuments);
				this.down('#docsView').refresh();
			},
			scope: this
		});
	},

	getColorForTopic: function(topicIndex) {
		return this.getApplication().getColor(topicIndex);
	},

	onQuery: function(cmp, query) {
		var topicsView = this.down('#topicsView');
		topicsView.getEl().query('.highlighted').forEach(function(hi) {
			hi.classList.remove('highlighted');
		});
		
		if (query.trim() !== '') {
			var matcher = new RegExp(query, 'gi');
			var topicsStore = topicsView.getStore();
			var indexes = [];
			var matches = [];
			topicsStore.each(function(record) {
				var terms = record.get('terms');
				var termMatches = [];
				for (var i = 0; i < terms.length; i++) {
					var term = terms[i];
					if (term.search(matcher) !== -1) {
						termMatches.push(i);
					}
				}
				if (termMatches.length > 0) {
					indexes.push(record.get('index'));
				}
				matches.push(termMatches);
			});
			if (indexes.length > 0) {
				topicsView.setSelection(indexes.map(function(index) {return topicsStore.findRecord('index', index)}));
				topicsView.getNodes().forEach(function(node, i) {
					var nodeMatches = matches[i];
					if (nodeMatches.length > 0) {
						var terms = node.querySelectorAll('.term');
						nodeMatches.forEach(function(termIndex) {
							terms[termIndex].classList.add('highlighted');
						})
					}
				});
			} else {
				this.setCurrentTopics([]);
				topicsView.getSelectionModel().deselectAll(true);
				this.down('#docsView').refresh();
			}
		} else {
			this.setCurrentTopics([]);
			topicsView.getSelectionModel().deselectAll(true);
			this.down('#docsView').refresh();
		}
	},
	
	initialize: function() {
		this.runIterations();
	},

	getExtraDataExportItems: function() {
		return [{
			name: 'export',
			inputValue: 'dataAsTsv',
			boxLabel: this.localize('exportGridCurrentTsv')
		}]
	},

	exportDataAsTsv: function(panel, form) {
		var topicsValue = "Topic\t";
		var docsValue = 'Document Title';

		var topicOrder = [];

		var includeDiagnostics = this.down('#topicsView').hasCls('showDiagnostics');

		this.down('#topicsView').getStore().getData().each(function(record, i) {
			if (i === 0) {
				topicsValue += record.get('terms').map(function(t, i) { return 'Term '+i; }).join("\t");
				if (includeDiagnostics) {
					topicsValue += "\t"+Object.keys(record.get('diagnostics')).join("\t");
				}
			}
			
			topicOrder.push(record.get('index'));

			topicsValue += "\nTopic "+record.get('index')+"\t"+record.get('terms').join("\t");
			if (includeDiagnostics) {
				topicsValue += "\t"+Object.values(record.get('diagnostics')).join("\t");
			}
			docsValue += "\tTopic "+record.get('index')+' Weight';
		});

		this.down('#docsView').getStore().getData().each(function(record) {
			var title = this.getCorpus().getDocument(record.get('docId')).getTitle();
			
			var weights = topicOrder.map(function(topicIndex) {
				var weight = record.get('weights')[topicIndex];
				return Ext.util.Format.number(weight*100, "00.######");
			}).join("\t");

			docsValue += "\n"+title+"\t"+weights;
		}, this);

		Ext.create('Ext.window.Window', {
			title: panel.localize('exportDataTitle'),
			height: 290,
			width: 450,
			bodyPadding: 10,
			layout: {
				type: 'vbox',
				pack: 'start',
				align: 'stretch'
			},
			modal: true,
			defaults: {
				margin: '0 0 5px 0'
			},
			items: [{
				html: panel.localize('exportDataTsvMessage')
			},{
				html: '<textarea class="x-form-text-default x-form-textarea" style="height: 76px; width: 100%">'+topicsValue+'</textarea>'
			},{
				html: '<textarea class="x-form-text-default x-form-textarea" style="height: 76px; width: 100%">'+docsValue+'</textarea>'
			}],
			buttonAlign: 'center',
			buttons: [{
				text: 'OK',
				handler: function(btn) {
					btn.up('window').close();
				}
			}]
		}).show();
	}
	
});

// assuming Cirrus library is loaded by containing page (via voyant.jsp)
Ext.define('Voyant.panel.Via', {
	extend: 'Ext.panel.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.via',
    statics: {
    	i18n: {
    	},
    	api: {
    		stopList: 'auto',
    		limit: 100,
    		docIndex: undefined
    	},
		glyph: 'xf06e@FontAwesome'
    },
    
    config: {
    	mode: undefined,
    	options: [
    		{xtype: 'stoplistoption'},
    		{
	    		xtype: 'listeditor',
	    		name: 'whiteList'
    	    },
    	    {xtype: 'categoriesoption'}
    	]
    },
    
    layout: 'fit',
    
    constructor: function(config) {
        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
    },
    
    initComponent: function (config) {
    	Ext.apply(this, {
    		title: this.localize('title'),
    		dockedItems: [{
                dock: 'bottom',
                xtype: 'toolbar',
                overflowHandler: 'scroller',
                items: [{
        			xtype: 'corpusdocumentselector',
        			singleSelect: true
        		},{
        			fieldLabel: this.localize('visible'),
        			labelWidth: 40,
        			width: 120,
        			xtype: 'slider',
	            	increment: 10,
	            	minValue: 10,
	            	maxValue: 1000,
	            	listeners: {
	            		afterrender: function(slider) {
	            			slider.setValue(this.getApiParam("limit"))
	            		},
	            		changecomplete: function(slider, newvalue) {
	            			this.setApiParams({limit: newvalue});
	            			this.loadFromCorpus(this.getCorpus());
	            		},
	            		scope: this
	            	}
                }]
    		}]
    	});

    	this.callParent(arguments);
    	
    	
    },
    
    listeners: {
    	resize: function(panel, width, height) {
//    		if (this.getCorpus()) {
//        		this.loadFromCorpus(this.getCorpus())
//    		}
    	},
    	
    	loadedCorpus: function(src, corpus) {
    		var langs = corpus.get("languageCodes");
    		var val = Ext.Array.each(langs, function(lang) {
    			if (lang!='en') {
    				this.showError(this.localize('englishOnly'));
    				return false;
    			}
    		}, this);
    		if (corpus.getWordTokensCount()>100000 && !this.getApiParam("docIndex")) {
    			this.setApiParam("docIndex", 0)
    		}
    		this.loadFromCorpus(corpus);
    	},
    	
    	corpusSelected: function(src, corpus) {
    		this.setApiParam("docIndex", "");
    		this.loadFromCorpus(corpus)
    	},
    	
    	documentSelected: function(src, document) {
    		this.setApiParam("docIndex", document.getIndex());
    		this.loadFromCorpus(this.getCorpus())
    	}
    	
    	
    },
    
    loadFromCorpus: function(corpus) {
    	var me = this;
    	this.mask(this.localize("loading"))
    	var params = this.getApiParams();
    	var a = corpus.loadRelatedWords(params).then(function(relatedWords) {
    		me.unmask()
    		var edges = relatedWords.map(function(item) {return {source: item.getSource(), target: item.getTarget()}})
    		var graph = me.down("voyantnetworkgraph");
    		if (graph) {
    			graph.loadJson({edges: edges});
    		} else {
    			graph = Ext.create("Voyant.widget.VoyantNetworkGraph", {
        			edges: edges,
        			listeners: {
        				nodeclicked: function(src, node) {
        					me.dispatchEvent('termsClicked', me, [node.term]);
        				}
        			}
        		})
        		me.add(graph)
    		}
    	}, function(response) {
    		me.unmask();
    		if (response.timedout) {
    			me.showError(me.localize('timedout'));
    		} else {
        		me.showError(response);
    		}
    	});
    }
});
Ext.define('Voyant.panel.NSSI', {
	extend: 'Ext.grid.Panel',
	mixins: ['Voyant.panel.Panel'],
	alias: 'widget.nssi',

	statics: {
		i18n: {
			title: 'NSSI Results',
			entity: 'Entity',
			lemma: 'Lemma',
			classification: 'Classification',
			document: 'Document',
			start: 'Start',
			end: 'End'
		}
	},
	config: {
	},

	constructor: function(config) {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
		this.callParent(arguments);
		this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
	},

	initComponent: function() {
		var me = this;

		var store = Ext.create('Ext.data.JsonStore', {
			fields: [
				{name: 'entity'},
				{name: 'lemma'},
				{name: 'classification'},
				{name: 'docId'},
				{name: 'start', type: 'int'},
				{name: 'end', type: 'int'}
			]
		});

		Ext.apply(me, {
			title: this.localize('title'),
			emptyText: this.localize('emptyText'),
			store : store,
			columns: [{
				text: this.localize('document'),
				dataIndex: 'docIndex',
				width: 'autoSize',
				sortable: true
			},{
				text: this.localize('classification'),
				dataIndex: 'classification',
				flex: .5,
				sortable: true
			},{
				text: this.localize('entity'),
				dataIndex: 'entity',
				flex: 1,
				sortable: true
			},{
				text: this.localize('lemma'),
				dataIndex: 'lemma',
				flex: 1,
				sortable: true
			},{
				text: this.localize('start'),
				dataIndex: 'start',
				width: 'autoSize',
				sortable: false
			},{
				text: this.localize('end'),
				dataIndex: 'end',
				width: 'autoSize',
				sortable: false
			}]
		});

		me.on('loadedCorpus', function() {
			var me = this;
			if (this.isVisible()) {
				this.load().then(function(data) {
					var parsedData = [];
					data.documents.forEach(function(doc) {
						var docIndex = me.getCorpus().getDocument(doc.id).getIndex();
						doc.entities.forEach(function(entity) {
							parsedData.push(Object.assign({ docIndex: docIndex }, entity));
						});
					});
					store.loadRawData(parsedData);
				}, function(err) {
					console.log(err);
				})
			}
		}, me);

		me.callParent(arguments);
	},

	load: function(params, dfd) {
		dfd = dfd || new Ext.Deferred();
		var me = this;

		Ext.Ajax.request({
			url: Voyant.application.getTromboneUrl(),
			params: {
				corpus: this.getCorpus().getAliasOrId(),
				tool: 'corpus.NSSI',
				useCache: false,
				noCache: true
			},
			scope: this
		}).then(function(response) {
			var data = Ext.JSON.decode(response.responseText);
			if (data && data.nssi && data.nssi.progress) {
				new Voyant.widget.ProgressMonitor({
					progress: data.nssi.progress,
					delay: 10000,
					maxMillisSinceStart: 1000*60*60, // an hour (!)
					success: function() {
						console.log('NSSI progress monitor success');
						me.load.call(me, params, dfd);
					},
					failure: function(responseOrProgress) {
						Voyant.application.showResponseError(me.localize("failedToFetchGeonames"), responseOrProgress);
					},
					scope: me
				});
			}
			if (data && data.nssi && !data.nssi.progress) {
				dfd.resolve(data.nssi);
			}
		}, function(response) {
			Voyant.application.showResponseError(me.localize('failedToFetchGeonames'), response);
		});
		return dfd.promise;
	}
});


Ext.define("Voyant.notebook.editor.button.Add", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperadd',
	statics: {
		i18n: {
			addTip: 'Add New Cell',
			addText: 'Add Text',
			addCode: 'Add Code'
		}
	},
	constructor: function(config) {
		config = config || {};

		Ext.apply(config, {
			tooltip: this.localize('addTip'),
			arrowVisible: false,
			menuAlign: 'tr-br?',
			menu: {
				items: [{
					text: this.localize('addText'),
					glyph: 'xf0f6@FontAwesome',
					handler: function() {
						var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
						var notebook = ed.findParentByType('notebook');
						var cmp = notebook.addText('',ed.getIndex()+1);
						cmp.getTargetEl().scrollIntoView(notebook.getTargetEl(), null, true, true);
						notebook.redoOrder();
					}
				},{
					text: this.localize('addCode'),
					glyph: 'xf121@FontAwesome',
					handler: function() {
						var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
						var notebook = ed.findParentByType('notebook');
						var cmp = notebook.addCode('',ed.getIndex()+1);
						cmp.getTargetEl().scrollIntoView(notebook.getTargetEl(), null, true, true);
						notebook.redoOrder();
					}
				}]
			}
		});

		this.callParent(arguments);
	},
	glyph: 'xf067@FontAwesome'
})
Ext.define("Voyant.notebook.editor.button.CodeConfig", {
	extend: "Ext.menu.Item",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookcodeconfig',
	statics: {
		i18n: {
			text: 'Config',
			tip: "Configuration Options",
			title: "Cell Mode",
			modeCode: 'Code',
			modeJavascript: 'Javascript (default)',
			modeData: 'Data',
			modeFile: 'File',
			modeJson: 'JSON',
			modeText: 'Text',
			modeXml: 'XML',
			modeHtml: 'HTML',
			ok: "OK",
			cancel: "Cancel"
		},
		configWin: undefined,
		initWindow: function(buttonInstance) {
			if (Voyant.notebook.editor.button.CodeConfig.configWin === undefined) {
				Voyant.notebook.editor.button.CodeConfig.configWin = new Ext.Window({
					title: buttonInstance.localize('title'),
					closeAction: 'hide',
					layout: 'fit',
					width: 240,
					items: [{
						xtype: 'form',
						layout: {
							type: 'vbox',
							align: 'stretch'
						},
						bodyPadding: 10,
						items: [{
							xtype: 'fieldset',
							title: buttonInstance.localize("modeCode"),
							items: [{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeJavascript'),
								name  : 'codeMode',
								inputValue: 'javascript',
								flex  : 1
							}]
						},{
							xtype: 'fieldset',
							title: buttonInstance.localize("modeData"),
							items: [{
								xtype : 'radiofield',
								boxLabel : 'Corpus',
								name  : 'codeMode',
								inputValue: 'corpus',
								flex  : 1
							},{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeFile'),
								name  : 'codeMode',
								inputValue: 'file',
								flex  : 1
							},{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeJson'),
								name  : 'codeMode',
								inputValue: 'json',
								flex  : 1
							},{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeText'),
								name  : 'codeMode',
								inputValue: 'text',
								flex  : 1
							},/*{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeCsv'),
								name  : 'codeMode',
								inputValue: 'csv',
								flex  : 1													
							},{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeTsv'),
								name  : 'codeMode',
								inputValue: 'tsv',
								flex  : 1													
							},*/{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeXml'),
								name  : 'codeMode',
								inputValue: 'xml',
								flex  : 1
							},{
								xtype : 'radiofield',
								boxLabel : buttonInstance.localize('modeHtml'),
								name  : 'codeMode',
								inputValue: 'html',
								flex  : 1
							}]
						}]
					}],
					buttons: [{
						text: buttonInstance.localize('ok'),
						itemId: 'ok'
					},{
						text:  buttonInstance.localize('cancel'),
						handler: function(btn) {
							btn.up('window').close();
						}
					}]
				});
			}
		},
		showConfigWindow: function(codeEditorInstance) {
			Voyant.notebook.editor.button.CodeConfig.configWin.down('radiofield[name=codeMode][inputValue="'+codeEditorInstance.getMode()+'"]').setValue(true);
			Voyant.notebook.editor.button.CodeConfig.configWin.down('button#ok').setHandler(function(btn) {
				var win = btn.up('window');
				var form = win.down('form');
				if (form.isDirty()) {
					codeEditorInstance.up('notebook').setIsEdited(true);
					var values = form.getValues();
					codeEditorInstance.switchModes(values.codeMode);
					
				}
				win.close();
			});
			Voyant.notebook.editor.button.CodeConfig.configWin.show();
		}
	},
	constructor: function(config) {
		Ext.apply(this, {
			text: this.localize('text'),
			// tooltip: this.localize('tip')
		})
		
		Voyant.notebook.editor.button.CodeConfig.initWindow(this);

		this.callParent(arguments);
	},
	glyph: 'xf013@FontAwesome',
	handler: function(btn, e) {
		Voyant.notebook.editor.button.CodeConfig.showConfigWindow(Voyant.notebook.editor.EditorWrapper.currentEditor);
	}
});

Ext.define('Voyant.notebook.editor.button.Export', {
	extend: 'Ext.menu.Item',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.notebookwrapperexport',
	statics: {
		i18n: {
			text: 'Export',
			tip: 'Export',
			exportTitle: 'Export',
			exportOpen: 'Export content into new window',
			exportDownload: 'Download file to your machine',
			exportCorpus: 'Open Corpus in Voyant Tools',
			cancelTitle: 'Cancel'
		},
		exportWin: undefined,
		getExportWindow: function(instance) {
			if (this.exportWin === undefined) {
				this.exportWin = Ext.create('Ext.window.Window', {
					title: instance.localize('exportTitle'),
					closeAction: 'hide',
					modal: true,
					width: 250,
					bodyPadding: 5,
					layout: {
						type: 'vbox',
						align: 'stretch'
					},
					defaults: {
						xtype: 'button'
					},
					items: [{
						itemId: 'corpus',
						text: instance.localize('exportCorpus'),
						glyph: 'xf08e@FontAwesome',
						margin: '0 0 5 0',
						hidden: true
					},{
						itemId: 'open',
						text: instance.localize('exportOpen'),
						glyph: 'xf08e@FontAwesome',
						margin: '0 0 5 0',
					},{
						itemId: 'download',
						preventDefault: false,
						text: instance.localize('exportDownload'),
						glyph: 'xf019@FontAwesome',
						handler: function(btn) {
							btn.up('window').close();
						}
					}],
					buttons: [{
						text: instance.localize('cancelTitle'),
						glyph: 'xf00d@FontAwesome',
						handler: function(btn) {
							btn.up('window').close();
						}
					}]
				});
			}

			var wrapper = Voyant.notebook.editor.EditorWrapper.currentEditor;
			
			var notebook = wrapper.up('notebook');
			var notebookId = notebook.getNotebookId() || 'spyral';
			
			var mode = wrapper.getMode();

			var dfd = new Ext.Deferred();

			var outputPromise = null;
			if (mode === 'file' || mode === 'corpus') {
				outputPromise = wrapper.cachedInput.getBlob();
			} else {
				outputPromise = wrapper.results.updateCachedOutput().then(function() {
					return Ext.Promise.resolve(wrapper.getOutput());
				});
			}

			outputPromise.then(function(output) {
				var input = wrapper.getInput();
	
				var corpusButton = this.exportWin.down('#corpus');
				var openButton = this.exportWin.down('#open');
				corpusButton.setHidden(true);
				openButton.setHidden(false);

				var fileName;
				var fileType;
				var fileContent;
				if (mode === 'file' || mode === 'corpus') {
					openButton.setHidden(true);
					if (mode === 'file') {
						fileName = input.fileName;
					} else {
						fileName = 'SpyralCorpus-'+input.corpusId;
					}
					fileType = output.type;
					fileContent = output;
				} else if (mode === 'javascript') {
					// corpus check
					if (Spyral.Util.isObject(output) && output.hasOwnProperty('corpusid') && Spyral.Util.isString(output.corpusid)) {
						corpusButton.setHidden(false);
						corpusButton.setHandler(function(btn) {
							var url = Voyant.application.getBaseUrlFull()+'?corpus='+output.corpusid;
							window.open(url);
						});
					}
	
					if (Spyral.Util.isUndefined(output)) {
						// code output is either a document or hasn't been run yet
						// try getContent fallback
						output = wrapper.getContent().output;
					}
					
					if (Spyral.Util.isObject(output) || Spyral.Util.isArray(output)) {
						fileName = notebookId+'_'+wrapper.getCellId()+'.json';
						fileType = 'application/json';
						fileContent = JSON.stringify(output);
					} else if (Spyral.Util.isNode(output) || (Spyral.Util.isString(output) && output.match(/<\/?\w+.*?>/g) !== null)) {
						fileName = notebookId+'_'+wrapper.getCellId()+'.html';
						fileType = 'text/html';
						if (Spyral.Util.isString(output)) {
							fileContent = output;
						} else {
							fileContent = new XMLSerializer().serializeToString(output);
						}
					} else {
						fileName = notebookId+'_'+wrapper.getCellId()+'.txt';
						fileType = 'text/plain';
						fileContent = output;
					}
				} else {
					fileName = notebookId+'_'+wrapper.getDataName()+'.'+mode;
					fileType = 'text/'+mode;
					fileContent = input;
					if (mode === 'json') {
						fileType = 'application/json';
					} else if (mode === 'text') {
						fileName = notebookId+'_'+wrapper.getDataName()+'.txt';
						fileType = 'text/plain';
					}
				}
				
				var file = new File([fileContent], fileName, {lastModified: new Date().getTime(), type: fileType});
	
				this.exportWin.down('#open').setHandler(function(btn) {
					var myWindow = window.open();
					myWindow.document.write(fileContent);
					myWindow.document.close();
					myWindow.focus();
					btn.up('window').close();
				});
	
				this.exportWin.addListener('show', function() {
					var url = URL.createObjectURL(file);
					this.exportWin.down('#download').getEl().set({
						download: fileName,
						href: url
					});
				}, this, { single: true });

				dfd.resolve(this.exportWin);

			}.bind(this), function(err) {
				dfd.reject(err);
			});

			return dfd.promise;
		}
	},
	constructor: function(config) {
		Ext.apply(config, {
			text: this.localize('text'),
			// tooltip: this.localize('tip')
		})
		this.callParent(arguments);
	},
	glyph: 'xf08e@FontAwesome',
	handler: function(cmp) {
		Voyant.notebook.editor.button.Export.getExportWindow(cmp).then(function(exportWin) {
			exportWin.show();
		}, function(err) {
			Ext.Msg.show({
				title: 'Export Error',
				msg: 'There was an error exporting the cell contents.'+"<br><pre style='color: red'>"+err+"</pre>",
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.ERROR
			});
		});
	}
})
Ext.define("Voyant.notebook.editor.button.ExpandCollapse", {
	extend: "Ext.menu.Item",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperexpandcollapse',
	statics: {
		i18n: {
			collapse: 'Collapse Editor',
			expand: 'Expand Editor'
		}
	},
	constructor: function(config) {
		config = config || {};
		config.text = this.localize('collapse');
		this.callParent(arguments);
	},
	isCollapsed: false,
	glyph: 'xf066@FontAwesome',
	handler: function(btn, e) {
		var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
		if (btn.isCollapsed) {
			ed.expand();
		} else {
			ed.collapse();
		}
		btn.setCollapsed(!btn.isCollapsed);
	},
	setCollapsed: function(isCollapsed) {
		this.isCollapsed = isCollapsed;
		this.setGlyph(isCollapsed ? 'xf065@FontAwesome' : 'xf066@FontAwesome');
		this.setText(isCollapsed ? this.localize('expand') : this.localize('collapse'));
		// this.setTooltip(isCollapsed ? this.localize('expand') : this.localize('collapse'));
	}
});

Ext.define("Voyant.notebook.editor.button.Counter", {
	extend: "Ext.toolbar.TextItem",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrappercounter',
	statics: {
		i18n: {
		}
	},
	config: {
		order: 0,
		name: undefined
	},
	cls: 'notebookwrappercounter',
	constructor: function(config) {
    	Ext.apply(this, {
    		toolTip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	setOrder: function(pos) {
		this.callParent(arguments);
		this.updateHtml();
	},
	updateHtml: function() {
		var pos = this.getOrder()+1;
		var lnk = 'spyralcounter_'+pos;
		var name = this.getName();
		this.setHtml('<a name="'+name+'" href="#'+name+'">'+pos+'</a>');
	}
})
Ext.define("Voyant.notebook.editor.button.MoveDown", {
	extend: "Ext.menu.Item",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrappermovedown',
	statics: {
		i18n: {
			text: 'Move Down'
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
			text: this.localize('text'),
    		// tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf063@FontAwesome',
	handler: function(evt) {
		var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
		ed.findParentByType('notebook').fireEvent("notebookWrapperMoveDown", ed);
		Voyant.notebook.editor.EditorWrapper.hideToolbars(evt, true);
	}
})
Ext.define("Voyant.notebook.editor.button.MoveUp", {
	extend: "Ext.menu.Item",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrappermoveup',
	statics: {
		i18n: {
			text: 'Move Up'
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
			text: this.localize('text'),
    		// tooltip: this.localize('tip')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf062@FontAwesome',
	handler: function(evt) {
		var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
		ed.findParentByType('notebook').fireEvent("notebookWrapperMoveUp", ed);
		Voyant.notebook.editor.EditorWrapper.hideToolbars(evt, true);
	}
})
Ext.define("Voyant.notebook.editor.button.Remove", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperremove',
	statics: {
		i18n: {
			text: 'Remove'
		}
	},
	constructor: function(config) {
    	Ext.apply(this, {
			// text: this.localize('text'),
    		tooltip: this.localize('text')
    	})
        this.callParent(arguments);
	},
	glyph: 'xf014@FontAwesome',
	handler: function(evt) {
		var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
		Ext.Msg.show({
			buttons: Ext.Msg.OKCANCEL,
			icon: Ext.MessageBox.QUESTION,
			msg: this.localize("confirmRemove"),
			title: this.localize("confirmRemoveTitle"),
			fn: function(buttonId) {
				if (buttonId === 'ok') {
					ed.findParentByType('notebook').fireEvent("notebookWrapperRemove", ed);
					Voyant.notebook.editor.EditorWrapper.hideToolbars(evt, true);
				}
			},
			scope: this
		})
	}
})
Ext.define("Voyant.notebook.editor.button.Run", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperrun',
	statics: {
		i18n: {
			text: 'Run'
		}
	},
	glyph: 'xf04b@FontAwesome',
	constructor: function(config) {
		config = config || {};
		config.tooltip = this.localize('tip');
		// config.text = this.localize('text');
		this.callParent(arguments);
	},
	handler: function(btn, e) {
		var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
		ed.up('notebook')._run([ed]);
	}
})
Ext.define("Voyant.notebook.editor.button.RunAll", {
	extend: "Ext.button.Button",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperrunall',
	statics: {
		i18n: {
		}
	},
	glyph: 'xf04e@FontAwesome',
	constructor: function(config) {
		config = config || {};
		config.tooltip = this.localize('tip');
		this.callParent(arguments);
	}
})
Ext.define("Voyant.notebook.editor.button.RunUntil", {
	extend: "Ext.menu.Item",
	mixins: ["Voyant.util.Localization"],
	alias: 'widget.notebookwrapperrununtil',
	statics: {
		i18n: {
			text: "Run...",
			tip: "Run multiple cells",
			runUntil: "Run up to here",
			runUntilTip: "Run previous code cells and this one.",
			runFrom: "Run from here onwards",
			runFromTip: "Run this and following code cells."
		}
	},
	glyph: 'xf050@FontAwesome',
	constructor: function(config) {
		config = config || {};
		config.text = this.localize('text');
		// config.tooltip = this.localize('tip');
		config.menu = {
			items: [{
				text: this.localize("runUntil"),
				// tooltip: this.localize("runUntilTip"),
				glyph: 'xf049@FontAwesome',
				handler: function() {
					var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
					ed.up('notebook').runUntil(ed);
				}
			},{
				text: this.localize("runFrom"),
				// tooltip: this.localize("runFromTip"),
				glyph: 'xf050@FontAwesome',
				handler: function() {
					var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
					ed.up('notebook').runFrom(ed);
				}
			}]
		}

		this.callParent(arguments);
	}
})
Ext.define("Voyant.notebook.editor.EditorWrapper", {
	extend: "Ext.panel.Panel",
	mixins: ["Voyant.util.Localization"],
	alias: "widget.notebookeditorwrapper",
	cls: "notebook-editor-wrapper",
	config: {
		cellId: undefined,
		index: undefined,
		content: '',
		isEditing: false,
		isCollapsed: false // custom tracker instead of using Panel's collapsed, which causes due to our overrides
	},
	statics: {
		currentEditor: undefined, // used primarily by toolbar buttons to determine the target of their actions
		toolbarLeft: undefined,
		toolbarRight: undefined,
		showToolbars: function(editor) {
			Voyant.notebook.editor.EditorWrapper.currentEditor = editor;
			Voyant.notebook.editor.EditorWrapper.currentEditor.body.addCls('notebook-editor-wrapper-hover');

			if (Voyant.notebook.editor.EditorWrapper.toolbarLeft === undefined) {
				Voyant.notebook.editor.EditorWrapper.toolbarLeft = Ext.create('Ext.container.Container', {
					floating: true, // TODO toolbars float above notebook header
					shadow: false,
					preventRefocus: true, // prevents focusing on collapsed/blurred CodeEditor when hiding toolbar
					layout: 'auto',
					defaults: { margin: '0 0 3px 3px', cls: 'x-btn x-btn-default-toolbar-small', iconCls: 'x-btn-icon-el-default-toolbar-small' },
					items: [{
						style: {float: 'right'},
						xtype: 'notebookwrapperrun',
						itemId: 'notebookwrapperrun'
					},{
						style: {float: 'right'},
						xtype: 'notebookwrapperadd',
						itemId: 'notebookwrapperadd'
					},{
						style: {float: 'right', clear: 'both'},
						xtype: 'button',
						glyph: 'xf0c9@FontAwesome',
						arrowVisible: false,
						menuAlign: 'tr-br?',
						menu: {
							items: [{
								xtype: 'notebookwrapperrununtil',
								itemId: 'notebookwrapperrununtil'
							},{
								xtype: 'notebookcodeconfig',
								itemId: 'notebookcodeconfig'
							},{
								xtype: 'notebookwrapperexpandcollapse',
								itemId: 'notebookwrapperexpandcollapse'
							},{
								xtype: 'notebookwrapperexport',
								itemId: 'notebookwrapperexport'
							},{
								xtype: 'menuseparator', itemId: 'menuseparator'
							},{
								text: 'Move',
								glyph: 'xf07d@FontAwesome',
								itemId: 'notebookwrappermove',
								menu: {
									items: [{
										xtype: 'notebookwrappermoveup'
									},{
										xtype: 'notebookwrappermovedown'
									}]
								}
							}],
							listeners: {
								show: function(menu) {
									var ed = Voyant.notebook.editor.EditorWrapper.currentEditor;
									menu.down('#notebookwrapperexpandcollapse').setCollapsed(ed.getIsCollapsed());
								}
							}
						}
					},{
						style: {float: 'left'},
						xtype: 'notebookwrapperremove',
						itemId: 'notebookwrapperremove'
					}]
				});
			}
			if (Voyant.notebook.editor.EditorWrapper.toolbarRight === undefined) {
				Voyant.notebook.editor.EditorWrapper.toolbarRight = Ext.create('Ext.container.Container', {
					floating: true,
					shadow: false,
					preventRefocus: true,
					layout: { type: 'vbox', align: 'middle', pack: 'start' },
					defaults: { margin: '0 3px 3px 3px', cls: 'x-btn x-btn-default-toolbar-small', iconCls: 'x-btn-icon-el-default-toolbar-small' },
					items: [{
						xtype: 'notebookwrappercounter'
					}]
				});
			}

			if (Voyant.notebook.editor.EditorWrapper.toolbarLeft.down('menu').isVisible()) return; // don't change toolbars when menu is open

			var showButtons = [];
			if (editor.xtype === 'notebookcodeeditorwrapper') {
				showButtons = ['notebookwrapperadd', 'notebookwrapperrun', 'notebookwrapperrununtil', 'notebookcodeconfig', 'notebookwrapperexpandcollapse', 'notebookwrappermove', 'notebookwrapperremove', 'menuseparator'];
			} else if (editor.xtype === 'notebookdatawrapper') {
				showButtons = ['notebookwrapperadd', 'notebookwrapperrun', 'notebookwrapperrununtil', 'notebookcodeconfig', 'notebookwrapperexport', 'notebookwrapperexpandcollapse', 'notebookwrappermove', 'notebookwrapperremove', 'menuseparator'];
			} else {
				showButtons = ['notebookwrapperadd', 'notebookwrappermove', 'notebookwrapperremove'];
			}
			Voyant.notebook.editor.EditorWrapper.toolbarLeft.query('button, menuitem').forEach(function(button) {
				if (button.itemId) { button.setVisible(showButtons.indexOf(button.itemId) !== -1); }
			});

			if (editor.xtype === 'notebookrunnableeditorwrapper') {
				var expandCollapseBtn = Voyant.notebook.editor.EditorWrapper.toolbarLeft.down('notebookwrapperexpandcollapse');
				expandCollapseBtn.setCollapsed(editor.editor.getIsCollapsed());
			}

			var counter = Voyant.notebook.editor.EditorWrapper.toolbarRight.down('notebookwrappercounter');
			counter.setName(editor.getCellId());
			counter.setOrder(editor.getIndex());

			var box = editor.body.getBox();
			Voyant.notebook.editor.EditorWrapper.toolbarLeft.showAt(box.x-58, box.y, false);
			Voyant.notebook.editor.EditorWrapper.toolbarRight.showAt(box.x+box.width, box.y, false);
		},
		hideToolbars: function(evt, force) {
			// don't change toolbars when menu is open
			if (Voyant.notebook.editor.EditorWrapper.toolbarLeft.down('menu').isVisible()) return;

			// hide any open submenus
			Voyant.notebook.editor.EditorWrapper.toolbarLeft.query('menu menu').forEach(function(menu) { menu.setVisible(false); });

			if (Voyant.notebook.editor.EditorWrapper.currentEditor) {
				var doHide = force ? true : false;
				if (!doHide) {
					if (evt.relatedTarget !== null) {
						var isAncestor = Voyant.notebook.editor.EditorWrapper.toolbarLeft.getEl().isAncestor(evt.relatedTarget) || Voyant.notebook.editor.EditorWrapper.toolbarRight.getEl().isAncestor(evt.relatedTarget)
						doHide = !isAncestor;
					}
				}
				if (doHide) {
					if (Voyant.notebook.editor.EditorWrapper.currentEditor.body) {
						Voyant.notebook.editor.EditorWrapper.currentEditor.body.removeCls('notebook-editor-wrapper-hover');
					}
					Voyant.notebook.editor.EditorWrapper.currentEditor = undefined;

					if (Voyant.notebook.editor.EditorWrapper.toolbarLeft !== undefined) {
						Voyant.notebook.editor.EditorWrapper.toolbarLeft.hide();
					}
					if (Voyant.notebook.editor.EditorWrapper.toolbarRight !== undefined) {
						Voyant.notebook.editor.EditorWrapper.toolbarRight.hide();
					}
				}
			}
		}
	},
	border: false,
	bodyBorder: false,
	initComponent: function() {
		this.setCellId(this.config.cellId);
		this.on("afterrender", function(){
			this.mon(this.getEl(), "mouseover", function() {
				Voyant.notebook.editor.EditorWrapper.showToolbars(this);
			}, this);
			this.mon(this.getEl(), "mouseleave", function(evt) {
				Voyant.notebook.editor.EditorWrapper.hideToolbars(evt);
			}, this);
		}, this);
		this.callParent(arguments);
	},
	getContent: function() {
		throw new Error('Subclass must override!');
	},
	applyIsEditing: function(val) {
		if (this.rendered) {
			if (val) {
				this.body.addCls('notebook-editor-wrapper-editing');
			} else {
				this.body.removeCls('notebook-editor-wrapper-editing');
			}
		}
		return val;
	}
})
Ext.define("Voyant.notebook.editor.RunnableEditorWrapper", {
	extend: "Voyant.notebook.editor.EditorWrapper",
	mixins: ["Voyant.util.Localization"],
	alias: "widget.notebookrunnableeditorwrapper",
	config: {
		isRun: false,
		mode: 'javascript'
	},

	editor: undefined,
	results: undefined,

	constructor: function(config) {
		this.results.addListener('initialized', this.updateLayout, this);

		this.callParent(arguments);
	},

	/**
	 * Run the code in this editor.
	 * @param {array} priorVariables Variables from prior cells that should be eval'd before this cell's code
	 */
	run: function(priorVariables) {
		if (this.results.getIsInitialized()) {
			if (priorVariables === undefined) {
				console.log('fetching prior vars');
				priorVariables = this.up('notebook').getNotebookVariables(this);
			}
			return this._run(priorVariables);
		} else {
			return Ext.Promise.reject('Editor is not initialized');
		}
	},
	
	_run: function(priorVariables) {
		this.results.clear();

		this.editor.clearMarkers();

		var code = this.editor.getValue();

		this.setIsRun(true);
		
		var runPromise = this.results.run(code, priorVariables);
		runPromise.otherwise(function(eventData) {
			if (eventData.error !== undefined) {
				var location = eventData.error.location;
				if (location !== undefined) {
					this.editor.addMarker(location, 'error');
					this.editor.addLineMarker(location, 'error');
				}
			}
		}, this);

		return runPromise;
	},
	
	getInput: function() {
		return this.editor.getValue();
	},

	getVariables: function() {
		if (this.results.getHasRunError()) {
			return [];
		} else {
			return this.results.getVariables();
		}
	},

	getOutput: function() {
		if (this.results.getHasRunError()) {
			return undefined;
		} else {
			return this.results.getCachedResultsValue();
		}
	},

	_reduceDataViewerOutput: function(output) {
		var html = new DOMParser().parseFromString(output, 'text/html');
		
		var container = html.querySelector('.spyral-dv-container');
		if (container !== null) {
			// if dataviewer, trim the content that will be saved
			function trimContent(parent, limit) {
				var content = parent.querySelector('.spyral-dv-content .spyral-dv-right');
				if (content !== null) {
					var toRemove = [];
					var wasTrimmed = false;
					for (var i = 0; i < content.children.length; i++) {
						if (i >= limit) {
							toRemove.push(content.children[i]);
							wasTrimmed = true;
						} else {
							trimContent(content.children[i], limit);
						}
					}
					toRemove.forEach(function(node) { content.removeChild(node); });
					if (wasTrimmed) {
						content.insertAdjacentHTML('beforeend', '<span class="spyral-dv-content">...</span>')
					}
				}
			}
			trimContent(container, 10);

			return container.outerHTML.replace(/spyral-dv-collapsed/g, 'spyral-dv-expanded'); // expand all nodes
		} else {
			return output;
		}
	},

	// override Ext.Panel expand/collapse
	expand: function() {
		this.editor.expand();
		this.setIsCollapsed(false);
	},
	collapse: function() {
		this.editor.collapse();
		this.setIsCollapsed(true);
	},

	/**
	 * This is a method for getting string versions of input and output content.
	 * Primarily used when saving the notebook.
	 * @returns {Object}
	 */
	getContent: function() {
		var output = this._reduceDataViewerOutput(this.results.getOutput());
		return {
			input: this.getInput(),
			output: output,
			mode: this.getMode(),
			expandResults: this.results.getExpandResults()
		};
	}
});

Ext.define("Voyant.notebook.editor.SandboxWrapper", {
	extend: "Ext.Container",
	mixins: ["Voyant.util.Localization"],
	alias: "widget.sandboxwrapper",
	statics: {
		i18n: {
			expandResults: 'Expand Results',
			collapseResults: 'Collapse Results',
			viewWarnings: 'View Warning(s)',
			generalWarning: 'Warning: {warningInfo}',
			serializationWarning: 'The variable "{warningInfo}" cannot be passed between cells.',
			loadVariableWarning: 'The variable "{warningInfo}" could not be loaded.'
		},
	},

	config: {
		isInitialized: false,

		cachedPaddingHeight: undefined,
		cachedResultsHeight: undefined,
		cachedResultsValue: undefined,
		cachedResultsOutput: '',
		cachedResultsVariables: [],

		runPromise: undefined,
		hasRunError: false,

		initIntervalID: undefined,
		maskTimeoutId: undefined,

		emptyResultsHeight: 40,
		minimumResultsHeight: 120,

		expandResults: true
	},

	constructor: function(config) {
		config.expandResults = config.expandResults !== undefined ? config.expandResults : true;
		var isExpanded = config.expandResults;
		var sandboxSrcUrl = config.sandboxSrcUrl;

		Ext.apply(this, {
			itemId: 'parent',
			cls: 'notebook-code-results',
			height: this.getEmptyResultsHeight(),
			layout: {
				type: 'vbox',
				align: 'stretch'
			},
			items: [{
				xtype: 'container',
				flex: 1,
				layout: {
					type: 'absolute'
				},
				items: [{
					xtype: 'uxiframe',
					itemId: 'resultsFrame',
					x: 0,
					y: 0,
					anchor: '100%',
					height: '100%',
					src: sandboxSrcUrl,
					renderTpl: ['<iframe allow="midi; geolocation; microphone; camera; display-capture; encrypted-media;" sandbox="allow-same-origin allow-scripts allow-modals allow-popups allow-forms allow-top-navigation-by-user-activation allow-downloads" src="{src}" id="{id}-iframeEl" data-ref="iframeEl" name="{frameName}" width="100%" height="100%" frameborder="0" style="min-height: 40px"></iframe>']
				},{
					xtype: 'toolbar',
					itemId: 'buttons',
					hidden: true,
					x: 0,
					y: 0,
					style: { background: 'none', paddingTop: '6px', pointerEvents: 'none' },
					defaults: { style: { pointerEvents: 'auto'} },
					items: ['->',{
						itemId: 'warnings',
						glyph: 'xf12a@FontAwesome',
						hidden: true,
						tooltip: this.localize('viewWarnings'),
						warnings: [],
						handler: function(btn) {
							if (btn.warnings.length > 0) {
								Ext.Msg.show({
									title: 'Warning',
									message: btn.warnings,
									buttons: Ext.Msg.OK,
									icon: Ext.Msg.INFO
								});
							}
						}
					},{
						itemId: 'expandButton',
						glyph: isExpanded ? 'xf066@FontAwesome' : 'xf065@FontAwesome',
						tooltip: isExpanded ? this.localize('collapseResults') : this.localize('expandResults'),
						handler: function() {
							this._doExpandCollapse();
						},
						scope: this
					}
					// ,{
					// 	xtype: 'notebookwrapperexport'
					// }
					,{
						glyph: 'xf014@FontAwesome',
						tooltip: 'Remove Results',
						handler: function() {
							//this.resetResults();
							this.clear();
							this.hide();
						},
						scope: this
					}]
				}]
			},{
				xtype: 'component',
				itemId: 'expandWidget',
				height: 20,
				hidden: isExpanded ? true : false,
				style: {textAlign: 'center', fontSize: '26px', cursor: 'pointer', borderTop: '1px solid #DDD', color: '#000'},
				html: '&#8943;',
				listeners: {
					afterrender: function(cmp) {
						var me = this;
						cmp.getEl().on('click', function() {
							me._doExpandCollapse();
						})
					},
					scope: this
				}
			}]
		});

		this.callParent(arguments);
	},

	initComponent: function() {
		var handleResultsScoped = this._handleResults.bind(this);

		this.on('afterrender', function(cmp) {
			cmp.getEl().on('mouseover', function(event, el) {
				cmp.down('#buttons').setVisible(true);
			});
			cmp.getEl().on('mouseout', function(event, el) {
				cmp.down('#buttons').setVisible(false);
			});

			window.addEventListener('message', handleResultsScoped);

			var me = this;
			this.setInitIntervalID(setInterval(function() {
				me._sendMessage({type: 'command', command: 'init'});
			}, 100));
		}, this);

		this.on('removed', function() {
			window.removeEventListener('message', handleResultsScoped);
		}, this);

		this.callParent(arguments);
	},

	clear: function() {
		if (this.isVisible() === false) {
			console.log("clearing but not visible!", this);
			this.show();
		}
		this.down('#warnings').hide().warnings = [];
		this._sendMessage({type: 'command', command: 'clear'});
	},

	resetResults: function() {
		this.setCachedResultsValue(undefined);
		this.setCachedResultsOutput('');
		this.setCachedResultsVariables([]);
	},

	run: function(code, priorVariables) {
		if (priorVariables === undefined) {
			priorVariables = [];
		}

		// reset
		//this.resetResults(); // TODO review this vs setvisible
		this.down('#warnings').hide().warnings = [];
		this.show();
		this.setHasRunError(false);
		this.getEl().removeCls(['error','success','warning']);

		this.setRunPromise(new Ext.Deferred());

		var actualPromise = this.getRunPromise().promise;
		actualPromise.then(function(result) {
			if (result.warnings && result.warnings.length > 0) {
				this._handleWarnings(result.warnings);
				this.getEl().addCls('warning');
			} else {
				this.getEl().addCls('success');
			}
		}, function() {
			this.setHasRunError(true);
			this.getEl().addCls('error');
		}, undefined, this);

		this.mask('Running code...');

		// console.log('sending vars', priorVariables);
		this._sendMessage({type: 'code', value: code, variables: priorVariables});

		return actualPromise;
	},

	mask: function(maskMsg) {
		var me = this;
		this.setMaskTimeoutId(setTimeout(function() {
			me.superclass.mask.call(me, maskMsg, 'spyral-code-mask');
		}, 250)); // only mask long running code
	},

	unmask: function() {
		clearTimeout(this.getMaskTimeoutId());
		this.superclass.unmask.call(this);
	},

	updateHtml: function(html) {
		this._sendMessage({type: 'command', command: 'update', html: html});
	},

	updateValue: function(name, value) {
		this._sendMessage({type: 'command', command: 'update', name: name, value: value});
	},

	getValue: function() {
		return this.getCachedResultsValue();
	},

	updateCachedOutput: function() {
		var me = this;
		return new Ext.Promise(function (resolve, reject) {
			me._sendMessage({type: 'command', command: 'getContents'});
			me.on('sandboxMessage', function(eventData) {
				if (eventData.command === 'getContents') {
					me.setCachedResultsOutput(eventData.value);
				} else {
					console.warn('getOutput: received unexpected message',eventData);
				}
				resolve(me.getCachedResultsOutput());
			}, me, {single: true});
		});
	},

	getOutput: function() {
		return this.getCachedResultsOutput();
	},

	getVariables: function() {
		return this.getCachedResultsVariables();
	},

	applyCachedResultsVariables: function(newVars, oldVars) {
		var parentNotebook = this.up('notebook');
		if (parentNotebook) {
			// it isn't necessary to compare old and new vars since they all get removed prior to running in resetResults
			// var toRemove = oldVars.filter(function(oldVar) {
			// 	return newVars.find(function(newVar) { return newVar.name === oldVar.name }) === undefined;
			// });
			parentNotebook.updateTernServerVariables(newVars, oldVars);
		}
		return newVars;
	},

	getResultsEl: function() {
		var doc = this.down('#resultsFrame');
		if (doc) {
			return doc;
		} else {
			return null;
		}
	},

	_sendMessage: function(messageObj) {
		this.down('#resultsFrame').getWin().postMessage(messageObj, '*');
	},

	_handleResults: function(e) {
		var frame = this.down('#resultsFrame').getFrame();
		if (e.source === frame.contentWindow) {
			var me = this;
			var eventData = e.data;//JSON.parse(td.decode(ev.target.result));
			if (eventData.type) {
				switch (eventData.type) {
					case 'error':
						console.log('iframe error:', eventData);
						me.unmask();
						me.getRunPromise().reject(eventData);
						break;
					case 'command':
						// console.log('iframe command:', eventData);
						switch (eventData.command) {
							case 'init':
								if (me.getIsInitialized() === false) {
									me.setIsInitialized(true);
									clearInterval(me.getInitIntervalID());
									me.fireEvent('initialized', me);
								}
								break;
							case 'clear':
								me._setHeight(0);
								break;
						}
						break;
					case 'result':
						console.log('iframe result:', eventData);
						me.unmask();
						me.getRunPromise().resolve(eventData);
						break;
				}

				if (eventData.command !== 'getContents' &&  // don't overwrite value or variables when we just want to get sandbox contents, i.e. dom output
					eventData.command !== 'clear') { // don't wipe variables just because results were cleared TODO review
					if (eventData.value) {
						me.setCachedResultsValue(eventData.value);
					}
					me.setCachedResultsVariables(eventData.variables);
				}

				if (eventData.output) {
					me.setCachedResultsOutput(eventData.output);
				}

				if (eventData.height > 0) {
					me._setHeight(eventData.height);
				}

				me.fireEvent('sandboxMessage', eventData);
			} else {
				console.warn('unrecognized message!', e);
			}
		}
	},

	_handleWarnings: function(warningsArray) {
		var warningsContent = [];
		warningsArray.forEach(function(warning) {
			switch(warning.type) {
				case 'serialization':
					warningsContent.push(this.localize('serializationWarning').replace('{warningInfo}', warning.warningInfo));
					break;
				case 'loadVariable':
					warningsContent.push(this.localize('loadVariableWarning').replace('{warningInfo}', warning.warningInfo));
					break;
			}
		}, this)
		var parent = this.down('#warnings');
		parent.show();
		parent.warnings = '<p>'+warningsContent.join('</p><p>')+'</p>';
	},

	_doExpandCollapse: function() {
		var expandButton = this.down('#expandButton');
		if (this.getExpandResults()) {
			this.setExpandResults(false);
			expandButton.setTooltip(this.localize('expandResults'));
			expandButton.setGlyph('xf065@FontAwesome');
		} else {
			this.setExpandResults(true);
			expandButton.setTooltip(this.localize('collapseResults'));
			expandButton.setGlyph('xf066@FontAwesome');
		}
		
		this._setHeight();
	},
	
	/**
	 * Set the height of the results component
	 */
	_setHeight: function(height) {
		if (this.getCachedPaddingHeight() === undefined) {
			// compute and store parent padding, which we'll need when determining proper height
			var computedStyle = window.getComputedStyle(this.getEl().dom);
			this.setCachedPaddingHeight(parseFloat(computedStyle.getPropertyValue('padding-top'))+parseFloat(computedStyle.getPropertyValue('padding-bottom')) + 2); // extra 2 for border
		}
		if (height !== undefined) {
			// cache height
			this.setCachedResultsHeight(height);
		} else {
			height = this.getCachedResultsHeight();
			if (height === undefined) {
				var resultsEl = this.getResultsEl();
				if (resultsEl) {
					height = resultsEl.getHeight();
				} else {
					height = this.getEmptyResultsHeight();
				}
				this.setCachedResultsHeight(height);
			}
		}
		height += this.getCachedPaddingHeight();

		var resultsEl = this.getResultsEl();
		if (resultsEl) {
			var expandWidget = this.down('#expandWidget');
			if (this.getExpandResults()) {
				expandWidget.hide();
				// console.log('setResultsHeight', Math.max(height, this.getEmptyResultsHeight()))
				this.setHeight(Math.max(height, this.getEmptyResultsHeight()));
				// resultsEl.removeCls('collapsed');
			} else {
				height = Math.min(Math.max(height, this.getEmptyResultsHeight()), this.getMinimumResultsHeight());
				if (height < this.getMinimumResultsHeight()) {
					expandWidget.hide();
				} else {
					expandWidget.show();
				}
				// console.log('setResultsHeight', height)
				this.setHeight(height);
				// resultsEl.addCls('collapsed');
			}
		}

		// this.fireEvent('sizeChanged', this);
	}
});

Ext.define("Voyant.notebook.editor.CodeEditor", {
	extend: "Ext.Component",
	alias: "widget.notebookcodeeditor", 
	mixins: ["Voyant.util.Localization"],
	cls: 'notebook-code-editor',
	config: {
		// theme: 'ace/theme/chrome',
		mode: 'javascript',
		content: '',
		docs: undefined,
		isChangeRegistered: false,
		editor: undefined,
		editedTimeout: undefined,
		editorHeight: undefined,
		editorDocHeight: undefined,
		markers: [],
		parentWrapper: undefined,
		isCollapsed: false
	},
	statics: {
		i18n: {
		},
		api: {
			content: undefined
		},
		ternServer: undefined
	},

	MIN_LINES: 2,

	constructor: function(config) {
		this.callParent(arguments);
	},
	listeners: {
		render: function() {
			var me = this;
			var editorTarget = Ext.getDom(this.getEl());
			var editor = CodeMirror(editorTarget, {
				mode: this._getModeConfig(this.getMode()),
				value: this.getContent(),
				lineNumbers: true,
				lineWrapping: true,
				styleActiveLine: true,
				viewportMargin: 50, // lines rendered above and below current view
				extraKeys: {
					'Shift-Enter': function() {
						me.up('notebookrunnableeditorwrapper').run();
					},
					'Shift-Ctrl-Enter': function() {
						var wrapper = me.up('notebookrunnableeditorwrapper');
						wrapper.up('notebook').runUntil(wrapper);
					},
					'Shift-Cmd-Enter': function() {
						var wrapper = me.up('notebookrunnableeditorwrapper');
						wrapper.up('notebook').runUntil(wrapper);
					},
					'Ctrl-/': function() {
						editor.toggleComment();
					},
					'Cmd-/': function() {
						editor.toggleComment();
					}
				}
			});
			
			editor.on('focus', function(editor, ev) {
				me.getParentWrapper().setIsEditing(true);
			});
			editor.on('blur', function(editor, ev) {
				me.getParentWrapper().setIsEditing(false);
			});

			editor.on('change', function(editor, ev) {
				me.clearMarkers();
				
				var editorHeight = editor.getWrapperElement().offsetHeight;
				var editorDocHeight = editor.getDoc().height;
				if (editorHeight !== me.getEditorHeight() || editorDocHeight !== me.getEditorDocHeight()) {
					me.setEditorHeight(editorHeight);
					me.setEditorDocHeight(editorDocHeight);
					setTimeout(function() {
						var height = editor.getWrapperElement().offsetHeight;
						me.setSize({height: height});
					}, 0);
				}

				if (me.getIsChangeRegistered() === false) {
					me.setIsChangeRegistered(true);
					var wrapper = me.up('notebookrunnableeditorwrapper');
					wrapper.setIsRun(false);
					wrapper.up('notebook').setIsEdited(true);
				} else {
					if (!me.getEditedTimeout()) { // no timeout, so set it to 30 seconds
						me.setEditedTimeout(setTimeout(function() {
							me.setIsChangeRegistered(false);
						}, 30000));
					}
				}
			});

			if (this.getMode() === 'javascript') {
				if (Voyant.notebook.editor.CodeEditor.ternServer === undefined) {
					var defs = this.getDocs();
					var url = Voyant.application.getBaseUrlFull();
					Voyant.notebook.editor.CodeEditor.ternServer = new CodeMirror.TernServer({
						defs: defs,
						useWorker: true,
						workerScript: url+'resources/spyral/tern/worker.js',
						workerDeps: ['tern_worker_deps.js'],
						hintDelay: 5000
					});
				}

				editor.on('keypress', function(ed, event) {
					if (event.key === '.') {
						Voyant.notebook.editor.CodeEditor.ternServer.complete(ed);
					} else if (event.key === '{') {
						// many Spyral methods take a single config object
						// so look out for that and display config object properties
						var cursor = ed.getCursor();
						var range = ed.getRange({line: cursor.line, ch: 0}, cursor);
						if (range.match(/\(\s*$/)) {
							// let closebrackets addon finish and then look for matches
							setTimeout(function() {
								Voyant.notebook.editor.CodeEditor.ternServer.complete(ed);
							}, 50);
						}
					}
				});
				
				Object.assign(editor.getOption('extraKeys'), {
					'Ctrl-Space': function(ed) { Voyant.notebook.editor.CodeEditor.ternServer.complete(ed); },
					'Ctrl-D': function(ed) { Voyant.notebook.editor.CodeEditor.ternServer.showDocs(ed, undefined, me._showDocsCallback.bind(me)); },
					'Cmd-Space': function(ed) { Voyant.notebook.editor.CodeEditor.ternServer.complete(ed); },
					'Cmd-D': function(ed) { Voyant.notebook.editor.CodeEditor.ternServer.showDocs(ed, undefined, me._showDocsCallback.bind(me)); }
				});
				editor.on('cursorActivity', function(ed) { Voyant.notebook.editor.CodeEditor.ternServer.updateArgHints(ed); });
			}

			this.setEditor(editor);

			this._setModeOptions(this.getMode());

			this.expand();

			me.fireEvent('resize', me);

		},
		removed: function(cmp, container) {
			if (cmp.getEditor()) {
				cmp.setEditor(undefined);
			}
		}
		
	},

	_getModeConfig: function(mode) {
		var modeConfig = undefined;
		switch (mode) {
			case 'json':
				modeConfig = { name: 'javascript', json: true };
				break;
			case 'xml':
				modeConfig = 'xml';
				break;
			case 'html':
				modeConfig = { name: 'xml', htmlMode: true }
			default:
				modeConfig = 'javascript';
		}
		return modeConfig;
	},

	_setModeOptions: function(mode) {
		var options = {};
		switch (mode) {
			case 'json':
			case 'javascript':
				options.autoCloseBrackets = true;
				options.matchBrackets = true;
				break;
			default:
				options.autoCloseBrackets = false;
				options.matchBrackets = false;
				break;
		}
		for (var key in options) {
			this.getEditor().setOption(key, options[key]);
		}
	},
	
	switchModes: function(mode) {
		console.log('mode', mode);
		this.setMode(mode);
		if (this.rendered) {
			this.getEditor().setOption('mode', this._getModeConfig(mode));
			this._setModeOptions(mode);
		}
	},
	
	getValue: function() {
		return this.getEditor().getValue();
	},

	addMarker: function(location, type) {
		type = type === undefined ? 'error' : type;
		var cls = 'spyral-editor-'+type;
		var row = location[0];
		var col = location[1];
		col--;
		row--;
		var marker = this.getEditor().getDoc().markText(
			{line: row, ch: col},
			{line: row, ch: col+1},
			{className: cls}
		);
		this.getMarkers().push(marker);
	},

	addLineMarker: function(location, type) {
		type = type === undefined ? 'error' : type;
		var cls = 'spyral-editor-'+type;
		var row = location[0];
		row--;
		var marker = this.getEditor().getDoc().addLineClass(row, 'gutter', cls);
		this.getMarkers().push({marker: marker, where: 'gutter', cls: cls});
	},

	clearMarkers: function() {
		var editor = this.getEditor();
		var markers = this.getMarkers();
		markers.forEach(function(marker) {
			if (marker.marker) {
				editor.getDoc().removeLineClass(marker.marker, marker.where, marker.cls);
			} else {
				marker.clear();
			}
		});
		this.setMarkers([]);
	},

	_showDocsCallback: function() {
		var toolTipEl = this.getEditor().state.ternTooltip;
		var docLink = toolTipEl.querySelector('a');
		if (docLink) {
			docLink.addEventListener('click', function(e) {
				e.preventDefault();
				e.stopPropagation();
				var docHref = docLink.getAttribute('href');
				this.up('notebook').handleDocLink(docHref);
			}.bind(this));
		}
	},

	expand: function() {
		var editor = this.getEditor();
		var minHeight = ((this.MIN_LINES+1) * editor.defaultTextHeight()) + 'px';

		var editorWrapperEl = editor.getWrapperElement();
		editorWrapperEl.style.setProperty('min-height', minHeight);
		editor.getScrollerElement().style.setProperty('min-height', minHeight);
		editor.setSize(null, 'auto');

		Ext.fly(editorWrapperEl).unmask();

		this.setSize({height: editor.getWrapperElement().offsetHeight});

		this.setIsCollapsed(false);
	},

	collapse: function() {
		var editor = this.getEditor();
		var height = editor.defaultTextHeight()+8;

		var editorWrapperEl = editor.getWrapperElement();
		editorWrapperEl.style.removeProperty('min-height');
		editor.getScrollerElement().style.removeProperty('min-height');
		editor.setSize(null, height);
		editorWrapperEl.querySelector('.CodeMirror-vscrollbar').style.setProperty('display', 'none');

		var mask = Ext.fly(editorWrapperEl).mask();
		mask.setStyle({cursor: 'pointer', background: 'none'});
		mask.down('.x-mask-msg').hide();
		mask.on('click', function(evt) {
			this.up('notebookrunnableeditorwrapper').expand();
			this.getEditor().focus();
		}.bind(this))

		this.setSize({height: editor.getWrapperElement().offsetHeight});

		this.setIsCollapsed(true);
		
		setTimeout(function() {
			editor.display.input.blur();
		}, 0);
	}
})
Ext.define("Voyant.notebook.editor.CodeEditorWrapper", {
	extend: "Voyant.notebook.editor.RunnableEditorWrapper",
	requires: ["Voyant.notebook.editor.CodeEditor","Voyant.notebook.editor.button.Run","Voyant.notebook.editor.button.RunAll"],
	alias: "widget.notebookcodeeditorwrapper",
	cls: 'notebook-code-wrapper',
	statics: {
		i18n: {
		}
	},

	constructor: function(config) {
		config.mode = 'javascript';

		this.editor = Ext.create("Voyant.notebook.editor.CodeEditor", {
			content: Ext.Array.from(config.input).join("\n"),
			docs: config.docs,
			mode: config.mode,
			parentWrapper: this
		});

		var hideResults = !config.output || config.output.indexOf('>undefined<') !== -1;

		this.results = Ext.create('Voyant.notebook.editor.SandboxWrapper', {
			sandboxSrcUrl: Spyral.Load.baseUrl+'spyral/sandbox.jsp', // 'https://beta.voyant-tools.org/spyral/sandbox.jsp',
			expandResults: config.expandResults,
			hidden: hideResults,
			listeners: {
				initialized: function() {
					// pass along initialized
					this.fireEvent('initialized', this);

					if (config.output !== undefined) {
						this.results.updateHtml(config.output);
					}
				},
				scope: this
			}
		});

		Ext.apply(this, {
			border: false,
			layout: 'anchor',
			defaults: { anchor: '100%' },
			items: [this.editor, this.results]
		});
		
		this.callParent(arguments);
	},
	
	switchModes: function(mode) {
		if (mode !== 'javascript') {
			var notebook = this.up('notebook');
			notebook.addData('', this.getIndex(), undefined, {mode: mode});
			notebook.notebookWrapperRemove(this);
		} else {
			console.log('unhandled mode switch:',mode);
		}
	}
})
Ext.define('Voyant.notebook.editor.TextEditor', {
	extend: 'Ext.Component',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.notebooktexteditor',
	cls: 'notebook-text-editor',
	config: {
		editor: undefined,
		isEditRegistered: false,
		currentHeight: 0,
		isFresh: undefined,
		parentWrapper: undefined
	},
	statics: {
		i18n: {
		}
	},
	border: false,
	constructor: function(config) {
		config.isFresh = config.content ? false : true;
		Ext.apply(this, {
			html: config.content ? config.content : '<p style="text-align: center;">'+this.localize('emptyText')+'</p>'
		});
        this.callParent(arguments);
	},
	listeners: {
		boxready: function(cmp) {
			this.ownerCt.getTargetEl().on('click', function(e, t) {
				if (t.tagName !== 'A') {
					this._handleClick();
				}
			}, this);
		},
		removed: function(cmp, container) {
			// properly remove editor
			if (this.getEditor()) {
				this.getEditor().focusManager.blur(true); //focusManager bug workaround, see: https://dev.ckeditor.com/ticket/16825
				this.getEditor().destroy();
			}
		}
	},
	
	_handleClick: function() {
		if (this.getEditor() === undefined) {
			this._initEditor();
		} else {
			if (this.getParentWrapper().getIsEditing() === false) {
				this._enable();
			}
		}
	},
	
	getContent: function() {
		return this.getTargetEl().dom.innerHTML;
	},

	_initEditor: function() {
		var el = this.getTargetEl();
		var editor = CKEDITOR.inline(el.dom, {
			toolbar: [
				{ name: 'basicstyles', items: [ 'Bold', 'Italic', '-', 'RemoveFormat' ] },
				{ name: 'paragraph', items: [ 'NumberedList', 'BulletedList', '-', 'Justify', 'Outdent', 'Indent', 'Blockquote', 'JustifyLeft', 'JustifyCenter', 'JustifyRight' ] },
				{ name: 'styles', items: [ 'Styles', 'Format' ] },
				{ name: 'links', items: [ 'Link', 'Unlink', 'Anchor' ] },
				{ name: 'insert', items: [ 'Image', 'Table' ] },
				{ name: 'document', items: [ 'Sourcedialog' ] }
			],
			
			extraPlugins: 'sourcedialog,justify',
			allowedContent: true,
			disableNativeSpellChecker: false,
			toolbarCanCollapse: false,
			startupFocus: 'end',
			baseFloatZIndex: 20000 // EditorWrapper toolbars are 19000
		});
		
		editor.on('contentDom', function() {
			this._enable();
			var editable = editor.editable();
			editable.attachListener(editable, 'click', function(evt) {
				// prevent further listeners from firing, esp. the one that prevents links from working ( https://stackoverflow.com/a/45616460 )
				evt.stop();
			}, null, null, 0); // zero (i.e. very high) priority
		}, this);

		editor.on('focus', function(evt) {
			if (this.getIsFresh()) {
				this.setIsFresh(false);
				this.getTargetEl().update('<p></p>'); // insert paragraphs because otherwise ckeditor will do it automatically
			}
		}, this);
		
		editor.on('blur', function(evt) {
			this._disable();
		}, this);

		editor.on('change', function() {
			editor.container.$.scrollIntoView(); // needed to counteract range.scrollIntoView by ckeditor
			var editorHeight = editor.container.$.clientHeight;
			if (editorHeight !== this.getCurrentHeight()) {
				this.findParentByType('notebookeditorwrapper').setHeight(editorHeight);
				this.setCurrentHeight(editor.container.$.clientHeight)
			}
			if (!this.getIsEditRegistered()) {
				this.findParentByType('notebook').setIsEdited(true);
				this.setIsEditRegistered(true);

			} else {
				var me = this; // make sure to allow edits to be auto-saved every 30 seconds
				setTimeout(function() {
					me.setIsEditRegistered(false);
				}, 30000);
			}
		}, this);

		this.setEditor(editor);
	},

	_enable: function() {
		var editor = this.getEditor();
		editor.setReadOnly(false);

		// need timeout before focusing otherwise FF throws error
		setTimeout(function() {
			editor.focus();
			this.getParentWrapper().setIsEditing(true);
		}.bind(this), 0);
	},

	_disable: function() {
		this.getEditor().setReadOnly(true);
		this.getParentWrapper().setIsEditing(false);
	}
})
Ext.define("Voyant.notebook.editor.TextEditorWrapper", {
	extend: "Voyant.notebook.editor.EditorWrapper",
	requires: ["Voyant.notebook.editor.TextEditor"],
	alias: "widget.notebooktexteditorwrapper",
	cls: 'notebook-text-wrapper',
	config: {
	},
	minHeight: 50,
	constructor: function(config) {
		Ext.apply(this, {
			items: [{
				xtype: 'notebooktexteditor',
				content: Ext.Array.from(config.input).join(""),
				parentWrapper: this
			}]
		});
        this.callParent(arguments);
	},
	
	getContent: function() {
		return this.items.get(0).getContent();
	}
	
})
Ext.define('Voyant.notebook.editor.CachedInput', {
	extend: 'Ext.container.Container',
	alias: 'widget.notebookcachedinput', 
	mixins: ['Voyant.util.Localization'],
	config: {
	},
	statics: {
		i18n: {
		}
	},

	constructor: function(config) {
		this.callParent(arguments);
	},

	/**
	 * Returns a Ext.Promise that resolves to a string of code, which, when run, assigns the cached value to the varName
	 * @param {String} varName The name of the variable to use for the cached value
	 */
	getCode: function(varName) {
		throw new Error('Subclass must override!');
	},

	/**
	 * Returns an object suitable for saving to a notebook file, which can be used to recreate the input on load
	 */
	getInput: function() {
		throw new Error('Subclass must override!');
	},

	/**
	 * Returns a Ext.Promise that resolves to a Blob of the cached input value
	 */
	getBlob: function() {
		throw new Error('Subclass must override!');
	}
});
Ext.define('Voyant.notebook.editor.FileInput', {
	extend: 'Voyant.notebook.editor.CachedInput',
	alias: 'widget.notebookfileinput', 
	mixins: ['Voyant.util.Localization'],
	config: {
		dataUrl: undefined,
		resourceId: undefined,
		file: undefined,
		fileName: undefined
	},
	statics: {
		i18n: {
			fileUpload: 'File Upload',
			buttonLabel: 'Choose a file...',
			deleteMsg: 'The previously added file has been deleted. You will need to add a new file.'
		}
	},

	serverStorage: undefined,

	constructor: function(config) {
		Ext.apply(this, config, {
			width: '100%',
			items: [{
				xtype: 'voyantfilefield',
				itemId: 'file',
				fieldLabel: this.localize('fileUpload'),
				labelAlign: 'right',
				buttonText: this.localize('buttonLabel'),
				width: 350,
				listeners: {
					render: function(cmp) {
						if (config.fileName) {
							cmp.inputEl.dom.value = config.fileName;
						}
					},
					change: function(cmp, filename) {
						var file = cmp.fileInputEl.dom.files[0];
						this.setFile(file);
						this.setFileName(filename);
						this.setDataUrl(undefined);
						this.setResourceId(undefined);

						this.fireEvent('change', filename);
					},
					scope: this
				}
			}]
		});

		if (typeof Voyant.util.ServerStorage === 'undefined') {
			Ext.define('Voyant.util.ServerStorage', {
				extend: 'Voyant.util.Storage',
				getTromboneUrl: function() {
					return Voyant.application.getTromboneUrl();
				}
			});
		}
		this.serverStorage = Ext.create('Voyant.util.ServerStorage');

		this.callParent(arguments);
	},

	getCode: function(varName) {
		var dfd = new Ext.Deferred();

		this.getDataUrl().then(function(dataUrl) {
			var code = varName+'= Spyral.Util.dataUrlToBlob(`'+dataUrl+'`)';
			dfd.resolve(code);
		}, function() {
			dfd.reject();
		});

		return dfd.promise;
	},

	getInput: function() {
		return {
			resourceId: this.getResourceId(),
			fileName: this.getFileName()
		}
	},

	getDataUrl: function() {
		var dfd = new Ext.Deferred();

		if (this.getResourceId()) {
			this.loadStoredFile().then(function(dataUrl) {
				dfd.resolve(dataUrl);
			}, function() {
				dfd.reject();
			})
		} else {
			if (this.getFile()) {
				this.storeFile().then(function(result) {
					dfd.resolve(result[1]);
				}, function() {
					dfd.reject();
				});
			} else {
				dfd.reject();
			}
		}

		return dfd.promise;
	},

	getBlob: function() {
		var dfd = new Ext.Deferred();

		this.getDataUrl().then(function(dataUrl) {
			var blob = Spyral.Util.dataUrlToBlob(dataUrl);
			dfd.resolve(blob);
		}, function() {
			dfd.reject();
		});

		return dfd.promise;
	},

	storeFile: function() {
		var dfd = new Ext.Deferred();

		var file = this.getFile();
		if (file === undefined) {
			dfd.reject();
		} else {
			var me = this;
			Spyral.Util.blobToDataUrl(file).then(function(data) {
				var resourceId = Spyral.Util.id(32);
				me.serverStorage.storeResource(resourceId, data).then(function() {
					me.setResourceId(resourceId);
					me.setDataUrl(data);
					dfd.resolve([resourceId, data]);
				}, function() {
					dfd.reject();
				})
			}, function(err) {
				dfd.reject(err);
			});
		}

		return dfd.promise;
	},

	loadStoredFile: function() {
		var dfd = new Ext.Deferred();
		
		var resourceId = this.getResourceId();
		if (resourceId === undefined) {
			dfd.reject();
		} else {
			var me = this;
			this.serverStorage.getStoredResource(resourceId).then(function(dataUrl) {
				if (dataUrl !== undefined) {
					me.setDataUrl(dataUrl);
					dfd.resolve(dataUrl);
				} else {
					dfd.reject();
				}
			}, function() {
				dfd.reject();
			});
		}
		
		return dfd.promise;
	}
});

Ext.define('Voyant.form.field.File', {
	extend: 'Ext.form.field.File',
	alias: 'widget.voyantfilefield',
	onFileChange: function(button, e, value) {
		// remove fakepath
		var newValue = value.replace(/^.*(\\|\/|\:)/, ''); // TODO test in safari etc

		return this.callParent([ button, e, newValue ]);
	}
});
Ext.define('Voyant.notebook.editor.CorpusInput', {
	extend: 'Voyant.notebook.editor.CachedInput',
	alias: 'widget.notebookcorpusinput', 
	mixins: ['Voyant.util.Localization'],
	config: {
		corpusId: undefined,
		type: undefined,
		value: undefined
	},
	statics: {
		i18n: {
			corpusInput: 'Corpus Input',
			corpusText: 'Text',
			corpusVariable: 'Variable',
			corpusFile: 'File',
			corpusId: 'Corpus ID',
			notebookVariables: 'Notebook Variables'
		}
	},

	corpusCreator: undefined,

	constructor: function(config) {
		Ext.apply(this, {
			layout: {
				type: 'hbox',
				align: 'begin',
				pack: 'start'
			},
			items: [{
				xtype: 'combo',
				itemId: 'type',
				fieldLabel: this.localize('corpusInput'),
				labelAlign: 'right',
				margin: '5px',
				queryMode: 'local',
				allowBlank: false,
				editable: false,
				forceSelection: true,
				value: 'text',
				store: [['text',this.localize('corpusText')],['variable',this.localize('corpusVariable')],['file',this.localize('corpusFile')],['id',this.localize('corpusId')]],
				listeners: {
					change: function(rg, val) {
						rg.nextSibling().getLayout().setActiveItem(val);
						this.setType(val);
						this.setCorpusId(undefined);

						if (val === 'id') {
							rg.nextSibling('#corpusOptions').hide();
						} else {
							rg.nextSibling('#corpusOptions').show();
						}
					},
					scope: this
				}
			},{
				xtype: 'container',
				layout: 'card',
				defaultType: 'container',
				itemId: 'cards',
				flex: 1,
				margin: '5px 5px 5px 0',
				items: [{
					itemId: 'text',
					items: [{
						xtype: 'textfield',
						width: '75%',
						name: 'text',
						fieldLabel: '',
						listeners: {
							change: function() {
								this.setCorpusId(undefined);
							},
							scope: this
						}
					}]
				},{
					itemId: 'variable',
					items: [{
						xtype: 'combo',
						name: 'variable',
						fieldLabel: '',
						triggerAction: 'all',
						queryMode: 'local',
						editable: false,
						forceSelection: true,
						emptyText: this.localize('notebookVariables'),
						store: { fields: ['text'] }
					}],
					listeners: {
						activate: function(crd) {
							this.populateVariables();
						},
						change: function() {
							this.setCorpusId(undefined);
						},
						scope: this
					}
				},{
					itemId: 'file',
					xtype: 'notebookfileinput',
					flex: 1,
					listeners: {
						change: function() {
							this.setCorpusId(undefined);
						},
						scope: this
					}
				},{
					itemId: 'id',
					items: [{
						xtype: 'textfield',
						width: '75%',
						name: 'id',
						fieldLabel: '',
						listeners: {
							change: function() {
								this.setCorpusId(undefined);
							},
							scope: this
						}
					}]
				}]
			},{
				itemId: 'corpusOptions',
				xtype: 'button',
				width: 60,
				margin: '5px 5px 5px 0',
				text: 'Options',
				handler: function(btn) {
					if (this.corpusCreator === undefined) {
						this.corpusCreator = Ext.create('Voyant.panel.CorpusCreator');

					}
					this.corpusCreator.showOptionsClick(this.corpusCreator);
					this.corpusCreator.optionsWin.query('fieldset:last')[0].hide(); // hide access manager
					this.corpusCreator.optionsWin.query('button:first')[0].on('click', function(btn) {
						// reset corpus on OK button click
						this.setCorpusId(undefined);
					}, this, {single: true});
				},
				scope: this
			}],
			listeners: {
				boxready: function(cmp) {
					if (config.type) {
						cmp.down('#type').setValue(config.type);
					}
					if (config.value) {
						var formField = cmp.down('#'+config.type).child();
						if (formField.setRawValue) {
							formField.setRawValue(config.value);
						} else {
							formField.setValue(config.value);
						}
					}
					// set corpusId last, because of change listeners
					if (config.corpusId) {
						cmp.setCorpusId(config.corpusId);
					}

					cmp.up('notebookdatawrapper').results.on('sandboxMessage', function(msg) {
						// use sandbox listener to capture corpusId
						if (msg.type === 'result') {
							var corpusVarName = cmp.up('notebookdatawrapper').getDataName();
							var corpusVal = msg.variables.find(function(variable) { return variable.name === corpusVarName });
							Spyral.Util.blobToString(corpusVal.value).then(function(strVal) {
								var corpusJson = JSON.parse(strVal);
								cmp.setCorpusId(corpusJson.corpusid);
							});
						}
					});

					cmp.up('notebook').on('notebookRun', cmp.populateVariables, cmp);
				}
			}
		});

		this.callParent(arguments);
	},

	populateVariables: function() {
		var cmp = this.up('notebookdatawrapper');
		var prev = cmp.previousSibling();
		var variables = [];
		if (prev !== null) {
			variables = cmp.up('notebook').getNotebookVariables(cmp).map(function(vr) { return [vr.name] });
		}
		var combo = this.down('#variable combo');
		combo.getStore().loadRawData(variables);
		
		var resetCombo = true;
		var currValue = combo.getRawValue();
		variables.forEach(function(variable) {
			if (variable.indexOf(currValue) !== -1) {
				resetCombo = false;
			}
		})
		if (resetCombo) {
			combo.setValue(undefined);
		}
	},

	getCode: function(varName) {
		var dfd = new Ext.Deferred();

		if (this.getCorpusId()) {
			var val = varName+'=new Spyral.Corpus("'+this.getCorpusId()+'")';
			dfd.resolve(val);
		} else {
			var activeItem = this.down('#cards').getLayout().getActiveItem();
			var type = activeItem.getItemId();
			this.setType(type);
			
			var apiParams = {};
			if (this.corpusCreator) {
				Ext.apply(apiParams, this.corpusCreator.getApiParams());
			}
			var apiParamsStr = JSON.stringify(apiParams);
			
			if (type === 'variable') {
				var inputVarName = activeItem.down('combo').getRawValue();
				this.setValue(inputVarName);
				if (inputVarName !== '') {
					var val = 'Spyral.Corpus.load('+inputVarName+','+apiParamsStr+').then(function(){'+varName+'=arguments[0];return '+varName+'.metadata()})';
					dfd.resolve(val);
				} else {
					dfd.reject('No variable specified!');
				}
			} else if (type === 'file') {
				var file = activeItem.getFile();
				this.setValue(activeItem.getFileName());
				Spyral.Util.blobToDataUrl(file).then(function(dataUrl) {
					var val = 'Spyral.Corpus.load(Spyral.Util.dataUrlToBlob(`'+dataUrl+'`),'+apiParamsStr+').then(function(){'+varName+'=arguments[0];return '+varName+'.metadata()})';
					dfd.resolve(val);
				}, function() {
					dfd.reject();
				});
			} else if (type === 'text') {
				var text = activeItem.down('textfield').getValue().replace('"', '\"');
				this.setValue(text);
				if (text !== '') {
					var val = 'Spyral.Corpus.load({input:"'+text+'"},'+apiParamsStr+').then(function(){'+varName+'=arguments[0];return '+varName+'.metadata()})';
					dfd.resolve(val);
				} else {
					dfd.reject('No text entered!');
				}
			} else if (type === 'id') {
				var id = activeItem.down('textfield').getValue().replace('"', '\"');
				this.setValue(id);
				if (id !== '') {
					var val = 'Spyral.Corpus.load({corpus:"'+id+'"}).then(function(){'+varName+'=arguments[0];return '+varName+'.metadata()})';
					dfd.resolve(val);
				} else {
					dfd.reject('No ID entered!');
				}
			}
		}

		return dfd.promise;
	},

	getInput: function() {
		return {
			corpusId: this.getCorpusId(),
			type: this.getType(),
			value: this.getValue()
		}
	},

	getBlob: function() {
		var dfd = new Ext.Deferred();

		var corpusId = this.getCorpusId();
		if (corpusId === undefined) {
			dfd.reject();
		} else {
			Ext.Ajax.request({
				url: Voyant.application.getTromboneUrl(),
				binary: true,
				params: {
					tool: 'corpus.CorpusExporter',
					corpus: corpusId,
					outputFormat: 'zip'
				}
			}).then(function(response) {
				const blob = new Blob([response.responseBytes], {type: 'application/zip'});
				dfd.resolve(blob);
			}, function(err) {
				dfd.reject(err);
			});
		}

		return dfd.promise;
	}
});
Ext.define("Voyant.notebook.editor.DataWrapper", {
	extend: "Voyant.notebook.editor.RunnableEditorWrapper",
	requires: ["Voyant.notebook.editor.CodeEditor", "Voyant.notebook.editor.FileInput", "Voyant.notebook.editor.CorpusInput"],
	alias: "widget.notebookdatawrapper",
	cls: 'notebook-data-wrapper',
	statics: {
		i18n: {
			dataNameAlphanum: 'The data name must contain alphanumeric characters only',
			dataNameAlphastart: 'The data name must not begin with a number'
		}
	},
	config: {
		dataName: undefined
	},

	constructor: function(config) {
		config.mode = config.mode !== undefined ? config.mode : 'json';

		var hasCachedInput = config.mode === 'file' || config.mode === 'corpus';

		var resourceId = undefined;
		var fileName = undefined;
		if (hasCachedInput) {
			resourceId = config.input.resourceId;
			fileName = config.input.fileName;
		}

		this.editor = Ext.create("Voyant.notebook.editor.CodeEditor", {
			content: Ext.Array.from(config.input).join("\n"),
			docs: config.docs, // TODO
			mode: config.mode,
			hidden: hasCachedInput,
			parentWrapper: this
		});

		if (config.mode === 'corpus') {
			this.cachedInput = Ext.create('Voyant.notebook.editor.CorpusInput', config.input);
		} else {
			var cfg = hasCachedInput && config.input !== '' ? config.input : {};
			this.cachedInput = Ext.create('Voyant.notebook.editor.FileInput', Ext.apply(cfg, {hidden: !hasCachedInput, margin: '5px'}));
		}

		var hideResults = !config.output || config.output.indexOf('>undefined<') !== -1;

		this.results = Ext.create('Voyant.notebook.editor.SandboxWrapper', {
			sandboxSrcUrl: Spyral.Load.baseUrl+'spyral/sandbox.jsp', // 'https://beta.voyant-tools.org/spyral/sandbox.jsp',
			expandResults: config.expandResults,
			hidden: hideResults,
			listeners: {
				initialized: function() {
					// pass along initialized
					this.fireEvent('initialized', this);

					if (config.output !== undefined) {
						this.results.updateHtml(config.output);
					}
				},
				scope: this
			}
		});

		Ext.apply(this, {
			border: false,
			layout: 'anchor',
			defaults: { anchor: '100%' },
			items: [this.editor, this.cachedInput, {
				xtype: 'form',
				cls: 'notebook-data-input',
				bodyPadding: 6,
				bodyStyle: 'background-color: rgb(252, 252, 252);',
				layout: {
					type: 'hbox',
					pack: 'center'
				},
				items: [{
					width: 350,
					xtype: 'textfield',
					fieldLabel: 'Data Name',
					labelAlign: 'right',
					name: 'dataName',
					value: config.dataName,
					validator: function(val) {
						if (/^[a-zA-Z0-9_]+$/.test(val)) {
							if (/^\D/.test(val)) {
								return true;
							} else {
								return this.localize('dataNameAlphastart');
							}
						} else {
							return this.localize('dataNameAlphanum')
						}
					}.bind(this),
					allowBlank: false,
					listeners: {
						change: function(cmp, newVal, oldVal) {
							if (cmp.isValid()) {
								this.setDataName(newVal);
							} else {
								this.setDataName(undefined);
							}
						},
						scope: this
					}
				},{
					width: 100,
					margin: '0 0 0 6',
					xtype: 'button',
					text: 'Assign',
					handler: function() {
						if (this.down('textfield[name=dataName]').validate()) {
							this.up('notebook').setIsEdited(true);
							this.run();
						}
					},
					scope: this
				}]
			}, this.results]
		});
		
		this.callParent(arguments);
	},

	switchModes: function(mode) {
		if (mode === 'javascript') {
			var notebook = this.up('notebook');
			notebook.addCode('', this.getIndex(), undefined, {mode: 'javascript'});
			notebook.notebookWrapperRemove(this);
		} else {
			this.setMode(mode);
			
			if (mode === 'file') {
				this.editor.hide();
				if (this.cachedInput.isXType('notebookcorpusinput')) {
					this.cachedInput.destroy();
					this.cachedInput = Ext.create('Voyant.notebook.editor.FileInput', {margin: '5px'});
					this.insert(1, this.cachedInput);
				}
				this.cachedInput.show();
			} else if (mode === 'corpus') {
				this.editor.hide();
				if (this.cachedInput.isXType('notebookfileinput')) {
					this.cachedInput.destroy();
					this.cachedInput = Ext.create('Voyant.notebook.editor.CorpusInput', {});
					this.insert(1, this.cachedInput);
				}
				this.cachedInput.show();
			} else {
				this.cachedInput.hide();
				this.editor.switchModes(mode);
				this.editor.show();
			}
			
			this.updateLayout();
		}
	},

	_getCode: function() {
		var dfd = new Ext.Deferred();

		var dataName = this.getDataName();
		var dataNameField = this.down('textfield[name=dataName]');
		if (dataName === undefined || dataNameField.isValid() === false) {
			dataNameField.markInvalid(dataNameField.getErrors(dataNameField.getValue()));
			dfd.reject();
			return dfd.promise;
		}

		var mode = this.getMode();
		if (mode === 'file' || mode === 'corpus') {
			this.cachedInput.getCode(dataName).then(function(code) {
				dfd.resolve(code);
			}, function() {
				dfd.reject();
			});
		} else {
			var code = this.editor.getValue();
			switch(mode) {
				case 'text':
					code = dataName+'=`'+code+'`';
					break;
				case 'json':
					code = dataName+'= JSON.parse(`'+code+'`)';
					break;
				case 'xml':
					code = dataName+'= new DOMParser().parseFromString(`'+code+'`, "application/xml")';
					break;
				case 'html':
					code = dataName+'= new DOMParser().parseFromString(`'+code+'`, "application/xml")'; // also use xml for strict validation
					break;
			}
			dfd.resolve(code);
		}

		return dfd.promise;
	},

	_run: function(priorVariables) {
		var dfd = new Ext.Deferred();

		var me = this;
		this._getCode().then(function(code) {
			me.results.clear();

			if (me.getMode() !== 'file' && me.getMode() !== 'corpus') {
				me.editor.clearMarkers();
			}

			me.setIsRun(true);
			
			me.results.run(code, priorVariables).then(function(eventData) {
				dfd.resolve(eventData);
			}, function(eventData) {
				if (eventData.error !== undefined) {
					var location = eventData.error.location;
					if (location !== undefined) {
						me.editor.addMarker(location, 'error');
						me.editor.addLineMarker(location, 'error');
					}
				}
				dfd.reject(eventData);
			});
		}, function() {
			dfd.reject('Error handling data');
		});

		return dfd.promise;
	},

	getInput: function() {
		var mode = this.getMode();
		if (mode === 'file' || mode === 'corpus') {
			return this.cachedInput.getInput();
		} else {
			return this.editor.getValue();
		}
	},

	getContent: function() {
		var content = this.callParent(arguments);
		content.dataName = this.getDataName();
		return content;
	}
});

Ext.define("Voyant.notebook.github.OctokitWrapper", {
	extend: "Ext.Base",
	alias: "octokitwrapper",

	octokit: undefined,

	constructor: function(config) {
		const authToken = config.authToken;
		this.octokit = new Octokit({
			auth: authToken,
			userAgent: 'https://github.com/voyanttools/Voyant'
		});
	},

	getInfoForAuthenticatedUser: function() {
		return this.octokit.users.getAuthenticated();
	},

	getReposForAuthenticatedUser: function(affiliation='owner', page=0, per_page=10) {
		return this.octokit.repos.listForAuthenticatedUser({
			affiliation,
			page,
			per_page
		});
	},

	getReposForUser: function(owner, page=0, per_page=10) {
		return this.octokit.search.repos({
			q: 'user:'+owner,
			page,
			per_page
		})
	},

	searchWithinRepositories: function(query, page=0, per_page=10) {
		console.log(query);
	},

	getRepoContents: function(repoId) {
		let {owner, repo} = this.parseFullName(repoId);
		return this.getBranchSHAs({owner, repo, branch: 'master'}).then(function(resp) {
			return this.getTreeContentsRecursively(resp);
		}.bind(this));
	},

	getTreeContentsRecursively: function(params) {
		return this.octokit.git.getTree({
			owner: params.owner,
			repo: params.repo,
			tree_sha: params.baseTreeSHA,
			recursive: 1,
			headers: {
				'If-None-Match': '' // cache busting
			}
		}).then(function (resp) {
			return {
				...params,
				contents: this.unflattenContents(resp.data.tree),
				truncated: resp.data.truncated
			}
		}.bind(this));
	},

	loadFile: function(repoId, path) {
		let {owner, repo} = this.parseFullName(repoId);
		let ref = 'master';
		return this.octokit.repos.getContents({
			owner, repo, ref, path
		}).then(function(resp) {
			return {
				owner, repo, ref, path,
				sha: resp.data.sha,
				file: atob(resp.data.content)
			}
		}.bind(this));
	},

	// SAVING

	doesRepoExist: function(owner, repo) {
		return this.getRepoContents(owner+'/'+repo).then(function(resp) {
			return true;
		}.bind(this), function(err) {
			console.log(err);
			return false;
		}.bind(this));
	},

	getPermissionsForUser: function(owner, repo, username) {
		return this.octokit.repos.getCollaboratorPermissionLevel({
			owner, repo, username
		}).then(function(resp) {
			return resp.data.permission;
		}.bind(this), function(err) {
			return 'none';
		}.bind(this));
	},

	saveFile: async function(owner, repo, path, content, branch, message, sha) {
		if (sha === undefined) {
			sha = await this.getLatestFileSHA({owner, repo, branch, path})
		}
		return this.octokit.repos.createOrUpdateFile({owner, repo, path, content: btoa(content), branch, message, sha});
	},

	// UTILITIES

	parseFullName: function(fullName) {
		let [owner, repo] = fullName.split('/');
		return {owner, repo};
	},

	getBranchSHAs: function(params) {
		return this.octokit.repos.getBranch({
			owner: params.owner,
			repo: params.repo,
			branch: params.branch,
			headers: {
				'If-None-Match': '' // cache busting
			}
		}).then((resp) => {
			return {
				...params,
				baseTreeSHA: resp.data.commit.commit.tree.sha,
				parentCommitSHA: resp.data.commit.sha
			}
		})
	},

	getLatestFileSHA: async function(params) {
		const {owner, repo, branch, path} = params
		const {data: {data: {repository: {object: result}}}} = await this.octokit.request({
			method: 'POST',
			url: '/graphql',
			query: `{
				repository(owner: "${owner}", name: "${repo}") {
					object(expression: "${branch}:${path}") {
						... on Blob {
							oid
						}
					}
				}
			}`
		}).catch(function(error) {
			console.log(error);
		});
		const sha = result ? result.oid : undefined
		return sha
	},

	unflattenContents: function(flatContents) {
		const files = flatContents.filter(file=>file.type==='blob')
		var result = {type: 'folder', name: '', path: '', contents: []}
		const findSubFolder = (parentFolder, folderNameToFind) => {
			 const subfolder = parentFolder.contents.find(el => {
			 	return el.type === 'folder' && el.name === folderNameToFind
			 })
			return subfolder;
		}
		const addSubFolder = (newFolderName, parentFolder) => {
			const newSubFolder = {type: 'folder', name: newFolderName, path: `${parentFolder.path}/${newFolderName}`, contents:[]}
			parentFolder.contents.push(newSubFolder)
			return newSubFolder;
		}
		const addFile = (newFileName, parentFolder) => {
			const newFile = {type: 'file', name: newFileName, path: `${parentFolder.path}/${newFileName}`}
			parentFolder.contents.push(newFile)
		}
		const isFile = (pathSections, currentIndex) => {
			return pathSections.length - 1 == currentIndex
		}

		files.forEach(file=>{
			const pathSections = file.path.split('/')
			pathSections.reduce(function(parentFolder, pathSection, pathSectionIndex) {
				const subFolder = findSubFolder(parentFolder, pathSection)
				if (subFolder) {
					return subFolder
				} else if (isFile(pathSections, pathSectionIndex)) {
					return addFile(pathSection, parentFolder)
				} else {
					return addSubFolder(pathSection, parentFolder)
				}
			}, result)
		})
		return result
	}
});

Ext.define("Voyant.notebook.github.ReposBrowser", {
	extend: "Ext.container.Container",
	xtype: "githubreposbrowser",
	config: {
		repoType: 'owner',
		selectedNode: undefined,
		repoId: undefined,
		path: undefined
	},

	octokit: undefined,

	constructor: function(config) {
		config = config || {};
		
		this.octokit = config.octokit;

    	this.callParent(arguments);
    },

	initComponent: function() {
		Ext.apply(this, {
			layout: {
				type: 'hbox',
				align: 'stretch',
				pack: 'start'
			},
			items: [{
				layout: {
					type: 'vbox',
					align: 'stretch',
					pack: 'start'
				},
				flex: 1,
				items: [{
					layout: {
						type: 'accordion'
					},
					items: [{
						title: 'My Repositories',
						frame: true,
						items: {
							xtype: 'radiogroup',
							fieldLabel: 'Show repositories for which I am',
							labelAlign: 'top',
							layout: 'vbox',
							items: [{
								boxLabel: 'Owner',
								name: 'repoType',
								inputValue: 'owner',
								checked: true
							},{
								boxLabel: 'Collaborator',
								name: 'repoType',
								inputValue: 'collaborator'
							},{
								boxLabel: 'Organization Member',
								name: 'repoType',
								inputValue: 'organization_member'
							}],
							listeners: {
								change: function(field, newValues, oldValue) {
									this.setRepoType(newValues.repoType);
									this.clearTree(true);
									this.octokit.getReposForAuthenticatedUser(this.getRepoType(), 0, 100).then((resp) => {
										this.addReposToTree(resp.data);
									},(error) => {
										console.log(error);
									})
								},
								scope: this
							}
						},
						listeners: {
							expand: function() {
								this.clearTree(true);
								this.octokit.getReposForAuthenticatedUser(this.getRepoType(), 0, 100).then((resp) => {
									this.addReposToTree(resp.data);
								},(error) => {
									console.log(error);
								})
							},
							scope: this
						}
					},{
						title: 'Public Repositories',
						frame: true,
						layout: 'vbox',
						items: [{
							fieldLabel: 'Limit to user or organization',
							labelAlign: 'top',
							xtype: 'textfield'
						},{
							text: 'Search',
							xtype: 'button',
							handler: function(button) {
								let repoOwner = button.prev('textfield').getValue();
								if (repoOwner !== '') {
									this.clearTree(true);
									this.octokit.getReposForUser(repoOwner, 0, 100).then((resp) => {
										this.addReposToTree(resp.data.items);
									},(error) => {
										console.log(error);
									})
								}
							},
							scope: this
						}],
						listeners: {
							expand: function() {
								this.clearTree();
							},
							scope: this
						}
					}]
				}
				// ,{
				// 	padding: '20 0 0 0',
				// 	items: [{
				// 		fieldLabel: 'Search within repositories',
				// 		labelAlign: 'top',
				// 		xtype: 'textfield'
				// 	},{
				// 		xtype: 'button',
				// 		text: 'Search',
				// 		margin: '0 5 0 0',
				// 		handler: function(button) {
				// 			let query = button.prev('textfield').getValue();
				// 			if (query !== '') {
				// 				this.searchWithinRepositories(query);
				// 			}
				// 		},
				// 		scope: this
				// 	},{
				// 		xtype: 'button',
				// 		text: 'Clear',
				// 		handler: function(button) {
							
				// 		},
				// 		scope: this
				// 	}]
				// }
				]
			},{
				flex: 2,
				layout: 'fit',
				xtype: 'treepanel',
				itemId: 'repoTree',
				title: 'Repositories',
				scrollable: true,
				rootVisible: false,
				viewConfig: {
					emptyText: 'No results',
					listeners: {
						afteritemexpand: function(node, index, el) {
							if (node.hasChildNodes() === false) {
								switch(node.data.type) {
									case 'repo':
										let tr = el.querySelector('tr');
										Ext.fly(tr).addCls('x-grid-tree-loading');
										this.octokit.getRepoContents(node.getId()).then(function(resp) {
											Ext.fly(tr).removeCls('x-grid-tree-loading');
											this.addRepoContentsToNode(node, resp);
										}.bind(this))
										break;
									case 'folder':
										break;
								}
							}
						},
						itemclick: function(view, node, el) {
							this.setSelectedNode(node);
							this.fireEvent('nodeSelected', this, node.data.type, node);
						},
						scope: this
					}
				},
				store: {
					root: {
						name: 'Root',
						children: []
					}
				}
			}],
			listeners: {
				boxready: function() {
					this.down('#repoTree').setLoading(true);
					this.octokit.getReposForAuthenticatedUser(this.getRepoType(), 0, 100).then((resp) => {
						this.addReposToTree(resp.data);
					},(error) => {
						console.log(error);
					})
				}
			}
		});
		this.callParent(arguments);
	},

	updateSelectedNode: function(node, oldValue) {
		if (node !== undefined) {
			let repoParent = node;
			while (repoParent !== null && repoParent.data.type !== 'repo') {
				repoParent = repoParent.parentNode;
			}

			this.setRepoId(repoParent.getId());
			this.setPath(node.getId());
		} else {
			this.setRepoId(undefined);
			this.setPath(undefined);
		}
	},

	clearTree: function(setLoading) {
		let repoTree = this.down('#repoTree');
		let root = repoTree.getRootNode();
		root.removeAll();
		repoTree.getView().refresh();

		if (setLoading) {
			repoTree.setLoading(true);
		}

		this.setSelectedNode(undefined);
		this.fireEvent('nodeDeselected', this);
	},

	addReposToTree: function(rawRepos) {
		let repoTree = this.down('#repoTree');
		repoTree.setLoading(false);
		let root = repoTree.getRootNode();
		let repos = rawRepos.map((repo) => {
			return {
				id: repo.full_name,
				text: repo.full_name,
				description: repo.description,
				leaf: false,
				type: 'repo'
			}
		});
		root.appendChild(repos);
	},

	addRepoContentsToNode: function(node, octokitResponse) {
		function parseContents(content) {
			let nodeConfig = {
				id: content.path,
				text: content.name,
				type: content.type,
				leaf: content.type === 'file'
			};
			if (nodeConfig.leaf === false) {
				nodeConfig.children = [];
				content.contents.forEach((child) => {
					nodeConfig.children.push(parseContents(child));
				})
			}
			return nodeConfig;
		}
		let contents = parseContents(octokitResponse.contents);
		node.appendChild(contents.children);
	}
})
Ext.define("Voyant.notebook.github.FileSaver", {
	extend: "Ext.container.Container",
	xtype: "githubfilesaver",
	config: {
		currentFile: undefined,
		username: undefined
	},

	octokit: undefined,
	saveData: undefined,

	constructor: function(config) {
		config = config || {};
		
		this.octokit = config.octokit;
		this.saveData = config.saveData;

		this.setCurrentFile(config.currentFile);

    	this.callParent(arguments);
    },

	initComponent: function() {
		Ext.apply(this, {
			layout: {
				type: 'vbox',
				pack: 'start',
				align: 'stretch'
			},
			items: [{
				xtype: 'githubreposbrowser',
				octokit: this.octokit,
				itemId: 'repoBrowser',
				flex: 1,
				listeners: {
					nodeSelected: function(src, type, node) {
						const form = this.queryById('saveForm').getForm();
						const [owner, repo] = src.getRepoId().split('/');
						form.setValues({owner, repo});
						if (type === 'file') {
							const pathComponents = this.getPathComponents(src.getPath());
							form.setValues({...pathComponents});
						} else if (type === 'folder') {
							const folder = src.getPath().replace(/^\//, '');
							form.setValues({folder, file: ''});
						} else if (type === 'repo') {
							form.setValues({folder: '', file: ''});
						}
					},
					nodeDeselected: function(node) {
						// loadWin.queryById('load').setDisabled(true);
					},
					scope: this
				}
			},{
				bodyPadding: '10',
				height: 200,
				layout: {
					type: 'vbox',
					pack: 'start'
				},
				xtype: 'form',
				itemId: 'saveForm',
				items: [{
					html: '<span class="x-panel-header-title-default">Repository Path</span>'
				},{
					xtype: 'container',
					layout: 'hbox',
					defaults: {
						xtype: 'textfield',
						labelAlign: 'top'
					},
					items: [{
						fieldLabel: 'GitHub User',
						name: 'owner',
						allowBlank: false,
						margin: '0 10 0 0'
					},{
						fieldLabel: 'Repository Name',
						allowBlank: false,
						name: 'repo'
					}]
				},{
					html: '<span class="x-panel-header-title-default">File Path</span>',
					margin: '10 0 0 0',
				},{
					xtype: 'container',
					layout: 'hbox',
					defaults: {
						xtype: 'textfield',
						labelAlign: 'top'
					},
					items: [{
						fieldLabel: 'Folder(s)',
						name: 'folder',
						allowBlank: true,
						margin: '0 10 0 0'
					},{
						fieldLabel: 'File Name',
						allowBlank: false,
						name: 'file'
					}]
				},{
					/*
					xtype: 'container',
					width: '100%',
					layout: {
						type: 'hbox',
						align: 'middle',
						pack: 'start'
					},
					margin: '25 0 0 0',
					defaults: {
						xtype: 'button'
					},
					items: [{
						text: 'Save',
						handler: function () {
							this.doSave(false);
						},
						scope: this,
						margin: '0 10 0 0'
					}
					// ,{
					// 	text: 'Save as Pull Request',
					// 	handler: function () {
					// 		this.doSave(true);
					// 	},
					// 	scope: this
					// }
					]
				},{
					*/
					itemId: 'status',
					html: '',
					margin: '15 0 0 0'
				}],
				listeners: {
					validitychange: function(form, valid) {
						this.fireEvent('formValidityChange', this, valid);
					},
					scope: this
				}
			}],
			listeners: {
				boxready: function() {
					this.initForm();
				},
				scope: this
			}
		});

		this.callParent(arguments);
	},

	initForm: function() {
		this.octokit.getInfoForAuthenticatedUser().then(function(resp) {
			const username = resp.data.login;
			this.setUsername(username);

			const form = this.queryById('saveForm').getForm();
			const currentFile = this.getCurrentFile();			
			if (currentFile !== undefined) {
				const pathComponents = this.getPathComponents(currentFile.path);
				form.setValues({
					owner: currentFile.owner,
					repo: currentFile.repo,
					...pathComponents
				});
			} else {
				form.setValues({owner: username});
			}
		}.bind(this))
	},

	getPathComponents: function(path) {
		const pathComponents = path.split('/');
		let file = pathComponents[pathComponents.length-1];
		let folder = '';
		if (pathComponents.length > 2) {
			folder = pathComponents.slice(0, -1).join('/');
		}
		return {
			folder,
			file
		}
	},

	doSave: async function(isPR=false) {
		const form = this.queryById('saveForm').getForm();
		if (form.isValid()) {
			const {owner, repo, folder, file} = form.getValues();
			let path = file;
			if (folder !== '') {
				path = folder+'/'+file;
			}
			this.setStatus('Checking repository');
			const repoExists = await this.octokit.doesRepoExist(owner, repo);
			if (repoExists) {
				this.setStatus('Checking permissions');
				const permission = await this.octokit.getPermissionsForUser(owner, repo, this.getUsername());
				if (permission === 'none' || permission === 'read') {
					this.setStatus('You don\'t have permission to write to this repository', 'error');
				} else {
					this.setStatus('Checking file');
					const branch = 'master';
					const content = this.saveData;
					const fileData = {owner, repo, branch, path};
					const sha = await this.octokit.getLatestFileSHA(fileData);
					if (sha !== undefined) {
						const message = 'File updated by Spyral';
						this.octokit.saveFile(owner, repo, path, content, branch, message, sha).then(function(resp) {
							this.setStatus('File updated');
							setTimeout(function() {
								this.fireEvent('fileSaved', this, fileData);
							}.bind(this), 500);
						}.bind(this), function(error) {
							this.setStatus('Error: '+error.message, 'error');
						});
					} else {
						const message = 'File created by Spyral';
						this.octokit.saveFile(owner, repo, path, content, branch, message).then(function(resp) {
							this.setStatus('File created');
							setTimeout(function() {
								this.fireEvent('fileSaved', this, fileData);
							}.bind(this), 500);
						}.bind(this), function(error) {
							this.setStatus('Error: '+error.message, 'error');
						});
					}
				}
			} else {
				this.setStatus('The specified repository does not exist', 'error');
			}
		} else {
			this.setStatus('Form is not valid', 'error');
		}
	},

	setStatus: function(message, type) {
		let cls = '';
		if (type && type === 'error') {
			cls = 'x-form-invalid-under-default';
		}
		this.queryById('status').setHtml(`<span class="${cls}">${message}</span>`);
	}
});

Ext.define("Voyant.notebook.github.GitHubDialogs", {
	extend: "Ext.Component",
	requires: ['Voyant.notebook.github.OctokitWrapper','Voyant.notebook.github.ReposBrowser','Voyant.notebook.github.FileSaver'],
	alias: "widget.githubdialogs",
	config: {
		repoType: 'owner',
		currentFile: undefined
	},

	octokitWrapper: undefined,

	currentWindow: undefined,

	parent: undefined,

	constructor: function(config) {
		config = config || {};
		this.parent = config.parent;
    	this.callParent(arguments);
    },

	initComponent: function() {
		this.callParent(arguments);
	},

	close: function() {
		if (this.currentWindow !== undefined) {
			this.currentWindow.close();
			this.currentWindow = undefined;
		}
	},

	showLoad: function() {
		const me = this;

		if (this.parent.isAuthenticated) {
			if (this.octokitWrapper === undefined) {
				this.initOctokitWrapper(this.parent.githubAuthToken);
			}
		} else {
			this.parent.showGitHubAuthentication(this.showLoad.bind(this));
			return;
		}

		let loadWin = undefined;
		loadWin = Ext.create('Ext.window.Window', {
			title: 'Load from GitHub',
			width: 750,
			height: 550,
			closable: false,
			maximizable: true,
			layout: 'fit',
			items: {
				xtype: 'githubreposbrowser',
				octokit: this.octokitWrapper,
				itemId: 'repoBrowser',
				listeners: {
					nodeSelected: function(src, type, node) {
						if (type === 'file') {
							loadWin.queryById('load').setDisabled(false);
						} else {
							loadWin.queryById('load').setDisabled(true);	
						}
					},
					nodeDeselected: function(node) {
						loadWin.queryById('load').setDisabled(true);
					}
				}
			},
			buttons: [{
				text: 'Load Selected',
				itemId: 'load',
				disabled: true,
				handler: function() {
					const repoBrowser = loadWin.queryById('repoBrowser');
					this.loadFile(repoBrowser.getRepoId(), repoBrowser.getPath());
				},
				scope: this
			},{
				text: 'Cancel',
				handler: function() {
					me.close();
				}
			}]
		});
		loadWin.show();

		this.currentWindow = loadWin;
	},

	showSave: function(data) {
		const me = this;

		if (this.parent.isAuthenticated) {
			if (this.octokitWrapper === undefined) {
				this.initOctokitWrapper(this.parent.githubAuthToken);
			}
		} else {
			this.parent.showGitHubAuthentication(this.showSave.bind(this));
			return;
		}

		let saveWin = undefined;
		saveWin = Ext.create('Ext.window.Window', {
			title: 'Save to GitHub',
			width: 750,
			height: 650,
			closable: false,
			maximizable: true,
			layout: 'fit',
			items: {
				xtype: 'githubfilesaver',
				octokit: this.octokitWrapper,
				currentFile: this.getCurrentFile(),
				saveData: data,
				itemId: 'fileSaver',
				listeners: {
					formValidityChange: function(src, valid) {
						saveWin.queryById('save').setDisabled(!valid);
					},
					fileSaved: function(src, fileData) {
						me.fireEvent('fileSaved', me, fileData);
					}
				}
			},
			buttons: [{
				text: 'Save',
				itemId: 'save',
				disabled: true,
				handler: function() {
					saveWin.queryById('fileSaver').doSave();
				},
				scope: this
			},{
				text: 'Cancel',
				handler: function() {
					me.close();
					me.fireEvent('saveCancelled', me);
				}
			}]
		});
		saveWin.show();

		this.currentWindow = saveWin;
	},

	initOctokitWrapper: function(authToken) {
		this.octokitWrapper = new Voyant.notebook.github.OctokitWrapper({
			authToken: authToken
		});
	},

	loadFileFromId: function(id) {
		const parts = decodeURIComponent(id).split('/');
		if (parts.length >= 3) {
			const repoId = parts[0]+'/'+parts[1];
			const filePath = parts.slice(2).join('/');
			this.loadFile(repoId, filePath);
		}
	},

	loadFile: function(repoId, filePath) {
		if (this.parent.isAuthenticated) {
			if (this.octokitWrapper === undefined) {
				this.initOctokitWrapper(this.parent.githubAuthToken);
			}
		} else {
			this.parent.showGitHubAuthentication(this.loadFile.bind(this));
			return;
		}

		this.octokitWrapper.loadFile(repoId, filePath).then((data) => {
			this.setCurrentFile(data);
			this.fireEvent('fileLoaded', this, data);
		});
	}
})

Ext.define("Voyant.notebook.StorageDialogs", {
	extend: "Ext.Component",
	mixins: ["Voyant.util.Localization"],
	alias: "",
	statics: {
		i18n: {
			saveNewNotebook: 'Save New Notebook',
			overwriteNotebook: 'Overwrite Existing Notebook',
			open: 'Open',
			notebookFile: 'Notebook File',
			selectFile: 'Select File',
			openFile: 'Open File',
			cancel: 'Cancel',
			mustSelect: 'You must select a file.'
		}
	},

	notebookParent: undefined,

	constructor: function(config) {
		config = config || {};
    	this.callParent(arguments);

		this.notebookParent = config.notebookParent;
    },

	initComponent: function() {
		this.callParent(arguments);
	},
	
	showSave: function(data, metadata, notebookName='') {
		const me = this;
		const newNotebook = notebookName === '';
		const title = newNotebook ? this.localize('saveNewNotebook') : this.localize('overwriteNotebook');
		Ext.create('Ext.window.Window', {
			title: title,
			items: [{
				xtype: 'form',
				width: 450,
				bodyPadding: 5,
				plugins: ['datatip'],
				listeners: {
					beforeshowtip: function(tip, config, msg) {
						return !config.currentTarget.el.hasCls('x-form-invalid'); // don't show tooltip if the field is invalid because otherwise the two tips overlap
					}
				},
				layout: 'anchor',
				defaults: {
					labelAlign: 'right',
					labelWidth: 160,
					width: 360,
					inputAttrTpl: 'spellcheck="false"',
					xtype: 'textfield'
				},
    	    	items: [{
					fieldLabel: 'Notebook ID' + (newNotebook ? ' (optional)' : ''),
					name: 'notebookName',
					value: notebookName,
					allowBlank: true,
					readOnly: !newNotebook,
					tooltip: 'An ID used to identify this notebook. If left blank, one will be generated for you.',
					validator: function(val) {
						if (val == '') {
							return true;
						} else if (val.match(/^[A-Za-z0-9-]{4,32}$/) === null) {
							return 'The ID must be between 4 and 32 characters. You may use alphanumeric characters and dash.'
						} else {
							return true;
						}
					}
				}]
			}],
			buttons: [{
    	        text: 'Cancel',
	            ui: 'default-toolbar',
    	        handler: function() {
    	            this.up('window').close();
					me.fireEvent('saveCancelled', me);
    	        }
    	    }, " ", {
    	        text: 'Save',
    	        handler: function(button) {
					const win = button.up('window');
					const form = win.down('form').getForm();
					if (form.isValid()) {
						const values = form.getValues();
						values.data = data;
						values.metadata = metadata;
						if (newNotebook && values.notebookName !== '') {
							const info = me.notebookParent.accountInfo;
							const userId = info.id;
							me.doesNotebookExist(userId, values.notebookName).then(function(exists) {
								if (exists) {
									form.findField('notebookName').markInvalid('That Notebook ID already exists.');
								} else {
									me.doSave(values);
									win.close();
								}
							});
						} else {
							button.setDisabled(true);
							me.doSave(values).then(function(didSave) {
								button.setDisabled(false);
								if (didSave) {
									win.close();
								} else {
									// TODO show error
								}
							});
						}
					}
    	        }
			}],
			listeners: {
				close: function() {
					me.fireEvent('close', me); // need an additional close event in case the user uses the close tool / esc button
				}
			}
		}).show();
	},

	showLoad: function() {
		const me = this;
		Ext.create('Ext.window.Window', {
			title: me.localize('open'),
			items: [{
				xtype: 'form',
				width: 450,
				bodyPadding: 5,
				layout: 'anchor',
				defaults: {
					labelAlign: 'right',
					labelWidth: 160,
					width: 360
				},
				items: [{
					xtype: 'voyantfilefield',
					name: 'file',
					fieldLabel: me.localize('notebookFile'),
					allowBlank: false,
					buttonText: me.localize('selectFile'),
					accept: 'text/html,application/json'
				}],
				buttons: [{
					text: me.localize('cancel'),
					ui: 'default-toolbar',
					handler: function() {
						this.up('window').close();
					}
				},{
					text: me.localize('openFile'),
					handler: function(button) {
						const win = button.up('window');
						const form = win.down('form').getForm();
						const field = form.findField('file');
						if (form.isValid()) {
							const file = field.fileInputEl.dom.files[0];
							const fr = new FileReader();
							fr.onload = function(evt) {
								const data = evt.target.result;
								me.fireEvent('fileLoaded', data);
								win.close();
							}
							fr.readAsText(file);
						} else {
							field.markInvalid(me.localize('mustSelect'));
						}
					}
				}]
			}]
		}).show();
	},

	doesNotebookExist: function(userId, notebookName) {
		const dfd = new Ext.Deferred();

		Spyral.Load.trombone({
			tool: 'notebook.GitNotebookManager',
			action: 'exists',
			id: userId+this.notebookParent.NOTEBOOK_ID_SEPARATOR+notebookName,
			noCache: 1
		}).then(function(json) {
			if (json.notebook.success) {
				var exists = json.notebook.data === 'true';
				dfd.resolve(exists);
			} else {
				console.warn(json.notebook.error);
				dfd.resolve(false);
			}
		}).catch(function(err) {
			console.warn(err);
		});

		return dfd.promise;
	},

	doSave: function({notebookName, data, metadata}) {
		const me = this;

		const dfd = new Ext.Deferred();

		if (notebookName.indexOf(this.notebookParent.NOTEBOOK_ID_SEPARATOR) !== -1) {
			console.warn('doSave: was sent notebookId instead of name');
			notebookName = notebookName.split(this.notebookParent.NOTEBOOK_ID_SEPARATOR)[1];
		}

		var totalData = {data: data, metadata: JSON.stringify(metadata)};
		console.log('notebook size:',JSON.stringify(totalData).length);
		// TODO use form & isUpload options below, to handle large notebooks
		// https://docs.sencha.com/extjs/6.2.0/classic/Ext.Ajax.html#method-request

		Ext.Ajax.request({
			method: 'POST',
			url: Voyant.application.getBaseUrlFull()+'spyral/account/save',
			params: {
				name: notebookName,
				data: data,
				metadata: JSON.stringify(metadata)
			},
			success: function(resp) {
				const json = JSON.parse(resp.responseText);
				if (json.notebook.success) {
					me.fireEvent('fileSaved', me, json.notebook.id);
					dfd.resolve(true);
				} else {
					me.fireEvent('fileSaved', me, null, json.notebook.error);
					dfd.reject(false);
				}
			},
			failure: function(resp) {
				me.fireEvent('fileSaved', me, null, resp.responseText);
				dfd.reject(false);
			}
		});

		return dfd.promise;
	},

	reset: function() {
	}
})
Ext.define('Voyant.notebook.metadata.MetadataEditor', {
	extend: 'Ext.form.Panel',
	mixins: ['Voyant.util.Localization'],
	alias: 'widget.metadataeditor',
	statics: {
		i18n: {
			metadataAuthor: "Author(s)",
    		metadataTitle: "Title",
    		metadataTip: "Edit notebook metadata.",
    		metadataKeywords: "Keywords",
    		metadataDescription: "Description",
    		metadataLicense: "Licence",
    		metadataLanguage: "Language",
			metadataCatalogue: "Catalogue",
			metadataCatalogueInclude: "Include this notebook in the public Catalogue?"
		}
	},

	constructor: function(config) {
		Ext.apply(this, config, {
			trackResetOnLoad: true,
			items: {
				bodyPadding: 5,

				// Fields will be arranged vertically, stretched to full width
				layout: 'anchor',
				defaults: {
					anchor: '100%',
					labelAlign: "right"
				},

				// The fields
				defaultType: 'textfield',
				items: [{
					fieldLabel: this.localize("metadataAuthor"),
					name: 'author'
				},{
					fieldLabel: this.localize("metadataTitle"),
					name: 'title'
				},{
					fieldLabel: this.localize("metadataKeywords"),
					name: 'keywords',
					xtype: 'tagfield',
					store: {
						xtype: 'store.json',
						fields: [
							{name: 'label'},
							{name: 'count', type: 'integer'}
						]
					},
					displayField: 'label',
					valueField: 'label',
					queryMode: 'local',
					filterPickList: true,
					forceSelection: false,
					delimiter: ',',
					createNewOnEnter: true,
					listeners: {
						afterrender: function(cmp) {
							Spyral.Load.trombone({
								tool: 'notebook.CatalogueFacets',
								facets: 'facet.keywords',
								noCache: 1
							}).then(function(json) {
								cmp.getStore().loadRawData(json.catalogue.facets[0].results);
								// need to reset value to make sure previously set keywords show up
								cmp.setValue(cmp.getValue());
							});
						}
					}
				},{
					xtype: 'checkbox',
					fieldLabel: this.localize('metadataCatalogue'),
					boxLabel: this.localize('metadataCatalogueInclude'),
					name: 'catalogue',
					inputValue: 'true'
				},{
					xtype: 'textarea',
					fieldLabel: this.localize("metadataDescription"),
					name: 'description'
				},{
					xtype: 'combo',
					fieldLabel: this.localize("metadataLicense"),
					name: 'license',
					store: {
						fields: ['text'],
						data: [
							{"text": "Apache License 2.0"},
							{"text": "BSD 3-Clause \"New\" or \"Revised\" license"},
							{"text": "BSD 2-Clause \"Simplified\" or \"FreeBSD\" license"},
							{"text": "Creative Commons Attribution (CC BY)"},
							{"text": "Creative Commons Attribution-ShareAlike (CC BY-SA)"},
							{"text": "Creative Commons Zero (CC0)"},
							{"text": "GNU General Public License (GPL)"},
							{"text": "GNU Library or \"Lesser\" General Public License (LGPL)"},
							{"text": "MIT license"},
							{"text": "Mozilla Public License 2.0"},
							{"text": "Common Development and Distribution License"},
							{"text": "Eclipse Public License"}
						]
					}
				},{
					xtype: 'combo',
					name: 'language',
					fieldLabel: this.localize("metadataLanguage"),
					store: {
						fields: ['text'],
						data: [
							{"text": "Bengali"},
							{"text": "Bhojpuri"},
							{"text": "Egyptian Arabic"},
							{"text": "English"},
							{"text": "French"},
							{"text": "German"},
							{"text": "Gujarati"},
							{"text": "Hausa"},
							{"text": "Hindi"},
							{"text": "Indonesian"},
							{"text": "Italian"},
							{"text": "Japanese"},
							{"text": "Javanese"},
							{"text": "Kannada"},
							{"text": "Korean"},
							{"text": "Mandarin"},
							{"text": "Marathi"},
							{"text": "Persian"},
							{"text": "Portuguese"},
							{"text": "Russian"},
							{"text": "Southern Min"},
							{"text": "Spanish"},
							{"text": "Standard Arabic"},
							{"text": "Swahili"},
							{"text": "Tamil"},
							{"text": "Telugu"},
							{"text": "Thai"},
							{"text": "Turkish"},
							{"text": "Urdu"},
							{"text": "Vietnamese"},
							{"text": "Western Punjabi"},
							{"text": "Wu Chinese"},
							{"text": "Yue Chinese"}
						]
					}
				}]
			}
		});
		this.callParent(arguments);
	},
	loadMetadata: function(metadata) {
		if (metadata instanceof Spyral.Metadata) {
			this.loadRecord(Ext.create('Voyant.data.model.NotebookMetadata', {
				title: metadata.title,
				userId: metadata.userId,
				author: metadata.author,
				catalogue: metadata.catalogue,
				description: metadata.description,
				keywords: metadata.keywords,
				language: metadata.language,
				license: metadata.license
			}));
		}
	}
});

Ext.define('Voyant.data.model.NotebookMetadata', {
	extend: 'Ext.data.Model',
	fields: [
		{name: 'title', type: 'string'},
		{name: 'userId', type: 'string'},
		{name: 'author', type: 'string'},
		{name: 'catalogue', type: 'boolean', defaultValue: false},
		{name: 'description', type: 'string'},
		{name: 'keywords', type: 'string'},
		{name: 'language', type: 'string', defaultValue: 'English'},
		{name: 'license', type: 'string', defaultValue: 'Creative Commons Attribution (CC BY)'},
		{name: 'modified', type: 'date'},
		{name: 'created', type: 'date'}
	]
});
Ext.define('Voyant.notebook.util.FormatConverter', {
	importFromHtml: function(html) {
		var me = this;

		var parser = new DOMParser();
		var dom = parser.parseFromString(html, 'text/html');
		
		me.setMetadata(new Spyral.Metadata(dom));
		
		var hasDomError = false;
		var cells2Init = [];
		dom.querySelectorAll("section.notebook-editor-wrapper").forEach(function(section) {
			var classes = section.classList;
			if (classes.contains("notebooktexteditorwrapper")) {
				var editor = section.querySelector(".notebook-text-editor").innerHTML;
				me.addText(editor, undefined, section.id);
			} else if (classes.contains("notebookcodeeditorwrapper") || classes.contains("notebookdatawrapper")) {
				var inputEl = section.querySelector(".notebook-code-editor-raw");
				var typeRe = /\beditor-mode-(\w+)\b/.exec(inputEl.className);
				var editorType = typeRe[1];
				var matchClass = 'notebookcodeeditorwrapper';
				if (editorType !== 'javascript') {
					matchClass = 'notebookdatawrapper';
				}
				
				/* in an ideal world we could use inputEl.innerHTML to get the contents
				 * except that since it's in a parsed DOM it's already been transformed
				 *  significantly. For instance, all >, <, and & character appear in the
				 * html entities form (which breaks things like && () => {}). You also
				 * get strange artefacts like if you have "<div>" in your code it may add
				 * </div> to the end of the innerHTML (to make sure tags are balanced).
				 * and of course textContent or innerText won't work because that will
				 * strip any of the HTML formatting out. What's left is to use the parsing
				 * to ensure the order and to properly grab the IDs and then to do character
				 * searches on the original string. */
				var secPos = html.indexOf("<section id='"+section.id+"' class='notebook-editor-wrapper "+matchClass+"'>");
				var startPre = html.indexOf("<pre class='notebook-code-editor-raw editor-mode-", secPos);
				startPre = html.indexOf(">", startPre)+1; // add the length of the string
				var endPre = html.indexOf("</pre>\n<div class='notebook-code-results", startPre);
				
				// check if we have valid values
				if (secPos===-1 || startPre === -1 || endPre === -1) {
					hasDomError = true;
					// this might work, unless the js code includes HTML
					input = editorType === "javascript" ? inputEl.innerText : inputEl.innerHTML;
				} else {
					input = html.substring(startPre, endPre);
				}

				var output = section.querySelector(".notebook-code-results").innerHTML;
				var expandResults = section.querySelector(".notebook-code-results").classList.contains('collapsed') === false;

				if (editorType === 'javascript') {
					var codeCell = me.addCode({
						input: input,
						output: output,
						expandResults: expandResults,
						mode: editorType
					}, undefined, section.id);
	
					cells2Init.push(codeCell);
					codeCell.on('initialized', function() {
						var cellIndex = cells2Init.indexOf(codeCell);
						if (cellIndex !== -1) {
							cells2Init.splice(cellIndex, 1);
							if (cells2Init.length === 0) {
								me.fireEvent('notebookInitialized');
							}
						} else {
							console.error('unknown cell initialized', codeCell);
						}
					});
				} else {
					// hack to get the data name from the dataviewer
					var dataName = section.querySelector('.notebook-code-results .spyral-dv-left').firstChild.data;
					dataName = dataName.split(':')[0];
					var dataCell = me.addData({
						input: input,
						output: output,
						expandResults: expandResults,
						dataName: dataName,
						mode: editorType
					}, undefined, section.id);
					cells2Init.push(dataCell);
					dataCell.on('initialized', function() {
						var cellIndex = cells2Init.indexOf(dataCell);
						if (cellIndex !== -1) {
							cells2Init.splice(cellIndex, 1);
							if (cells2Init.length === 0) {
								me.fireEvent('notebookInitialized');
							}
						} else {
							console.error('unknown cell initialized', dataCell);
						}
					});
				}
			}
		});

		if (hasDomError) {
			me.showError(me.localize("errorParsingDomInput"))
		}
	},

	getInnerHeaderHtml: function() {
		let html = "";
		if (this.getMetadata().title) {
			html += "<div class='title'>"+this.getMetadata().title+"</div>";
		}
		if (this.getMetadata().author) {
			html += "<div class='author'>"+this.getMetadata().author+"</div>";
		}
		return html;
	},
	
	getInnerFooterHtml: function() {
		var text = "", metadata = this.getMetadata();
		if (metadata.author || metadata.license) {
			var text = "&copy;";
			if (metadata.author) {text+=" "+metadata.author;}
			if (metadata.license) {text+=" ("+metadata.license+")";}
			text += ". ";
		}
		if (metadata.created || metadata.modified) {
			var created = metadata.shortDate("created"), modified = metadata.shortDate("modified");
			if (created) {
				text += this.localize("created")+" "+created+"."
			}
			if (modified && created!=modified) {
				text += " "+this.localize("modified")+" "+modified+"."
			}
			
		}
		return text;
	},

	generateExportHtml: function() {
		var out = "<!DOCTYPE HTML>\n<html>\n<head>\n<meta charset='UTF-8'>\n";

		var metadata = this.getMetadata();
		out += metadata.getHeaders();

		out += '<link rel="stylesheet" type="text/css" href="https://voyant-tools.org/resources/codemirror/lib/codemirror.css">'
		+'<link rel="stylesheet" type="text/css" href="https://voyant-tools.org/resources/spyral/css/codemirror.css">'
		+'<link rel="stylesheet" type="text/css" href="https://voyant-tools.org/resources/spyral/css/spyral.css">'
		+'<link rel="stylesheet" type="text/css" href="https://voyant-tools.org/resources/spyral/css/dataviewer.css">';

		out += "</head>\n"
		+"<body class='exported-notebook'>\n"
		+"<header class='spyral-header'>"+this.getInnerHeaderHtml()+"</header>\n"
		+"<article class='spyralArticle'>\n";

		this.getComponent("cells").items.each(function(item, i) {
			out+="<section id='"+item.getCellId()+"' class='notebook-editor-wrapper "+item.xtype+"'>\n"+
			"<div class='notebookwrappercounter'>"+(item.getIndex()+1)+"</div>";

			var content = item.getContent();
			if (item.isXType('notebooktexteditorwrapper')) {
				out+="<div class='notebook-text-editor'>"+content+"</div>\n";
			} else {	
				var codeTextLayer = item.getTargetEl().query('.CodeMirror-wrap')[0].cloneNode(true);

				// code editor UI
				out += "<div class='notebook-code-editor'>\n"+codeTextLayer.outerHTML+"\n</div>\n"
				// code editor code for importing (hidden by CSS)
				+"<pre class='notebook-code-editor-raw editor-mode-"+content.mode+"'>"+content.input+"</pre>\n";

				// code editor results
				var output = content.output;
				if (output === '') {
					item.results.getResultsEl();
				}
				out += "<div class='notebook-code-results"+(content.expandResults ? '' : ' collapsed')+"'>\n"+content.output+"\n</div>\n";
			}

			out+="</section>\n"
		})
		out += "</article>\n<footer class='spyral-footer'>"+this.getInnerFooterHtml()+"</footer>\n</body>\n</html>";
		return out;
	},

	generateExportMetadata: function(metadata) {
		var clone = metadata.clone(); // use a clone so that altering title and description doesn't affect original
		
		if (clone.title) {
			clone.title = clone.title.replace(/<\/?\w+.*?>/g, '');
		}
		if (clone.description) {
			clone.description = clone.description.replace(/<\/?\w+.*?>/g, '');
		}

		if (clone.keywords) {
			if (Array.isArray(clone.keywords) === false) {
				clone.keywords = clone.keywords.split(/[\s,]+/)
			}
			clone.keywords = clone.keywords.reduce(function(keywordsArray, keyword) {
				if (keyword.length > 0) {
					keywordsArray.push(keyword.toLowerCase());
				}
				return keywordsArray;
			}, []);
		}

		return clone;
	},

	generateExportJson: function() {
		var cells = [];
		this.getComponent("cells").items.each(function(item, i) {
			var type;
			switch(item.xtype) {
				case 'notebookcodeeditorwrapper':
					type = 'code';
					break;
				case 'notebookdatawrapper':
					type = 'data';
					break;
				default:
					type = 'text';
			}
			cells.push({
				cellId: item.getCellId(),
				type: type,
				content: item.getContent()
			});
		});

		var json = {
			metadata: this.getMetadata(),
			cells: cells
		}

		return JSON.stringify(json);
	},


	/*
	 * Export dialog options below
	 */
	
	getExtraViewExportItems: function() {
		return [
		// {
		// 	inputValue: 'html',
		// 	boxLabel: this.localize('exportHtml')
		// },
		{
			inputValue: 'htmlDownload',
			boxLabel: '<a href="#">'+this.localize('exportHtmlDownload')+'</a>',
			listeners: {
				afterrender: function(cmp) {
					var name = (this.getNotebookId() || "spyral")+ ".html";
					var data = this.generateExportHtml();
					var properties = {type: 'text/html'};
					var file;
					try {
						file = new File([data], name, properties);
					} catch (e) {
						file = new Blob([data], properties);
					}

					var url = URL.createObjectURL(file);
					var a = cmp.boxLabelEl.dom.querySelector("a");
					a.setAttribute("download", name);
					a.setAttribute("href", url);
				},
				scope: this
			},
			handler: function(cmp) {
				cmp.boxLabelEl.dom.querySelector("a").click();
				cmp.up("window").close();
			}
		}]
	}
	
	// ,exportHtml: function() {
	// 	var out = this.generateExportHtml();
	// 	var myWindow = window.open();
	// 	myWindow.document.write(out);
	// 	myWindow.document.close();
	// 	myWindow.focus();
	// }
});

Ext.define('Voyant.notebook.util.NotebooksList', {
	extend: 'Ext.view.View',
	alias: 'widget.notebookslist',

	constructor: function(config) {
		Ext.apply(config, {
			width: '100%',
			padding: 10,
			scrollable: 'vertical',
			store: Ext.create('Ext.data.JsonStore', {
				fields: [
					{name: 'id'},
					{name: 'author'},
					{name: 'title'},
					{name: 'description'},
					{name: 'keywords'},
					{name: 'language'},
					{name: 'license'},
					{name: 'created', type: 'date'},
					{name: 'modified', type: 'date'},
					{name: 'catalogue', type: 'boolean'},
					{name: 'version'}
				]
			}),
			tpl: new Ext.XTemplate(
				'<tpl for=".">',
					'<div class="catalogue-notebook">',
						'<div class="id">{id}</div>',
						'<div class="title nowrap" title="{title}">',
						'<tpl if="catalogue"><i class="fa fa-th-list published" aria-hidden="true" title="In Catalogue"></i> </tpl>',
						'{title}</div>',
						'<div class="author nowrap"><i class="fa fa-user" aria-hidden="true"></i> {author}</div>',
						'<div class="description">{description}</div>',
						'<tpl if="keywords.length &gt; 0">',
							'<div class="keywords nowrap">',
								'<i class="fa fa-tags" aria-hidden="true"></i> ',
								'<tpl for="keywords">',
									'<span>{.}</span>',
								'</tpl>',
							'</div>',
						'</tpl>',
						'<div class="dates"><span class="date"><i class="fa fa-clock-o" aria-hidden="true"></i> {[Ext.Date.format(values.modified, "M j Y")]}</span></div>',
					'</div>',
				'</tpl>'
			),
			itemSelector: 'div.catalogue-notebook',
			overItemCls: 'catalogue-notebook-over',
			selectedItemCls: 'catalogue-notebook-selected'
		});

		this.callParent(arguments);
	}
});

Ext.define('Voyant.notebook.util.DocsWindow', {
	extend: 'Ext.window.Window',
	mixins: ['Voyant.util.Localization'],
	statics: {
		i18n: {
			home: 'Home',
			overview: 'Overview',
			configs: 'Configs',
			methods: 'Methods',
			docs: 'Docs',
			openFull: 'Open Full Documentation',
			outlineIntro: 'This is an inline version of the API documentation for <a href="#!/guide/notebook">Spyral Notebooks</a>. You can also <a href="#!/api">view the full documentation</a> in a new window.<br/><br/>For tutorials on how to use Spyral check out the <a href="https://voyant-tools.org/spyral/learnspyral@gh/Tutorials/">Spyral Tutorials Table of Contents</a>.',
			outlineApi: 'Here is a list of the Spyral classes that can be used in your notebook:',
			loadingDocs: 'Loading Docs'
		}
	},

	lastDocEntryClass: undefined,
	lastDocEntryMethod: undefined,

	outlineTemplate: new Ext.XTemplate(
		'<ul>',
			'<tpl for="groups">',
				'<tpl for="classes">',
					'<li><a href="#!/api/{.}">{.}</a></li>',
				'</tpl>',
			'</tpl>',
		'</ul>'
	),
	membersTemplate: new Ext.XTemplate(
		'<div class="members">',
			'<tpl for=".">',
				'<div class="member">',
					'<tpl if="meta.static">',
						'<span class="static" title="static">s</span>',
					'</tpl>',
					'<a href="#!/api/{owner}-{id}">{name}</a>',
				'</div>',
			'</tpl>',
		'</div>'
	),

	constructor: function(config) {
		this.mixins['Voyant.util.Localization'].constructor.apply(this, arguments);

		config = config || {};
		Ext.apply(config, {
			title: this.localize('docs'),
			width: 500,
			height: 500,
			minimizable: true,
			closeAction: 'hide',
			tbar: [{
				text: this.localize('home'),
				itemId: 'homeBtn',
				glyph: 'xf015@FontAwesome',
				handler: function(btn) {
					this.showDocs();
				}.bind(this)
			},{
				text: this.localize('overview'),
				itemId: 'overviewBtn',
				glyph: 'xf05a@FontAwesome',
				handler: function(btn) {
					this._showDocEntry();
				}.bind(this)
			},{
				text: this.localize('configs'),
				itemId: 'configsBtn',
				glyph: 'xf013@FontAwesome',
				handler: function(btn) {
					btn.up('window').getLayout().setActiveItem(1);
				}
			},{
				text: this.localize('methods'),
				itemId: 'methodsBtn',
				glyph: 'xf1b2@FontAwesome',
				handler: function(btn) {
					btn.up('window').getLayout().setActiveItem(2);
				}
			}],
			layout: 'card',
			items: [{
				itemId: 'main',
				cls: 'docsWindowContent',
				scrollable: 'y',
				html: ''
			},{
				itemId: 'configs',
				cls: 'docsWindowContent',
				scrollable: 'x',
				layout: 'fit',
				html: ''
			},{
				itemId: 'methods',
				cls: 'docsWindowContent',
				scrollable: 'x',
				layout: 'fit',
				html: ''
			}],
			tools: [{
				type: 'help',
				tooltip: this.localize('openFull'),
				callback: function(parent, tool, event) {
					var entryId = '';
					if (this.lastDocEntryClass) {
						entryId += '/'+this.lastDocEntryClass;
					}
					if (this.lastDocEntryMethod) {
						entryId += '-'+this.lastDocEntryMethod;
					}
					window.open(Voyant.application.getBaseUrlFull()+'docs/#!/api'+entryId, '_spyral_docs');
				}.bind(this)
			},{
				type: 'restore',
				itemId: 'restoreButton',
				hidden: true,
				handler: function(evt, el, owner, tool) {
					tool.hide();
					var win = owner.up('window');
					win.expand(false);
					setTimeout(function() {
						win.anchorTo(Ext.getBody(), 'br-br');
					}, 10);
				}
			}],
			listeners: {
				boxready: function(win) {
					win.body.addListener('click', function(evt) {
						if (evt.target.tagName.toLowerCase() === 'a') {
							evt.preventDefault();
							evt.stopPropagation();
							var link = evt.target.getAttribute('href');
							this.handleDocLink(link);
						}
					}, this);
				},
				minimize: function(win) {
					win.collapse(Ext.Component.DIRECTION_BOTTOM, false).anchorTo(Ext.getBody(), 'br-br');
					win.down('#restoreButton').show();
				},
				scope: this
			}
		});

		this.callParent([config]);
	},

	showDocs: function() {
		this.show().anchorTo(Ext.getBody(), 'br-br');
		this.getLayout().getRenderTarget().mask(this.localize('loadingDocs'));

		Ext.Ajax.request({
			// TODO inaccessible on server? Same with servers.json used by mirrors.jsp
			url: Voyant.application.getBaseUrlFull()+'resources/docs/en/categories.json'
		}).then(function(response) {
			var json;
			try {
				json = JSON.parse(response.responseText);
			} catch (e) {
				console.warn('error parsing api doc json', e);
			}
			if (json) {
				this._loadExtOutline(json[0]);
			}
		}.bind(this), function() {
			this._loadExtOutline({
				"name": "Spyral",
				"groups": [
					{
						"name": "Base",
						"classes": [
							"Spyral.Corpus",
							"Spyral.Table",
							"Spyral.Chart",
							"Spyral.Load",
							"Spyral.Util",
							"Spyral.Categories"
						]
					},{
						"name": "Notebook",
						"classes": [
							"Spyral.Metadata",
							"Spyral.Notebook",
							"Spyral.Util.Storage"
						]
					},{
						"name": "Global",
						"classes": [
							"window"
						]
					}
				]
			})
		}.bind(this)).always(function() {
			this.getLayout().setActiveItem(0);
			this.getLayout().getRenderTarget().unmask();
		}.bind(this));
	},

	handleDocLink: function(link) {
		var matches = link.match(/.*?\/api\/([\w.]+)-?(.*)?/);
		if (matches) {
			var linkClass = matches[1];
			var linkMethod = matches[2];
			if (linkClass !== this.lastDocEntryClass) {
				this.showDocsForClassMethod(linkClass, linkMethod);
			} else {
				this._showDocEntry(linkMethod);
			}
		} else {
			if (link.indexOf('#!') === 0) {
				window.open(Voyant.application.getBaseUrlFull()+'docs/'+link, '_spyral_docs');
			} else {
				window.open(link, '_external');
			}
		}
	},

	showDocsForClassMethod: function(docClass, docMethod) {
		this.show().anchorTo(Ext.getBody(), 'br-br');
		this.getLayout().getRenderTarget().mask(this.localize('loadingDocs'));

		Ext.Ajax.request({
			url: Voyant.application.getBaseUrlFull()+'docs/output/'+docClass+'.js'
		}).then(function(response) {
			var jsonpText = response.responseText; // response has JSON-P wrapper which we'll need to remove
			var json;
			try {
				var startIndex = jsonpText.indexOf('{');
				var endIndex = jsonpText.search(/\);\s*$/m);
				json = JSON.parse(jsonpText.substring(startIndex, endIndex));
			} catch (e) {
				console.warn('error parsing api doc json', e);
			}
			if (json) {
				this._loadExtDocs(json, docClass, docMethod);
			}
		}.bind(this)).always(function() {
			this.getLayout().getRenderTarget().unmask();
		}.bind(this));
	},

	_showDocEntry: function(entryId) {
		if (this.isHidden()) {
			this.show().anchorTo(Ext.getBody(), 'br-br');
		}
		var docsParentEl = this.down('#main').getEl().dom;
		docsParentEl.querySelectorAll('.doc-contents, .members-section > .subsection > div').forEach(function(el) { el.hidden = true; });
		this.lastDocEntryMethod = entryId;
		if (entryId) {
			docsParentEl.querySelector('#'+entryId).hidden = false;
		} else {
			docsParentEl.querySelector('.doc-contents').hidden = false;
		}
		this.getLayout().setActiveItem(0);
		setTimeout(function() {
			this.down('#main').body.scrollTo('top', 0, false);
		}.bind(this), 0);
	},

	_loadExtOutline: function(json) {
		this.lastDocEntryClass = undefined;
		this.lastDocEntryMethod = undefined;

		this.setTitle(this.localize('docs')+' '+this.localize('home'));
		this.down('#restoreButton').hide();
		this.down('#overviewBtn').hide();
		this.down('#configsBtn').hide();
		this.down('#methodsBtn').hide();

		var html = '<p>'+this.localize('outlineIntro')+'</p><p>'+this.localize('outlineApi')+'</p>';
		html += this.outlineTemplate.apply(json);

		this._setHtmlForCard('main', html);

		this.body.scrollTo('top', 0, false);

		if (this.getCollapsed()) {
			this.expand(false);
			setTimeout(function() {
				this.anchorTo(Ext.getBody(), 'br-br');
			}.bind(this), 10);
		}
	},

	_loadExtDocs: function(json, docClass, docMethod) {
		this.lastDocEntryClass = docClass;
		this.lastDocEntryMethod = docMethod;

		this.setTitle(this.localize('docs')+': '+json.name);
		this.down('#restoreButton').hide();

		this._setHtmlForCard('main', json.html);

		this._showDocEntry(docMethod);

		this.down('#overviewBtn').show();

		var configMembers = [];
		var methodMembers = [];
		json.members.forEach(function(member) {
			if (member.tagname === 'cfg') {
				configMembers.push(member);
			} else if (member.tagname === 'method') {
				if (member.meta.static) {
					// TODO add icon to indicate it's static?
				}
				methodMembers.push(member);
			}
		});

		this._setHtmlForCard('configs', this.membersTemplate.apply(configMembers));
		this.down('#configsBtn').setVisible(configMembers.length > 0);

		this._setHtmlForCard('methods', this.membersTemplate.apply(methodMembers));
		this.down('#methodsBtn').setVisible(methodMembers.length > 0);

		if (this.getCollapsed()) {
			this.expand(false);
			setTimeout(function() {
				this.anchorTo(Ext.getBody(), 'br-br');
			}.bind(this), 10);
		}
	},

	_setHtmlForCard: function(cardId, html) {
		this.down('#'+cardId).setHtml(html);
		var cardEl = this.down('#'+cardId).getEl().dom;
		Ext.fly(cardEl).selectable();
	}
});
Ext.define('Voyant.notebook.Catalogue', {
	extend: 'Ext.Component',
    mixins: ['Voyant.util.Localization','Voyant.notebook.util.NotebooksList'],
	alias: 'widget.notebookcatalogue',
	statics: {
		i18n: {
			title: 'Spyral Notebooks Catalogue',
			browse: 'Browse Notebooks',
			keywords: 'Keywords',
			author: 'Author',
			language: 'Language',
			license: 'License',
			search: 'Search within notebooks',
			noResults: 'No matching notebooks',
			suggested: 'Suggested Notebooks',
			load: 'Open Selected Notebook',
			close: 'Close'
		}
	},

	window: undefined,

	gettingFacets: false,

	constructor: function() {
		this.suggestedStore = Ext.create('Ext.data.JsonStore', {
			fields: [
				{name: 'id'},
				{name: 'author'},
				{name: 'title'},
				{name: 'description'},
				{name: 'keywords'},
				{name: 'language'},
				{name: 'license'},
				{name: 'created', type: 'date'},
				{name: 'modified', type: 'date'},
				{name: 'version'}
			]
		});
		this.suggestedTemplate = new Ext.XTemplate(
			'<tpl for=".">',
				'<div class="catalogue-notebook">',
					'<div class="title" title="{title}">{title}</div>',
					'<div class="description">{description}</div>',
				'</div>',
			'</tpl>'
		);
		this.callParent(arguments);
	},

	initComponent: function(config) {
		this.callParent(arguments);
	},

	showWindow: function() {
		if (this.window === undefined) {
			this.window = Ext.create('Ext.window.Window', {
				title: this.localize('title'),
				width: '80%',
				height: '80%',
				maximizable: true,
				modal: true,
				cls: 'catalogue',
				layout: 'border',
				items: [{
					xtype: 'panel',
					region: 'center',
					flex: 2,
					border: true,
					layout: {
						type: 'vbox',
						align: 'stretch'
					},
					items: [{
						xtype: 'toolbar',
						height: 30,
						layout: {
							type: 'hbox',
							pack: 'center'
						},
						items: [{xtype:'tbspacer', flex: .1},{
							xtype: 'textfield',
							itemId: 'queryfield',
							emptyText: this.localize('search'),
							flex: .8,
							enableKeyEvents: true,
							triggers: {
								cancel: {
									hidden: true,
									cls: 'fa-trigger form-fa-clear-trigger',
									handler: function(cmp) {
										cmp.setValue('');
										cmp.getTriggers()['cancel'].hide();
										this.getNotebooks();
									},
									scope: this
								},
								search: {
									cls: 'fa-trigger form-fa-search-trigger',
									handler: function(cmp) {
										this.getNotebooks();
									},
									scope: this
								}
							},
							listeners: {
								keyup: function(cmp, e) {
									if (e.getCharCode() === 13) {
										this.getNotebooks();
									}
									if (cmp.getValue().trim().length > 0) {
										cmp.getTriggers()['cancel'].show();
									} else {
										cmp.getTriggers()['cancel'].hide();
									}
								},
								scope: this
							}
						},{xtype:'tbspacer', flex: .1}]
					},{
						xtype: 'notebookslist',
						itemId: 'notebookslist',
						cls: 'catalogue-window',
						flex: 1,
						listeners: {
							itemdblclick: function(view, record, el) {
								this.fireEvent('notebookSelected', this, record.get('id'), this.hideWindow);
							},
							scope: this
						}
					}]
				},{
					xtype: 'panel',
					region: 'west',
					collapsible: true,
					title: this.localize('browse'),
					flex: 1,
					itemId: 'facets',
					cls: 'facets',
					layout: {
						type: 'accordion',
						animate: false,
						multi: true,
						fill: false,
						align: 'stretch',
						titleCollapse: true,
						hideCollapseTool: true
					},
					defaults: {
						xtype: 'grid',
						rowLines: false,
						hideHeaders: true,
        				selType: 'checkboxmodel',
						columns: [{ renderer: function(value, metaData, record) {return "("+record.get('count')+") "+record.get('label')}, flex: 1 }],
						store: {
							xtype: 'store.json',
							fields: [
								{name: 'label'},
								{name: 'count', type: 'integer'}
							]
						}
					},
					items: [{
						title: this.localize('keywords'),
						facet: 'facet.keywords',
						flex: 3
					},{
						title: this.localize('author'),
						facet: 'facet.author',
						flex: 2
					},{
						title: this.localize('language'),
						facet: 'facet.language',
						flex: 1
					},{
						title: this.localize('license'),
						facet: 'facet.license',
						flex: 1
					}]
				},{
					xtype: 'panel',
					region: 'east',
					collapsible: true,
					collapsed: false,
					title: this.localize('suggested'),
					width: 250,
					layout: 'fit',
					items: [{
						xtype: 'dataview',
						padding: 10,
						scrollable: 'vertical',
						itemId: 'suggestedNotebooks',
						store: this.suggestedStore,
						tpl: this.suggestedTemplate,
						itemSelector: 'div.catalogue-notebook',
						overItemCls: 'catalogue-notebook-over',
						selectedItemCls: 'catalogue-notebook-selected',
						listeners: {
							itemdblclick: function(view, record, el) {
								this.fireEvent('notebookSelected', this, record.get('id'), this.hideWindow);
							},
							scope: this
						}
					}]
				}],
				closeAction: 'hide',
				buttons: [{
					text: this.localize('close'),
					ui: 'default-toolbar',
					handler: function(but) {
						this.window.close();
					},
					scope: this
				},{
					text: this.localize('load'),
					glyph: 'xf115@FontAwesome',
					handler: function(but) {
						var record = this.window.down('#notebookslist').getSelection()[0];
						if (record === undefined) {
							record = this.window.down('#suggestedNotebooks').getSelection()[0];
						}
						if (record) {
							this.fireEvent('notebookSelected', this, record.get('id'), this.hideWindow)
						}
					},
					scope: this
				}]
			});
			this.window.query('#facets > grid').forEach(function(facetCmp) {
				facetCmp.getSelectionModel().on('selectionchange', this._loadFacets, this);
			}, this);
		} else {
			// reset catalogue
			this.window.query('#facets > grid').forEach(function(facetCmp) {
				facetCmp.getStore().clearFilter();
				facetCmp.getSelectionModel().deselectAll();
			});
			this.window.down('#queryfield').setValue('');
			this.window.down('#notebookslist').getSelectionModel().deselectAll();
			this.window.down('#suggestedNotebooks').getSelectionModel().deselectAll();
			this.window.down('#notebookslist').getStore().removeAll();
		}

		if (this.suggestedStore.isLoaded() === false) {
			this.getSuggestedNotebooks();
		}

		this.window.show();

		this._loadFacets();
	},

	hideWindow: function() {
		if (this.window !== undefined) {
			this.window.close();
		}
	},

	_getSelectedFacets: function() {
		var facets = [];
		this.window.query('#facets > grid').forEach(function(facetCmp) {
			facetCmp.getSelection().forEach(function(record) {
				facets.push([facetCmp.facet, record.get('label')]);
			})
		});
		return facets;
	},

	_loadFacets: function() {
		if (this.gettingFacets === false) {
			this.window.down('#facets').mask('Loading');
			this.gettingFacets = true;
			var facetQuery = this._getSelectedFacets().map(function(f) { return f.join('=') });

			var me = this;
			Spyral.Load.trombone({
				tool: 'notebook.CatalogueFacets',
				query: facetQuery,
				noCache: 1
			}).then(function(json) {
				json.catalogue.facets.forEach(function(facetResult) {
					var facetCmp = me.window.query('#facets > grid[facet='+facetResult.facet+']')[0];
					if (facetCmp) {
						var store = facetCmp.getStore();
						store.clearFilter();
						if (store.getCount() === 0) {
							store.loadRawData(facetResult.results);
						} else {
							var matches = [];
							store.each(function(record) {
								var label = record.get('label');
								for (var i = 0; i < facetResult.results.length; i++) {
									var result = facetResult.results[i];
									if (result.label === label) {
										record.set('count', result.count);
										matches.push(label);
										break;
									}
								}
							});
							store.filterBy(function(record) { return matches.indexOf(record.get('label')) !== -1 });
						}
					}
				});
				me.window.down('#facets').unmask();
				me.gettingFacets = false;
				
				me.getNotebooks();
			}).catch(function(err) {
				me.window.down('#facets').unmask();
				me.gettingFacets = false;
			});
		}
	},

	getNotebooks: function(queries) {
    	if (!queries) {
	    	queries = [];
			var facets = this._getSelectedFacets();
	    	facets.forEach(function(f) {
				queries.push(f.join(':'));
			})
			var queryfieldstring = this.window.down('#queryfield').getValue();
			if (queryfieldstring.trim().length > 0) {
				queries.push(queryfieldstring);
			}
			return this.getNotebooks(queries);
    	}
		if (queries.length === 0) {
			this.window.down('#notebookslist').getSelectionModel().deselectAll();
			this.window.down('#notebookslist').getStore().removeAll();
			return;
		}
		
		queries.push('facet.catalogue:true');

		this.window.down('#notebookslist').mask('Loading');
		this.window.down('#notebookslist').getSelectionModel().deselectAll();

		var me = this;
		Spyral.Load.trombone({
			tool: 'notebook.NotebookFinder',
			query: queries,
			noCache: 1
		}).then(function(json) {
			me.window.down('#notebookslist').unmask();
			me.window.down('#notebookslist').getStore().loadRawData(json.catalogue.notebooks);
			me.window.down('#notebookslist').getStore().sort('modified', 'DESC');
		}).catch(function(err) {
			me.window.unmask()
		});
	},

	getSuggestedNotebooks: function() {
		var notebookIds = ['Tutorials', 'aboutspyral', 'DialogicaWelcome'];
		var query = 'id:'+notebookIds.join('|id:');
		var me = this;
		Spyral.Load.trombone({
			tool: 'notebook.NotebookFinder',
			query: query,
			parse: false,
			noCache: 1
		}).then(function(json) {
			me.suggestedStore.loadRawData(json.catalogue.notebooks);
			me.suggestedStore.sort('modified', 'DESC');
		}).catch(function(err) {
		})
	}
});

Ext.define('Voyant.notebook.Authenticator', {
	mixins: ['Voyant.util.Localization','Voyant.notebook.util.NotebooksList'],
	statics: {
		i18n: {
			account: 'Account',
			signInWithGithub: 'Sign in with GitHub',
			signInWithGoogle: 'Sign in with Google',
			logout: 'Logout',
			yourNotebooks: 'Your Notebooks',
			authenticateWithGithub: 'Authenticate with GitHub',
			authorizeSpyralGithub: 'You must authorize Spyral to use GitHub on your behalf.',
			signInSuccess: 'Sign in successful!',
			close: 'Close',
			openSelected: 'Open Selected Notebook',
			deleteSelected: 'Delete Selected Notebook',
			notebookDeleted: 'Notebook deleted',
			errorDeletingNotebook: 'Error deleting notebook'
		}
	},

	accountInfo: undefined,

	getGitHubAuthButton: function(callback) {
		const me = this;
		return {
			xtype: 'button',
			glyph: 'xf09b@FontAwesome',
			text: me.localize('signInWithGithub'),
			margin: '5 15',
			handler: function(button) {
				function postMessageHandler(event) {
					if (event.origin === window.location.origin && event.data === 'oauth_cookie_set') {
						window.removeEventListener("message", postMessageHandler, false);
						event.source.close();
						me.retrieveAccountInfo().then(function(info) {
							callback.call(me, info);
						});
					} else {
						console.warn('Error authenticating with GitHub');
					}
				}
				window.open(Voyant.application.getBaseUrlFull()+'spyral/oauth', '_blank');
				window.addEventListener("message", postMessageHandler, false);
			}
		}
	},

	getGoogleAuthButton: function(callback) {
		google.accounts.id.initialize({
			client_id: "foobar",
			ux_mode: "redirect",
			login_uri: "http://localhost:8080/voyant/spyral/oauth/callback"
		});

		return {
			xtype: 'component',
			html: '<div id="signInWithGoogleButton"></div>',
			margin: 5,
			listeners: {
				afterrender: function() {
					google.accounts.id.renderButton(
						document.getElementById("signInWithGoogleButton"),
						{theme: "outline", size: "medium"}
					);
				}
			}
		}
	},

	showGitHubAuthentication: function(callback) {
		const me = this;

		Ext.create('Ext.window.Window', {
			title: me.localize('authenticateWithGithub'),
			width: 750,
			height: 550,
			closable: false,
			layout: {
				type: 'vbox',
				align: 'middle',
				pack: 'center'
			},
			items: [
				{html: '<div style="margin-bottom: 10px;">'+me.localize('authorizeSpyralGithub')+'</div>'},
				me.getGitHubAuthButton(callback)
			],
			buttons: [{
				text: 'Cancel',
				handler: function() {
					me.close();
				}
			}]
		}).show();
	},

	showAccountWindow: function() {
		const me = this;

		if (this.isAuthenticated()) {
			const idInfo = this.accountInfo.id.split('@');
			const id = idInfo[0];
			const idType = idInfo[1];

			const accountWin = Ext.create('Ext.window.Window', {
				title: me.localize('account'),
				width: 750,
				height: 550,
				modal: true,
				maximizable: true,
				closable: true,
				layout: {
					type: 'hbox',
					align: 'stretch',
					pack: 'center'
				},
				items: [{
					width: 200,
					layout: {
						type: 'vbox',
						align: 'middle',
						pack: 'start'
					},
					items: [{
						html:
`<div style="padding: 10px">
	<img src="${me.accountInfo.avatar}" width="100" height="100" style="display: block; margin-bottom: 5px" />
	<div style="margin-bottom: 5px">${me.accountInfo.name}</div>
	<div><i class="fa fa-${idType === 'gh' ? 'github' : 'google'}"></i> ${id}</div>
</div>`
					},{
						xtype: 'button',
						glyph: 'xf08b@FontAwesome',
						text: me.localize('logout'),
						handler: function(btn) {
							Ext.Ajax.request({url: me.getApplication().getBaseUrlFull()+'spyral/account/logout'});
							me.accountInfo = undefined;
							btn.up('window').close();
						}
					}]
				},{
					flex: 1,
					layout: {
						type: 'vbox',
						align: 'middle',
						pack: 'start'
					},
					items:[{
						html: '<h3>'+me.localize('yourNotebooks')+'</h3>'
					},{
						flex: 1,
						itemId: 'notebookslist',
						xtype: 'notebookslist',
						listeners: {
							itemdblclick: function(view, record, el) {
								const notebookId = record.get('id');
								me.fireEvent('notebookSelected', me, notebookId, function() {
									view.up('window').close()
								});
							}
						}
					}]
				}],
				buttons: [{
					text: me.localize('close'),
					ui: 'default-toolbar',
					handler: function(btn) {
						btn.up('window').close();
					}
				},{
					text: me.localize('deleteSelected'),
					ui: 'default-toolbar',
					glyph: 'xf1f8@FontAwesome',
					handler: function(btn) {
						const win = btn.up('window');
						const sel = win.down('#notebookslist').getSelection();
						if (sel[0]) {
							Ext.Msg.confirm('Delete', 'Are you sure you want to permanently delete the selected notebook?', function(button) {
								if (button === 'yes') {
									const notebookId = sel[0].get('id');
									me.deleteNotebook(notebookId).then(function() {
										win.down('#notebookslist').getStore().remove(sel[0]);
										me.toastInfo({
											html: me.localize('notebookDeleted'),
											anchor: 'tr'
										});
									}, function(err) {
										Ext.Msg.show({
											title: me.localize('errorDeletingNotebook'),
											msg: err,
											buttons: Ext.MessageBox.OK,
											icon: Ext.MessageBox.ERROR
										});
									});
								}
							}, me);
							
						}
					}
				},{
					text: me.localize('openSelected'),
					glyph: 'xf115@FontAwesome',
					handler: function(btn) {
						const win = btn.up('window');
						const sel = win.down('#notebookslist').getSelection();
						if (sel[0]) {
							const notebookId = sel[0].get('id');
							me.fireEvent('notebookSelected', me, notebookId, function() {
								win.close()
							});
						}
					}
				}]
			});
			accountWin.show();

			this.populateNotebookList(accountWin);
		}
	},

	retrieveAccountInfo: function() {
		const me = this;
		var dfd = new Ext.Deferred();

		Ext.Ajax.request({
			url: this.getApplication().getBaseUrlFull()+'spyral/account',
			success: function(resp) {
				if (resp.responseText === '') {
					dfd.resolve(undefined);
				} else {
					var info = JSON.parse(resp.responseText);
					me.accountInfo = info;
					dfd.resolve(info);
				}
			},
			failure: function() {
				dfd.reject();
			}
		});

		return dfd.promise;
	},

	isAuthenticated: function(refresh) {
		if (refresh) {
			return this.retrieveAccountInfo().then(function(info) {
				return info !== undefined;
			}, function() {
				return false;
			})
		}
		return this.accountInfo !== undefined;
	},

	populateNotebookList: function(accountWin) {
		accountWin.down('#notebookslist').mask('Loading');
		Spyral.Load.trombone({
			tool: 'notebook.NotebookFinder',
			query: 'facet.userId:'+this.accountInfo.id,
			noCache: 1
		}).then(function(json) {
			accountWin.down('#notebookslist').unmask();
			accountWin.down('#notebookslist').getStore().loadRawData(json.catalogue.notebooks);
			accountWin.down('#notebookslist').getStore().sort('modified', 'DESC');
		}).catch(function(err) {
			accountWin.unmask()
		});
	},

	deleteNotebook: function(notebookId) {
		const me = this;

		const dfd = new Ext.Deferred();

		Ext.Ajax.request({
			method: 'POST',
			url: Voyant.application.getBaseUrlFull()+'spyral/account/delete',
			params: {
				id: notebookId
			},
			success: function(resp) {
				const json = JSON.parse(resp.responseText);
				if (json.notebook.success) {
					me.fireEvent('fileDeleted', me, notebookId);
					dfd.resolve(true);
				} else {
					me.fireEvent('fileDeleted', me, null, json.notebook.error);
					dfd.reject(json.notebook.error);
				}
			},
			failure: function(resp) {
				me.fireEvent('fileDeleted', me, null, resp.responseText);
				dfd.reject(resp.responseText);
			}
		});

		return dfd.promise;
	},

	getCookie: function(cookieName) {
		const re = new RegExp('[; ]'+cookieName+'=([^\\s;]*)');
		const sMatch = (' '+document.cookie).match(re);
		if (cookieName && sMatch) return unescape(sMatch[1]);
		return '';
	},

	deleteCookie: function(cookieName, cookiePath) {
		cookiePath = cookiePath === undefined ? '/' : cookiePath;
		document.cookie = cookieName +'=; Path='+cookiePath+'; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
	}
});

/*
 * @class Notebook
 * A Spyral Notebook. This should never be instantiated directly.
 */
Ext.define('Voyant.notebook.Notebook', {
	alternateClassName: ["Notebook"],
	extend: 'Ext.panel.Panel',
	requires: ['Voyant.notebook.editor.CodeEditorWrapper','Voyant.notebook.editor.TextEditorWrapper','Voyant.notebook.metadata.MetadataEditor','Voyant.notebook.StorageDialogs','Voyant.notebook.github.GitHubDialogs'],
	mixins: ['Voyant.panel.Panel','Voyant.notebook.Authenticator','Voyant.notebook.util.FormatConverter'],
	alias: 'widget.notebook',
    statics: {
    	i18n: {
    		title: "Spyral",
    		created: "Notebook Created",
    		modified: "Notebook Modified",
			saving: "Saving Notebook",
			saved: "Notebook Saved",
    		clickToEdit: "Click to edit",
    		errorLoadingNotebook: "Error loading Spyral notebook",
    		cannotLoadJson: "Unable to parse JSON input.",
    		cannotLoadJsonUnrecognized: "Unable to recognize JSON input.",
    		cannotLoadUnrecognized: "Unable to recognize input.",
			cannotLoadNotebookId: "Unable to load the Spyral Notebook. It may no longer exist.",
    		openTitle: "Open",
    		openMsg: "Paste in Notebook ID or a Spyral data file (in HTML).",
    		exportHtmlDownload: "HTML (download)",
    		errorParsingDomInput: "An error occurred while parsing the input of the document. The results might still work, except if the code contained HTML tags.",
			metadataTip: "View and Edit the notebook metadata.",
			metadataEditor: "Edit Metadata",
    		metadataReset: "Reset",
    		metadataSave: "Save Metadata",
    		metadataCancel: "Cancel",
			catalogueTip: "Search a catalogue of available notebooks.",
			preparingExport: "Preparing Export",
			notSavedWarning: "Changes to your notebook have not been saved. Are you sure you want to continue?",
			accountTip: 'View your account',
			openTip: 'Open a Spyral Notebook (by uploading a file)',
			newNotebookIntro: `
			<p>This is a Spyral Notebook, a dynamic document that combines writing, code and data in service of reading, analyzing and interpreting digital texts.</p>
			<p>Spyral Notebooks are composed of text cells (like this one) and code cells (like the one below). You can click on the cells to edit them and add new cells by clicking add icon that appears in the left column when hovering over a cell.</p>
			<p>To learn more check out our <a href="https://voyant-tools.org/spyral/learnspyral@gh/Tutorials/" target="_blank">Spyral Tutorials Table of Contents</a> page.</p>
			`
    	},
    	api: {
    		input: undefined,
    		inputEncodedBase64Json: undefined,
    		run: undefined
    	}
    },
    config: {
        /**
         * @private
		 * This is a combination of username and notebook name, separated by NOTEBOOK_ID_SEPARATOR
         */
    	notebookId: undefined,
		/**
		 * @private
		 * The name of the notebook (distinct from the notebook title)
		 */
		notebookName: undefined,
        /**
         * @private
         */
    	metadata: undefined,
        /**
         * @private
         */
    	isEdited: false,
    	/**
    	 * @private
    	 */
    	version: "3.0",
		/**
		 * @private
		 * Which solution to use for storing notebooks, either: 'voyant' or 'github'
		 */
		storageSolution: 'voyant'
	},

	NOTEBOOK_ID_SEPARATOR: '_',

	SPYRAL_ID_REGEX: /\/spyral\/(.*?@[a-z]{2})[\/_]([A-Za-z0-9-]+)\/?$/,
	SPYRAL_ID_REGEX_OLD: /\/spyral\/([\w-]+)\/?$/,

	metadataWindow: undefined,
	voyantStorageDialogs: undefined,
	githubDialogs: undefined,
	catalogueWindow: undefined,
	docsWindow: undefined,

	// holds the content of the tern docs, for passing to the code editor
	spyralTernDocs: undefined,
	ecmaTernDocs: undefined,
	browserTernDocs: undefined,
    
    /**
     * @private
     */
    constructor: function(config) {
		var handleSignIn = function() {
			parent.setMetadata(parent.getMetadata().clone()); // force metadata refresh
			parent.setIsEdited(false);
			parent.toastInfo({
				html: parent.localize('signInSuccess'),
				anchor: 'tr'
			});
		}

    	Ext.apply(config, {
    		title: this.localize('title'),
    		includeTools: {
				'help': true,
				'gear': true,
    			'save': true,
    			'saveIt': {
    				tooltip: this.localize("saveItTip"),
    				itemId: 'saveItTool',
    				xtype: 'toolmenu',
    				glyph: 'xf0c2@FontAwesome',
					callback: function(parent, menu) {
						if (menu.toolMenu) menu.toolMenu.destroy(); // need to recreate toolMenu each to register item changes
						menu.items = [];

						parent.isAuthenticated(true).then(function(isAuth) {
							if (isAuth) {
								menu.items = [{
									text: 'Save',
									xtype: 'menuitem',
									glyph: 'xf0c2@FontAwesome',
									handler: parent.showSaveDialog.bind(parent, false),
									scope: parent
								},{
									text: 'Save As...',
									xtype: 'menuitem',
									glyph: 'xf0c2@FontAwesome',
									handler: parent.showSaveDialog.bind(parent, true),
									scope: parent
								}];
							} else {
								menu.items = [
									parent.getGitHubAuthButton(handleSignIn)
								];
							}
						}, function() {
							menu.items = [
								parent.getGitHubAuthButton(handleSignIn)
							];
						}).always(function() {
							menu.showToolMenu();
						});
						/*{
							text: 'Storage',
							xtype: 'menuitem',
							menu: {
								items: [{
									text: 'Voyant',
									xtype: 'menucheckitem',
									group: 'storageSolution',
									checked: true,
									handler: this.setStorageSolution.bind(this, 'voyant'),
									scope: this
								},{
									text: 'GitHub',
									xtype: 'menucheckitem',
									group: 'storageSolution',
									checked: false,
									handler: this.setStorageSolution.bind(this, 'github'),
									scope: this
								}]
							}
						}*/
					}
    			},
    			'new': {
    				tooltip: this.localize("newTip"),
    				callback: function() {
    	    			let url = this.getBaseUrl()+"spyral/";
						this.getApplication().openUrl(url);
    				},
    				xtype: 'toolmenu',
    				glyph: 'xf067@FontAwesome',
    				scope: this
    			},
    			'open': {
    				tooltip: this.localize("openTip"),
    				xtype: 'toolmenu',
					glyph: 'xf115@FontAwesome',
					callback: function(panel, tool) {
						const storageSolution = this.getStorageSolution();
						if (storageSolution === undefined) {
						} else {
							if (storageSolution === 'github') {
								this.githubDialogs.showLoad();
							} else {
								this.voyantStorageDialogs.showLoad();
							}
						}
					},
					scope: this
    			},
    			'runall': {
    				tooltip: this.localize("runallTip"),
    				callback: this.runAll,
    				xtype: 'toolmenu',
    				glyph: 'xf04e@FontAwesome',
    				scope: this
    			},
    			'metadata': {
    				tooltip: this.localize("metadataTip"),
    				callback: this.showMetadataEditor,
					xtype: 'toolmenu',
					glyph: 'xf02c@FontAwesome',
					scope: this
    			},
                'catalogue': {
                    tooltip: this.localize("catalogueTip"),
                    callback: function() {
                        this.catalogueWindow.showWindow();
                    },
                    xtype: 'toolmenu',
                    glyph: 'xf00b@FontAwesome',
                    scope: this
                },
				'account': {
					tooltip: this.localize("accountTip"),
					xtype: 'toolmenu',
					glyph: 'xf007@FontAwesome',
					callback: function(parent, menu) {
						if (menu.toolMenu) menu.toolMenu.destroy(); // need to recreate toolMenu each time to register item changes
						menu.items = [];

						parent.isAuthenticated(true).then(function(isAuth) {
							if (isAuth) {
								parent.showAccountWindow();
							} else {
								menu.items = [
									parent.getGitHubAuthButton(handleSignIn)
								];
							}
						}, function() {
							menu.items = [
								parent.getGitHubAuthButton(handleSignIn)
							];
						}).always(function() {
							menu.showToolMenu();
						});
					}
				}
    		},
    		
			scrollable: true,
			layout: {
				type: 'vbox',
				align: 'middle',
				padding: '50 0'
			},
			defaults: {
				width: '100%',
				maxWidth: 1100
			},
    		items: [{
    			itemId: 'spyralHeader',
    			cls: 'spyral-header',
    			listeners: {
    				afterrender: function(header) {
    					Ext.tip.QuickTipManager.register({
    						  target: header.getId(),
    						  text: this.localize("clickToEdit")
    						});
    					var head = header;
    					header.getTargetEl().on("click", function(header) {
    						this.showMetadataEditor();
    						head.removeCls("editable");
    					}, this);
    					header.mon(header.getEl(), "mouseover", function() {header.addCls("editable")});
    					header.mon(header.getEl(), "mouseout", function() {header.removeCls("editable")});
    				},
    				scope: this
    			}
    		},{
    			xtype: 'container',
    			itemId: 'cells',
				defaults: {
					margin: '10 0 10 0',
					padding: '0 65 0 65'
				}
    		},{
    			itemId: 'spyralFooter',
    			cls: 'spyral-footer',
    			listeners: {
    				afterrender: function(footer) {
    					Ext.tip.QuickTipManager.register({
  						  target: footer.getId(),
  						  text: this.localize("clickToEdit")
  						});
    					var foot = footer;
    					footer.getTargetEl().on("click", function(footer) {
    						this.showMetadataEditor();
    						foot.removeCls("editable");
    					}, this);
    					footer.mon(footer.getEl(), "mouseover", function() {footer.addCls("editable")});
    					footer.mon(footer.getEl(), "mouseout", function() {footer.removeCls("editable")});
    				},
    				scope: this
    			}
    		}],
			helpToolClick: this.showDocs.bind(this),
    		listeners: {
    			afterrender: this.init,
    			notebookWrapperMoveUp: this.notebookWrapperMoveUp,
    			notebookWrapperMoveDown: this.notebookWrapperMoveDown,
    			notebookWrapperRemove: this.notebookWrapperRemove,
				notebookWrapperAdd: this.notebookWrapperAdd,
				notebookInitialized: this.notebookInitialized,
				notebookSelected: this.handleNotebookSelected,
    			scope: this
    		}
    	})

        this.callParent(arguments);
    	this.mixins['Voyant.panel.Panel'].constructor.apply(this, arguments);
		this.mixins['Voyant.notebook.util.FormatConverter'].constructor.apply(this, arguments);

		this.voyantStorageDialogs = new Voyant.notebook.StorageDialogs({
			notebookParent: this,
			listeners: {
				'fileLoaded': function(fileData) {
					this.checkIsEditedAndDoCallback(this, function() {
						this.loadFromString(fileData);
					});
				},
				'fileSaved': function(src, notebookId, error) {
					this.unmask();
					if (notebookId !== null) {
						var id = this.getNotebookId();
						if (!id || notebookId!=id) {
							this.setNotebookId(notebookId);
						}
						this.toastInfo({
							html: this.localize('saved'),
							anchor: 'tr'
						});
						this.setIsEdited(false);
					} else {
						// save error
						this.showError("There was an error saving your notebook:\n"+error);
					}
				},
				'saveCancelled': function() {
				},
				'close': function() {
					this.unmask();
				},
				scope: this
			}
		});

		this.githubDialogs = new Voyant.notebook.github.GitHubDialogs({
			parent: this,
			listeners: {
				'fileLoaded': function(src, {owner, repo, ref, path, file}) {
					this.githubDialogs.close();
					this.loadFromString(file);

					const id = encodeURIComponent(owner+'/'+repo+'/'+path);
					if (location.search.indexOf(id) === -1) {
						const url = this.getBaseUrl()+'spyral/?githubId='+id;
						window.history.pushState({
							url: url
						}, 'Spyral Notebook: '+id, url);
					}
				},
				'fileSaved': function(src, {owner, repo, branch, path}) {
					this.githubDialogs.close();
					this.unmask();
					this.toastInfo({
						html: this.localize('saved'),
						anchor: 'tr'
					});
					this.setIsEdited(false);

					const id = encodeURIComponent(owner+'/'+repo+'/'+path);
					if (location.search.indexOf(id) === -1) {
						const url = this.getBaseUrl()+'spyral/?githubId='+id;
						window.history.pushState({
							url: url
						}, 'Spyral Notebook: '+id, url);
					}
				},
				'saveCancelled': function(src) {
					this.unmask();
				},
				scope: this
			}
		});

		this.catalogueWindow = new Voyant.notebook.Catalogue({
			listeners: {
				notebookSelected: this.handleNotebookSelected,
				scope: this
			}
		});
    },
    
    init: function() {
		window.onbeforeunload = function() {
			if (this.getIsEdited()) {
				return ''; // return any string to prompt the browser to warn the user they have unsaved changes
			}
		}.bind(this);

		// need to load docs first
		Ext.Promise.all([
			Ext.Ajax.request({url: this.getApplication().getBaseUrlFull()+'resources/spyral/docs/spyral.json'}),
			Ext.Ajax.request({url: this.getApplication().getBaseUrlFull()+'resources/spyral/docs/ecmascript.json'}),
			Ext.Ajax.request({url: this.getApplication().getBaseUrlFull()+'resources/spyral/docs/browser.json'})
		]).then(function(responses) {
			this.spyralTernDocs = Ext.JSON.decode(responses[0].responseText);
			this.ecmaTernDocs = Ext.JSON.decode(responses[1].responseText);
			this.browserTernDocs = Ext.JSON.decode(responses[2].responseText);

			this.loadFromQueryParams();
		}.bind(this), function() {
			this.loadFromQueryParams();
		}.bind(this));

		this.retrieveAccountInfo();
    },
    
    
    reset: function() {
		this.getScrollable().scrollTo(0, 0);
		this.getScrollable().trackingScrollTop = 0;
		this.getScrollable().trackingScrollLeft = 0;

		this.setMetadata(new Spyral.Metadata());
		this.voyantStorageDialogs.reset();
    	var cells = this.getComponent("cells");
    	cells.removeAll();
	},

	showSaveDialog: function(saveAs) {
		this.mask(this.localize('saving'));
		
		this.getMetadata().setDateNow('modified');
		this.getMetadata().set({userId: this.accountInfo.id});

		this.updateCachedOutput().then(function(result) {	
		}, function(err) {
			console.warn('Error updating cached results');
		}).finally(function() {
			var data = this.generateExportJson();
			var metadata = this.generateExportMetadata(this.getMetadata());
	
			var storageSolution = this.getStorageSolution();
			
			if (!saveAs && storageSolution === 'voyant' && this.getNotebookId() !== undefined) {
				this.voyantStorageDialogs.doSave({
					notebookName: this.getNotebookName(),
					data: data,
					metadata: metadata
				});
			} else {
				if (storageSolution === 'github') {
					this.githubDialogs.showSave(data);
				} else {
					this.voyantStorageDialogs.showSave(data, metadata, saveAs ? undefined : this.getNotebookName());
				}
			}
		}.bind(this));
	},

	updateCachedOutput: function() {
		return Ext.Promise.all(this.query('notebookrunnableeditorwrapper').map(function(cmp) {
			return cmp.results.updateCachedOutput();
		}));
	},

	exportToolClick: function(panel) {
		panel.mask(panel.localize('preparingExport'));
		panel.updateCachedOutput().finally(function() {
			panel.unmask();
			panel.mixins['Voyant.util.Toolable'].exportToolClick.call(this, panel);
		});
	},
	
	// override toolable method
	getExportUrl: function(asTool) {
		return location.href; // we just provide the current URL
	},

	// override toolable method
	exportBiblio: function() {
		var date = new Date();
		var url = this.getExportUrl();
		var metadata = this.getMetadata();
		var author = metadata.author;
		var title = metadata.title;
		Ext.Msg.show({
			title: this.localize('exportBiblioTitle'),
			message: '<fieldset><legend>MLA</legend>'+
			'<div class="x-selectable">'+
			author+'. "'+title+'." '+
			'<i>Spyral - Voyant Tools</i>, Development led by Stéfan Sinclair and Geoffrey Rockwell. '+Ext.Date.format(date,'Y')+'. Web. '+Ext.Date.format(date,'j M Y')+'. &lt;'+url+'&gt;.'+
			'</div></fieldset><br >'+
			'<fieldset><legend>Chicago</legend>'+
			'<div class="x-selectable">'+
			author+', "'+title+'", '+
			'<i>Spyral - Voyant Tools</i>, Development led by Stéfan Sinclair and Geoffrey Rockwell. Accessed '+Ext.Date.format(date,'F j, Y')+', '+url+'.'+
			'</div></fieldset><br >'+
			'<fieldset><legend>APA</legend>'+
			'<div class="x-selectable">'+
			author+'. ('+Ext.Date.format(date,'Y')+"). "+title+'. '+
			'<i>Spyral - Voyant Tools</i>, Development led by Stéfan Sinclair and Geoffrey Rockwell. Retrieved '+Ext.Date.format(date,'F j, Y')+', from '+url+
			'</div></fieldset>',
			buttons: Ext.Msg.OK,
			icon: Ext.Msg.INFO
		})
	},

	loadFromQueryParams: function() {
		var queryParams = Ext.Object.fromQueryString(document.location.search, true);
		var doRun = Ext.isDefined(queryParams.run);

		var spyralIdMatches = this.SPYRAL_ID_REGEX.exec(location.pathname);
		var spyralIdMatchesOld = this.SPYRAL_ID_REGEX_OLD.exec(location.pathname);

		var isGithub = Ext.isDefined(queryParams.githubId);
		
		if ("inputJsonArrayOfEncodedBase64" in queryParams) {
			let json = Ext.decode(decodeURIComponent(atob(queryParams.inputJsonArrayOfEncodedBase64)));
			json.forEach(function(block, index) {
				let text = block;
				if (text.trim().indexOf("<")==0) {
					if (index === 0) {
						// assume first text block is metadata
						this.setMetadata(new Spyral.Metadata({
							title: text
						}));
					} else {
						this.addText(text);
					}
				} else {
					this.addCode(text);
				}
			}, this);
		} else if (spyralIdMatches) {
			this.loadFromId(spyralIdMatches[1]+this.NOTEBOOK_ID_SEPARATOR+spyralIdMatches[2]);
			this.setStorageSolution('voyant');
		} else if (spyralIdMatchesOld) {
			this.loadFromId(spyralIdMatchesOld[1]);
			this.setStorageSolution('voyant');
		} else if (isGithub) {
			this.githubDialogs.loadFileFromId(queryParams.githubId);
			this.setStorageSolution('github');
		} else {
			this.addNew();
			this.setIsEdited(false);
		}
		
		if (doRun) {
			var me = this;
			Ext.defer(function() {
				me.runAll()
			}, 100)
		}
	},
	
	loadFromString: function(text) {
		text = text.trim();
		if (text.indexOf("{") === 0) {
			this.loadFromJson(text);
		} else if (this.SPYRAL_ID_REGEX.test('/spyral/'+text)) {
			var spyralIdMatches = this.SPYRAL_ID_REGEX.exec('/spyral/'+text);
			this.loadFromId(spyralIdMatches[1]+this.NOTEBOOK_ID_SEPARATOR+spyralIdMatches[2]);
		} else if (text.indexOf("<") !== 0 || text.indexOf("spyral") === -1) {
			return Ext.Msg.show({
				title: this.localize('errorLoadingNotebook'),
				msg: this.localize('cannotLoadUnrecognized'),
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.ERROR
			});
		} else {
			Ext.batchLayouts(function() {
				this.reset();
				this.setNotebookId(undefined);
				try {
					this.importFromHtml(text); // old format
				} catch (e) {
					Ext.Msg.show({
						title: this.localize('errorLoadingNotebook'),
						msg: this.localize('cannotLoadUnrecognized'),
						buttons: Ext.MessageBox.OK,
						icon: Ext.MessageBox.ERROR
					});
				}
			}, this);
		}
		return true;
    },

	loadFromJson: function(text) {
		var json;
		try {
			json = JSON.parse(text)
		} catch(e) {
			return Ext.Msg.show({
				title: this.localize('errorLoadingNotebook'),
				msg: this.localize('cannotLoadJson')+"<br><pre style='color: red'>"+e+"</pre>",
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.ERROR
			});
		}

		if (!json.cells || !json.metadata) {
			return Ext.Msg.show({
				title: this.localize('errorLoadingNotebook'),
				msg: this.localize('cannotLoadJsonUnrecognized'),
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.ERROR
			});
		}

		Ext.batchLayouts(function() {
			this.reset();
			this.setMetadata(new Spyral.Metadata(json.metadata));

			var cells2Init = [];
			json.cells.forEach(function(cell) {
				var cell2Init = undefined;
				switch(cell.type) {
					case 'text':
						this.addText(cell.content, undefined, cell.cellId);
						break;
					case 'code':
						cell2Init = this.addCode(cell.content, undefined, cell.cellId);
						break;
					case 'data':
						cell2Init = this.addData(cell.content, undefined, cell.cellId);
						break;
				}
				if (cell2Init) {
					cell2Init.on('initialized', function() {
						var cellIndex = cells2Init.indexOf(cell2Init);
						if (cellIndex !== -1) {
							cells2Init.splice(cellIndex, 1);
							if (cells2Init.length === 0) {
								this.fireEvent('notebookInitialized', this);
							}
						} else {
							console.error('unknown cell initialized', cell2Init);
						}
					}.bind(this));
					cells2Init.push(cell2Init);
				}
			}, this);
		}, this);
	},
    
    loadFromId: function(id) {
    	this.mask(this.localize("loading"));
    	var me = this;
    	Spyral.Load.trombone({
	    	 tool: 'notebook.GitNotebookManager',
	    	 action: 'load',
	    	 id: id,
	    	 noCache: 1
    	}).then(function(json) {
    		me.unmask();
			if (json.notebook.success) {
				me.loadFromString(json.notebook.data);
				if (json.notebook.id && json.notebook.id !== me.getNotebookId()) {
					me.setNotebookId(json.notebook.id);
				}
				me.setIsEdited(false);
			} else {
				Ext.Msg.show({
					title: me.localize('errorLoadingNotebook'),
					msg: json.notebook.error,
					buttons: Ext.MessageBox.OK,
					icon: Ext.MessageBox.ERROR
				});
			}
    	}).catch(function(err) {
			me.unmask();
			Ext.Msg.show({
				title: me.localize('errorLoadingNotebook'),
				msg: me.localize('cannotLoadNotebookId'),
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.ERROR
			});
		});
    },

	checkIsEditedAndDoCallback: function(source, callback) {
		if (this.getIsEdited()) {
			Ext.Msg.show({
				title: this.localize('openTitle'),
				message: this.localize('notSavedWarning'),
				buttons: Ext.Msg.YESNO,
				icon: Ext.Msg.QUESTION,
				fn: function(btn) {
					if (btn==='yes') {
						callback.call(source);
					}
				},
				scope: this

			});
		} else {
			callback.call(source);
		}
	},

	handleNotebookSelected: function(source, notebookId, callback) {
		this.checkIsEditedAndDoCallback(source, function() {
			callback.call(source);
			this.loadFromId(notebookId);
		}.bind(this));
	},
    
    runUntil: function(upToCmp) {
    	var containers = [];
    	Ext.Array.each(this.query("notebookrunnableeditorwrapper"), function(item) {
			containers.push(item);
    		if (upToCmp && upToCmp===item) {return false;}
    	}, this);
    	this._run(containers);
    },
    
    runFrom: function(fromCmp) {
    	var containers = [], matched = false;
    	Ext.Array.each(this.query("notebookrunnableeditorwrapper"), function(item) {
    		if (fromCmp && fromCmp===item) {matched=true;}
    		if (matched) {
    			containers.push(item);
    		}
    	}, this);
    	this._run(containers);
    },
    
    runAll: function() {
    	var containers = [];
    	Ext.Array.each(this.query("notebookrunnableeditorwrapper"), function(item) {
			containers.push(item);
    	}, this);
    	this._run(containers);
    },
    
    _run: function(containers, prevVars) {
    	if (containers.length>0) {
    		var container = containers.shift();
			var me = this;
    		container.run(prevVars).then(function(result) {
				// check for and remove older duplicates
				var newVars = container.getVariables();
				if (prevVars === undefined) {
					prevVars = [];
				}
				newVars.forEach(function(newVar) {
					for (var i = 0; i < prevVars.length; i++) {
						var prevVar = prevVars[i];
						if (newVar.name === prevVar.name) {
							// console.log('removing duplicate var:', prevVar.name);
							prevVars.splice(i, 1);
							break;
						}
					}
				});
				prevVars = prevVars.concat(newVars);
				
				Ext.defer(me._run, 100, me, [containers, prevVars]);
			}, function(error) {
				// console.log('nb error', error);
			});
    	} else {
			 // the notebook has finished running
			this.updateTernServerVariables(this.getNotebookVariables());
			this.fireEvent('notebookRun', this);
		}
	},

	notebookInitialized: function() {
		// run all data cells
		// var containers = [];
    	// Ext.Array.each(this.query("notebookdatawrapper"), function(item) {
		// 	containers.push(item);
    	// }, this);
    	// this._run(containers, []);
	},

	updateTernServerVariables: function(varsToAdd, varsToRemove) {
		if (Voyant.notebook.editor.CodeEditor.ternServer) {
			if (varsToRemove) {
				varsToRemove.forEach(function(theVar) {
					Voyant.notebook.editor.CodeEditor.ternServer.server.delFile(theVar.name);
				})
			}
			if (varsToAdd === undefined) {
				console.warn('updateTernServerVariables: no varsToAdd!');
			} else {
				varsToAdd.forEach(function(theVar) {
					if (theVar.isSpyralClass) {
						// many Spyral classes are created via helper methods, e.g. loadCorpus
						// therefore add text that initializes the variable using the class constructor
						// ensuring that the tern server is aware of the variable name and type
						var ternText = 'var '+theVar.name+' = new '+theVar.isSpyralClass+'()';
						Voyant.notebook.editor.CodeEditor.ternServer.server.addFile(theVar.name, ternText);
					} else {
						Spyral.Util.blobToString(theVar.value).then(function(blobStr) {
							var ternText = 'var '+theVar.name+' = '+blobStr;
							Voyant.notebook.editor.CodeEditor.ternServer.server.addFile(theVar.name, ternText);
						});
					}
				});
			}
		}
	},

	getNotebookVariables: function(upToCmp) {
		var variables = [];

		Ext.Array.each(this.query("notebookrunnableeditorwrapper"), function(item) {
			if (upToCmp && upToCmp===item) {return false;} // NB upToCmp exits earlier here than in runUntil

			if (item.getIsRun()) {
				var newVars = item.getVariables();
				newVars.forEach(function(newVar) {
					for (var i = 0; i < variables.length; i++) {
						var prevVar = variables[i];
						if (newVar.name === prevVar.name) {
							variables.splice(i, 1); // remove older duplicate var
							break;
						}
					}
				});

				variables = variables.concat(newVars);
			}
		});

		return variables;
	},

	getNotebookBlocks: function(upToCmp) {
		var blocks = [];

		Ext.Array.each(this.query("notebookrunnableeditorwrapper"), function(item) {
			if (upToCmp && upToCmp===item) {return false;} // NB upToCmp exits earlier here than in runUntil

			blocks.push(item.getInput());
		});

		return blocks;
	},


	
	addNew: function() {
		// TODO metadata defaults
		this.setMetadata(new Spyral.Metadata({
			title: "Spyral Notebook",
			language: "English"
		}));
		this.addText(this.localize('newNotebookIntro'));
		this.addCode('');
	},
    
	addText: function(block, index, cellId) {
		return this._add(block, index, 'notebooktexteditorwrapper', cellId);
	},
 
	addCode: function(block, index, cellId, config) {
		config = config || {};
		config.docs = [this.ecmaTernDocs, this.browserTernDocs, this.spyralTernDocs];
		return this._add(block, index, 'notebookcodeeditorwrapper', cellId, config);
	},

	addData: function(block, index, cellId, config) {
		return this._add(block, index, 'notebookdatawrapper', cellId, config);
	},
		
	_add: function(block, index, xtype, cellId, config) {
		if (Ext.isString(block)) {
			block = {input: block}
		}
		var cells = this.getComponent("cells");
		index = (typeof index === 'undefined') ? cells.items.length : index;
		cellId = (typeof cellId === 'undefined') ? Spyral.Util.id() : cellId;
		return cells.insert(index, Ext.apply(block, {
			xtype: xtype,
			index: index,
			cellId: cellId
		}, config))
	},

    
	notebookWrapperMoveUp: function(wrapper) {
		var cells = this.getComponent("cells");
		var i = cells.items.findIndex('id', wrapper.id);
		if (i==0) {
			Ext.Msg.show({
				title: this.localize('error'),
				msg: this.localize('cannotMoveHigher'),
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.WARNING
			});
		}
		else {
			cells.move(i, i-1);
			this.redoOrder();
		}
	},
	
	notebookWrapperMoveDown: function(wrapper) {
		var cells = this.getComponent("cells");
		var i = cells.items.findIndex('id', wrapper.id);
		if (i==cells.items.getCount()-1) {
			Ext.Msg.show({
				title: this.localize('error'),
				msg: this.localize('cannotMoveLower'),
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.WARNING
			});
		}
		else {
			cells.move(i, i+1);
			this.redoOrder();
		}
	},
	
	notebookWrapperRemove: function(wrapper) {
		var cells = this.getComponent("cells");
		cells.remove(wrapper);
		if (cells.items.length==0) {
			this.addText("(Click to edit).")
		}
		this.redoOrder();
	},
	
	notebookWrapperAdd: function(wrapper, e) {
		var cells = this.getComponent("cells");
		var i = cells.items.findIndex('id', wrapper.id);
		var runnable = wrapper.getXTypes(wrapper).indexOf('notebookrunnableeditorwrapper') !== -1;
		var cmp;
		if ((!runnable && !e.hasModifier()) || (runnable && e.hasModifier())) {
			cmp = this.addCode('',i+1);
		} else {
			cmp = this.addText('',i+1);
		}
		cmp.getTargetEl().scrollIntoView(this.getTargetEl(), null, true, true);
		this.redoOrder();
	},

	redoOrder: function() {
		this.query("notebookeditorwrapper").forEach(function(cmp, i) {
			cmp.setIndex(i);
		})
		this.setIsEdited(true);
	},
    
    applyIsEdited: function(val) {
    	// TODO: perhaps setup autosave
    	if (this.rendered) {
        	// this.getHeader().down("#saveItTool").setDisabled(val === false);
        	if (!val) {
        		this.query("notebookcodeeditor").forEach(function(editor) {
        			editor.setIsChangeRegistered(false);
        		})
        		this.query("notebooktexteditor").forEach(function(editor) {
        			editor.setIsEditRegistered(false);
        		})
        	}
    	}
		return val;
    },
    
	applyNotebookId: function (id) {
		if (this.isConfiguring === false) { // don't (re)set url during initial config as this will clear the url's notebook id
			let url = this.getBaseUrl()+"spyral/";
			if (id) {
				if (id.indexOf(this.NOTEBOOK_ID_SEPARATOR) === -1) {
					// old ID system
					this.setNotebookName(id);
				} else {
					const notebookName = id.split(this.NOTEBOOK_ID_SEPARATOR)[1];
					this.setNotebookName(notebookName);
				}
				url += id.replace(this.NOTEBOOK_ID_SEPARATOR, '/')+"/";
			}
			window.history.pushState({
				url: url
			}, '', url);
		}

		return id;
    },

	applyMetadata: function(metadata) {
		if (metadata !== undefined) {
			// remove tags from old notebooks
			metadata.title = metadata.title.replace(/<\/?\w+.*?>/g, '');
			metadata.description = metadata.description.replace(/<\/?\w+.*?>/g, '');
			
			// set user info if logged in
			if (this.isAuthenticated() && metadata.userId === '' && metadata.author === '') {
				metadata.userId = this.accountInfo.id;
				metadata.author = this.accountInfo.name;
			}
		}
		
		return metadata;
	},
		
	updateMetadata: function() {
		var metadata = this.getMetadata();
		document.title = metadata.title+' - Spyral';

		this.getComponent("spyralHeader").update(this.getInnerHeaderHtml());
		this.getComponent("spyralFooter").update(this.getInnerFooterHtml());

		if (this.metadataEditor) {
			this.metadataEditor.loadMetadata(metadata);
		}

		this.setIsEdited(true);
	},

	showMetadataEditor: function() {
		if (this.metadataWindow === undefined) {
			var me = this;
			
			this.metadataEditor = Ext.create('widget.metadataeditor', {
				anchor: '100%'
			});
			this.metadataWindow = Ext.create('Ext.window.Window', {
				title: this.localize('metadataEditor'),
				autoScroll: true,
				width: 600,
				closeAction: 'hide',
				layout: 'anchor',
				items: this.metadataEditor,
				buttons: [{
					text: this.localize('metadataCancel'),
					ui: 'default-toolbar',
					handler: function() {
						this.up('window').close();
					}
				},{
					text: this.localize('metadataReset'),
					ui: 'default-toolbar',
					handler: function() {
						me.metadataEditor.reset();
					}
				},{
					text: this.localize('metadataSave'),
					handler: function() {
						var form = me.metadataEditor.getForm();
						var values = form.getValues();
						values.catalogue = values.catalogue === 'true'; // convert to boolean
						me.getMetadata().set(values);
						me.updateMetadata();
						this.up('window').close();
					}
				}]
			});
		}

		var metadata = this.getMetadata();
		if (metadata === undefined) {
			metadata = new Spyral.Metadata();
			this.setMetadata(metadata);
		}

		this.metadataEditor.loadMetadata(metadata);

		this.metadataWindow.show();
	},

	showDocs: function() {
		if (this.docsWindow === undefined) {
			this.docsWindow = Ext.create('Voyant.notebook.util.DocsWindow');
		}
		this.docsWindow.showDocs();
	},

	showDocsForClassMethod: function(docClass, docMethod) {
		if (this.docsWindow === undefined) {
			this.docsWindow = Ext.create('Voyant.notebook.util.DocsWindow');
		}
		this.docsWindow.showDocsForClassMethod(docClass, docMethod);
	},

	handleDocLink: function(link) {
		if (this.docsWindow === undefined) {
			this.docsWindow = Ext.create('Voyant.notebook.util.DocsWindow');
		}
		this.docsWindow.handleDocLink(link);
	}
});
Ext.define('Voyant.VoyantApp', {
	
    extend: 'Ext.app.Application',
	mixins: ['Voyant.util.Localization','Voyant.util.Api','Voyant.util.Colors'],
	requires: ['Voyant.util.ResponseError'],
    
    name: 'VoyantApp',
    
    statics: {
    	i18n: {
    	},
    	api: {
			palette: 'default',
			categories: 'auto',
    		lang: undefined,
    		debug: undefined
    	}
    },
    
    config: {
    	baseUrl: undefined,
		tromboneUrl: undefined,
		categoriesManager: undefined
    },
    
    constructor: function(config) {
    	this.setBaseUrl(this.config.baseUrl);
    	
    	// set the Trombone URL from the baseURL // TODO: maybe allow this to be overridden
		this.setTromboneUrl(this.config.baseUrl+'trombone');
		
    	// set the application for the Corpus so that we can use a simple constructor
		Voyant.application = this;
		
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);

		this.mixins['Voyant.util.Colors'].constructor.apply(this, arguments);

		this.setCategoriesManager(new Spyral.Categories());
		
		this.getCategoriesManager().addFeature('color', '#BF1B2C'); // default color is Voyant red
		this.getCategoriesManager().addFeature('font', '"Palatino Linotype", "Book Antiqua", Palatino, serif');
		
		// override Voyant.util.Colors methods to add palette api param
		var _getColor = this.getColor;
		this.getColor = function(index, returnHex) {
			return _getColor.apply(this, [this.getApiParam('palette'), index, returnHex]);
		}
		var _getColorForTerm = this.getColorForTerm;
		this.getColorForTerm = function(term, returnHex) {
			if (term.indexOf('@') === 0) {
				var catColor = this.getCategoriesManager().getCategoryFeature(term.substring(1), 'color');
				if (returnHex) {
					return catColor;
				} else {
					return this.hexToRgb(catColor);
				}
			} else {
				return _getColorForTerm.apply(this, [this.getApiParam('palette'), term, returnHex]);
			}
		}

		// call the parent constructor
		this.callParent(arguments);
    },
    getBaseUrl: function() {
    	var baseUrl = this.callParent();
    	return baseUrl.indexOf("//")==0 ? location.protocol+baseUrl : baseUrl;
    },
    
    getBaseUrlFull: function() {
    	return window.location.origin+this.getBaseUrl(); // maybe doesn't work in all browsers?
    },

    getRelativeUrl: function() {
    	var url = window.location.pathname.substring(this.getBaseUrl().length);
    	var relative = "";
    	for (var i=0, len=url.split("/").length-1; i<len; i++) {
    		relative+="../"
    	}
    	return relative;
    },
    
    getTools: function() {
    	return [{type: 'maximize'},{type: 'help'}]
    },
    
    launch: function() {
    	Ext.tip.QuickTipManager.init();
    	Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {
    	    showDelay: 50 // shorten the delay before showing
    	});
    	
		if (this.getApiParam("categories")) {
			this.loadCategoryData(this.getApiParam("categories"));
		}

		this.callParent(arguments);
    },
    
    tromboneCall: function(config) {
    	var config = config ? config : {};
    	Ext.applyIf(config, {
    		url: this.getTromboneUrl()
    	});
    	if (!config.success && !config.failure && !config.callback) {
        	Ext.applyIf(config, {
        		url: this.getTromboneUrl(),
        	    scope: this,
        	    callback: function(response, success, options) {
        	    	this.dispatchEvent(config.tool+"Loaded", response, success, options)
        	    }
        	});
    	};
    	Ext.Ajax.request(config);
    },
    
    getViewport: function() {
    	return Ext.ComponentQuery.query('viewport')[0];
    },

    dispatchEvent: function(eventName, src) {
    	var viewport = this.getViewport();
		var panels = viewport.query("panel,chart");
		var isHeard = false;

		// tell the app
		if (this.hasListener && this.hasListener(eventName)) {
			this.fireEvent.apply(this, arguments);
			isHeard = true
		}
		
		// tell the panels, except the current one
		for (var i=0; i<panels.length; i++) {
			if (panels[i].hasListener && panels[i].hasListener(eventName)) {
				if (src && src.getId && panels[i].getId && src.getId()==panels[i].getId()) {
					continue; // don't send to self
				}
				isHeard = true;
				panels[i].fireEvent.apply(panels[i], arguments);
			}
		}
		
		if (!isHeard) {
			// let the application know that we have an unhandledEvent
			var args = ["unhandledEvent", src, eventName];
			for (var i=2; i<arguments.length; i++) {args.push(arguments[i])}
			this.fireEvent.apply(this, args);
		}
    },
    
	showResponseError: function(config, response) {
		this.showError(Ext.create("Voyant.util.ResponseError", {msg: (Ext.isString(config) ? config : config.msg), response: response}))
	},
	
	showError: function(config, response) {
		if (config instanceof Voyant.util.ResponseError) {
			config = {
				message: config.getMsg()+"<p class='error'>\n"+config.getError()+" … "+
					"<a href='#' onclick=\"window.open('').document.write(unescape('<pre>"+escape(config.getDetails())+"</pre>')); return false;\">more</a></p>"
			}
		} else if (config instanceof Ext.data.operation.Operation) {
			return this.showError(Ext.create("Voyant.util.ResponseError", config.getError()))
		} else {
			if (Ext.isString(config)) {
				config = {message: config}
			} else if (Ext.isObject(config)) {
				if (config.responseText) {
					// rebundle as error (without nice message)
					return this.showResponseError(config.statusText, config);
				} else if (config.statusText) {
					return this.showResponseError(config.statusText, config)
				}
			}
			// maybe handle other forms
		}
		

		Ext.applyIf(config, {
			title: this.localize("error"),
		    buttons: Ext.Msg.OK,
		    icon: Ext.MessageBox.ERROR,
		    autoScroll: true
		})
		Ext.Msg.show(config);
	},
	
	getToolConfigFromToolXtype: function(xtype) {
		cls = Ext.ClassManager.getByAlias("widget."+xtype);		
		return {
			xtype: xtype,
			title: this._localizeClass(cls, "title"),
			tooltip: { // this needs to be an object for compatibility (other configs can be changed)
				text: this._localizeClass(cls, "helpTip")
			},
			glyph: cls && cls.glyph ? cls.glyph : 'xf12e@FontAwesome'
		};
	},

	/**
	 * Opens a URL in a new window (handling the case when popup windows aren't allowed).
	 * @param {String} url The URL to open.
	 * @private
	 */
	openUrl: function(url) {
		var win = window.open(url);
		if (!win) { // popup blocked
			Ext.Msg.show({
				title: "Popup Blocked",
				buttonText: {ok: "Close"},
				icon: Ext.MessageBox.INFO,
				message: "A popup window was blocked. <a href='"+url+"' target='_blank' class='link'>Click here</a> to open the new window.",
				buttons: Ext.Msg.OK
			});
		}
	},
	
	loadCategoryData: function(id) {
		return this.getCategoriesManager().load(id, {
			trombone: Voyant.application.getTromboneUrl()
		}).then(function() {
			for (var category in this.getCategoriesManager().getCategories()) {
				var color = this.getCategoriesManager().getCategoryFeature(category, 'color');
				if (color !== undefined) {
					var rgb = this.hexToRgb(color);
					var terms = this.getCategoriesManager().getCategoryTerms(category);
					for (var i = 0; i < terms.length; i++) {
						this.setColorForTerm(terms[i], rgb);
					}
				}
			}
		}.bind(this));
	},

	saveCategoryData: function(data) {
		return this.getCategoriesManager().save({}, {
			trombone: Voyant.application.getTromboneUrl()
		});
	}
});
Ext.define('Voyant.VoyantCorpusApp', {
	
    extend: 'Voyant.VoyantApp',
    
    name: 'VoyantCorpusApp',

    requires: ['Voyant.panel.CorpusSet','Voyant.data.model.Corpus','Voyant.panel.VoyantHeader', 'Voyant.panel.VoyantFooter', 'Voyant.panel.CorpusCreator', 'Voyant.panel.Cirrus', 'Voyant.panel.Summary', 'Voyant.panel.DreamScape', 'Voyant.panel.CorpusTerms', 'Voyant.panel.Reader', 'Voyant.panel.Documents', 'Voyant.panel.Trends', 'Voyant.panel.Contexts', 'Voyant.panel.DocumentTerms','Voyant.panel.CorpusCollocates','Voyant.panel.CollocatesGraph','Voyant.panel.Phrases','Voyant.panel.ScatterPlot','Voyant.panel.TopicContexts','Voyant.panel.TermsRadio','Voyant.panel.TermsBerry', 'Voyant.panel.Embedder'],
    
    statics: {
    	i18n: {
    	},
    	api: {
    		toolFlow: undefined // TODO what is this supposed to do?
    	}
    },
    
	constructor: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);

		this.callParent(arguments);
	},

	init: function() {
		if (this.getEntitiesEnabled() === true) {
			var moreVizTools = this.getMoreTools()[2];
			moreVizTools.items.push('rezoviz');
		}
	},
	
    config: {
    	corpus: undefined,
    	corpusAccess: undefined,
		entitiesEnabled: false,
    	moreTools: [{
			i18n: 'moreToolsScaleCorpus',
			glyph: 'xf065@FontAwesome',
			items: ['cirrus','corpusterms','bubblelines','correlations','corpuscollocates','dreamscape','loom','mandala','microsearch','streamgraph','phrases','documents','summary','trends','scatterplot','termsradio','topics','veliza','wordtree']
    	},{
			i18n: 'moreToolsScaleDocument',
			glyph: 'xf066@FontAwesome',
			items: ['bubbles','cirrus','contexts','documentterms','reader','textualarc','trends','knots','topics']
    	},{
			i18n: 'moreToolsTypeViz',
			glyph: 'xf06e@FontAwesome',
			items: ['cirrus','bubblelines','bubbles','collocatesgraph','dreamscape','loom','knots','mandala','microsearch','streamgraph','scatterplot','textualarc','trends','termsberry','termsradio','wordtree']
		},{
			i18n: 'moreToolsTypeGrid',
			glyph: 'xf0ce@FontAwesome',
			items: ['corpusterms','corpuscollocates','correlations','phrases','contexts','documentterms','documents','topics']
		},{
			
			i18n: 'moreToolsTypeOther',
			glyph: 'xf035@FontAwesome',
			items: ['reader','summary','veliza','embedder']
    	}]
    },
    
    launch: function(config) {
		this.callParent(arguments);
		
    	if (this.hasQueryToLoad()) {
        	var queryParams = Ext.Object.fromQueryString(document.location.search);
        	if (!queryParams.corpus && this.getCorpusId && this.getCorpusId()) {
        		queryParams.corpus = this.getCorpusId();
        	}
        	if (config && config.useCache) { // for large corpora
        		queryParams.useCache = config.useCache;
        	}
        	this.loadCorpusFromParams(queryParams);
        	
        	if (queryParams.palette) {
        		if (queryParams.palette.indexOf(",") > -1) { // treat as inline
        	    	var palette = Ext.decode(queryParams.palette);
        	    	this.addColorPalette(queryParams.palette, palette);
        		} else {
					if (this.getPalettes()[queryParams.palette] === undefined) {
						this.loadCustomColorPalette(queryParams.palette);
					}
				}
			}
    	} else {
    		var viewport = this.getViewport();
    		if (viewport) {
    			var corpuscreator = viewport.down("corpuscreator")
    			if (corpuscreator) {
    				var toast = corpuscreator.toastInfo({
    					html: this.localize('didYouKnowText'),
    					title: this.localize('didYouKnow'),
    					anchor: corpuscreator.down("textareafield"),
    					align: 'tr',
    					listeners: {
    						beforeclose: {
    							fn: function() {
    								this.getHeader().getTools().forEach(function(tool) {
    									if (tool.type=="gear" || tool.type=='help') {
    										tool.getEl().frame("#ff0000", 1, { duration: 3000 })
    									}
    								});
    							},
    							scope: corpuscreator
    						}
    					}
    				});
    			}
    		}
    	}
    },
    
    loadCorpusFromParams: function(params) {
		var me = this;

		if (this.errorLoadingCorpus) {
			delete params.corpus; // remove corpus ID so that it's not used erroneously
			delete this.errorLoadingCorpus;
		}

		var view = me.getViewport()
		view.mask(this.localize("fetchingCorpus"));
		if (params.archive) { // fix a few URLs we know about
			if (Ext.isString(params.archive)) {params.archive=[params.archive]}
			params.archive = params.archive.map(function(archive) {
				return archive.replace('/blogs.sub.uni-hamburg.de/hup/lhn/', '/wikis.sub.uni-hamburg.de/lhn/index.php/')
					.replace('/hup.sub.uni-hamburg.de/', '/wikis.sub.uni-hamburg.de/')
			})
		}
		
		this.validateCorpusLoadParams(params);

		new Voyant.data.model.Corpus(params).then(function(corpus) {
			view.unmask();
			me.setCorpus(corpus);
			if (me.validateCorpusAccess()) {
				me.dispatchEvent('loadedCorpus', this, corpus);
			}
		}).otherwise(function() {
			me.errorLoadingCorpus = true; // track error so we can remove corpus ID from params on subsequent load
			view.unmask();
		})
    },
    
    validateCorpusLoadParams: function(params) {
    	// leave untouched by default, this can be overridden
    },
    
    validateCorpusAccess: function() {
		var me = this, view = me.getViewport(), corpus = this.getCorpus();
		if (corpus && corpus.requiresPassword() && !me.getViewport().query("panel").every(function(panel) {
			return !panel.isConsumptive
		})) {
			var noPasswordAccess = corpus.getNoPasswordAccess();
			var passWin = Ext.create('Ext.window.Window', {
	            title: me.localize('passwordRequiredTitle'),
			    layout: 'fit',
			    items: {
			    	padding: 10,
	                flex: 1,
	                width: 300,
	                layout: {
	                    type: 'vbox',
	                    align: 'stretch'
	                },
	                items: [
	                    {
	                        html: '<p>'+me.localize('passwordRequiredMessage')+'</p>' + (noPasswordAccess=='NONCONSUMPTIVE' ? '<p>'+me.localize('nonConsumptiveMessage')+"</p>" : "")+'</p>'
	                    },{
	                    	xtype: 'textfield',
	                    	fieldLabel: me.localize('password')
	                    }
	                ],
	                bbar: {
	//                	ui: 'footer',
	                	layout: {pack: 'center'},
	                	items: [{
	                    	text: me.localize('passwordValidateButton'),
	                    	ui: 'default',
	                    	handler: function() {
	                    		var password = passWin.query("textfield")[0].getValue().trim();
	                    		if (password.length==0) {
	                    			me.showError({
	                    				message: me.localize('noPasswordGiven')
	                    			})
	                    			return;
	                    		}
	                    		passWin.mask();
	                    		Ext.Ajax.request({
	                    			  url: me.getTromboneUrl(),
	                    			  params: {
	                    				  corpus: corpus.getId(),
	                    				  passwordForSession: password
	                    			  },
	                    			  method: 'POST',
	                    			  success: function(result, request) {
	                    				  passWin.unmask();
	                    				  var access = result.responseText;
	                    				  if (access=="ADMIN" || access=="ACCESS") {
			                    			    passWin.close();
			                    			    view.unmask();
			                    			    me.setCorpusAccess(access);
					            				me.dispatchEvent('loadedCorpus', this, corpus);
	                    				  }
	                    				  else {
	  		                    			me.showError({
			                    				message: me.localize('badPassword')
			                    			})
	                    				  }
	                    			  },
	                    			  failure: function(result, request) {
	                    				  passWin.unmask();
	  		                    			me.showError({
			                    				message: me.localize('passwordValidationError')
			                    			})
	                    			  } 
	                    		});
	                    	}
	                    },{
	                    	text: me.localize('nonConsumptiveButton'),
	                    	hidden: corpus.getNoPasswordAccess()=='NONE',
	                    	handler: function() {
	                    		passWin.mask();
	                    		Ext.Ajax.request({
	                    			  url: me.getTromboneUrl(),
	                    			  params: {
	                    				  corpus: corpus.getId(),
	                    				  passwordForSessionRemove: true
	                    			  },
	                    			  method: 'POST',
	                    			  callback: function(result, request) { // do this even if request fails
	                    				  passWin.unmask();
	                    				  passWin.close();
	                    				  view.unmask();
	                    				  me.dispatchEvent('loadedCorpus', me, corpus);
	                    			  }
	                    		});
	                    	}
	                    }]
	                }
	            }
			}).show();
			return false;
		} else {
			return true
		}
    },
    
    hasQueryToLoad: function(params) {
    	if (!params) {
    		params = Ext.Object.fromQueryString(document.location.search);
    	}
    	return params.corpus || params.input || (this.getCorpusId && this.getCorpusId()); // TODO: should this include "archive" from V1?
    },
    
    listeners: {
    	loadedCorpus: function(src, corpus) {
    		this.setCorpus(corpus);
    		
    		this.on("unhandledEvent", function(src, eventName, data) {
				var url = this.getBaseUrl() + '?corpus='+corpus.getAliasOrId();
				var api = this.getModifiedApiParams() || {}; // use application, not tool
				delete api.view; // make sure we show default view
				if (eventName=='termsClicked') {
					// data can be a simple array of terms or an array of term objects
					if (Ext.isArray(data) && data.length > 0 && typeof data[0] !== 'string' && 'term' in data[0] && 'docIndex' in data[0]) {
						let termsObj = {};
						let docIndObj = {};
						data.forEach(function(datum) {
							termsObj[datum.term]=true;
							docIndObj[datum.docIndex]=true;
						})
						api.query=Object.keys(termsObj);
						api.docIndex=Object.keys(docIndObj);
					} else {						
						api.query=data;
					}
				}
				else if (eventName=='documentsClicked') {
					var docIndex = [];
					if (data.forEach) {
						data.forEach(function(doc) {
							docIndex.push(doc.getIndex())
						})
					}
					api.docIndex=docIndex
				}
				else if (eventName=='corpusTermsClicked') {
					if (data.map) {
						api.query = data.map(function(corpusTerm) {return corpusTerm.getTerm()});
					}
				}
				else if (eventName=='documentTermsClicked') {
					if (data.map) {
						api.query = data.map(function(documentTerm) {return documentTerm.getTerm()});
						api.docIndex = data.map(function(documentTerm) {return documentTerm.getDocIndex()});
					}
				}
				else {
					if (console) {console.warn("Unhandled event: "+eventName, data)}
					return;
				}
				if (api.toolFlow) {
					var toolFlow = Ext.Array.from(api.toolFlow.split(","));
					api.view = toolFlow.shift();
					if (toolFlow.length>0) {
						api.toolFlow = toolFlow.join(",");
					} else {
						delete api.toolFlow
					}
				}
				url += "&"+Ext.Object.toQueryString(api)
				this.openUrl(url)
			})
    	}
    }

});
Ext.define('Voyant.panel.DocumentClusters', {
	extend: 'Ext.panel.Panel',
	alias: 'widget.documentclusters',
	title: "Document Clusters"
})

//	extend: 'Ext.panel.Panel',
//	alias: 'widget.rezoviz',
//	title: "RezoViz"
//})
Ext.define('Voyant.VoyantCorpusToolsetApp', {
	extend : 'Voyant.VoyantCorpusApp',
	requires: ['Voyant.panel.Contexts','Voyant.panel.CollocatesGraph','Voyant.panel.Trends'],
	name : 'VoyantCorpusToolsetApp',
	launch: function() {
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: [{
		        region: 'south',
		        xtype: 'voyantfooter'
		    }, {
         	   xtype: 'tabpanel',
        	   region: 'center',
		    	split: true,
        	   items: [{
        		   xtype: 'cirrus',
                   collapsible: true
        	   },{
        		   xtype: 'corpusterms',
                   collapsible: true
        	   },{
        		   xtype: 'documents',
                   collapsible: true
        	   },{
        		   xtype: 'rezoviz',
                   collapsible: true
        	   },{
        		   xtype: 'trends',
                   collapsible: true
        	   },{
        		   xtype: 'documentclusters',
                   collapsible: true
        	   }],
        	   flex: 6
           }]
		});
        this.callParent(arguments);
	}
});
Ext.define('Voyant.VoyantDefaultApp', {
	extend : 'Voyant.VoyantCorpusApp',
	mixins: ['Voyant.util.Api'],
	name : 'VoyantDefaultApp',
	constructor: function() {
		this.mixins['Voyant.util.Api'].constructor.apply(this, arguments);
        this.callParent(arguments);
	},
	statics: {
		i18n: {
			serverMessage: ' '
		},
		api: {
			view: 'corpusset',
			stopList: 'auto',
			panels: undefined,
			rtl: undefined
		}
	},
	
	listeners: {
    	loadedCorpus: function(src, corpus) {
    		this.viewport.down('voyantheader').collapse();
    		this.viewport.down('#toolsContainer').setActiveItem(1);
    		var corpusId = this.getCorpusId && this.getCorpusId() ? this.getCorpusId() : undefined;
    		if (window.history.pushState && !corpusId) {
    			// add the corpusId to the url
    			var corpusId = corpus.getAliasOrId();
        		var queryParams = Ext.Object.fromQueryString(document.location.search);
        		
    			var url = this.getBaseUrl()+'?corpus='+corpusId;
    			for (var key in queryParams) {
    				if (key !== 'corpus') {
    					var vals = Ext.isString(queryParams[key]) ? [queryParams[key]] : queryParams[key];
    					if (Ext.isArray(vals)) {
    						vals.forEach(function(val) {
    	    					url += '&'+key+'='+val;
    						})
    					}
    				}
    			}
    			window.history.pushState({
    				corpus: corpusId
    			}, 'Corpus: '+corpusId, url);
    		}
    	}
	},
	getViewComponent: function() {
		return this.viewport.down('#toolsContainer-main')
	},
	launch: function() {
		var queryParams = Ext.Object.fromQueryString(document.location.search) || {};
		var view = this.getApiParam('view', 'CorpusSet');
		var xtype = view.toLowerCase();
		if (!Ext.ClassManager.getByAlias("widget."+xtype) || queryParams.noskin) {
			Ext.Msg.show({
			    title: this.localize('noViewErrorTitle'),
			    message: new Ext.Template(this.localize(queryParams.noskin ? 'noViewKnownErrorTpl' : 'noViewErrorTpl')).apply({
			    	view: queryParams.noskin ? queryParams.noskin : view,
			    	additional: queryParams.noskin && queryParams.noskin == 'convert' ? this.localize(queryParams.noskin+'SkinMsg') : ''
			    }),
			    buttons: Ext.Msg.OK,
			    icon: Ext.Msg.ERROR
			});
			xtype = 'corpusset'; // switch to default view
		}
		var SPLIT_SIZE = 5;
		this.viewport = Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    rtl: (this.getApiParam('rtl')!==undefined || Voyant.util.Localization.LANGUAGE=="ar" || Voyant.util.Localization.LANGUAGE=="he"),
		    items: [{
		    	xtype: 'voyantheader',
		    	region: 'north'
		    },{
		        region: 'south',
		        xtype: 'voyantfooter'
		    },{
		    	region: 'center',
		    	layout: 'card',
		    	itemId: 'toolsContainer',
				activeItem: 0,
				items: [{
					xtype : 'container',
					layout: {
						type: 'vbox',
						pack: 'center',
						align: 'center'
					},
					items: [{
						xtype: 'corpuscreator'
					},{
						xtype: 'container',
						width: 800,
						html: ""+
						"<div id='voyantIs' style='font-style: italic; text-align: center; margin-top: 10px;'>"+
							"<div>"+this.localize('voyantIs')+"</div>"+
							(this.localize('translatedBy').indexOf("English") == -1 ? "<div>"+this.localize('translatedBy')+"</div>" : "")+
							(this.getCorpusCreatorText && this.getCorpusCreatorText().trim().length>0 ?  "<div id='corpusCreatorText'>"+this.getCorpusCreatorText()+"</div>" : "")+
						"</div>"
					},{
						xtype: 'container',
						width: 'auto',
						html: ""+
						"<div style='font-style: italic; text-align: center; margin-top: 10px;'>"+
							"<div>"+this.localize('serverMessage')+"</div>"+
						"</div>"
					}]	
				},{
					layout: 'fit',
					itemId: 'toolsContainer-main',
					items: {
						xtype: xtype
					}
				}]
		    }]
		});
		this.callParent(arguments);
	}
});
Ext.define('Voyant.panel.MoreLikeThis', {
	extend: 'Ext.panel.Panel',
	alias: 'widget.morelikethis',
	title: "More Like this"
})
Ext.define('Voyant.VoyantDocumentToolsetApp', {
	extend : 'Voyant.VoyantCorpusApp',
	requires: ['Voyant.panel.Contexts','Voyant.panel.CollocatesGraph','Voyant.panel.Trends'],
	name : 'VoyantDocumentToolsetApp',
	launch: function() {
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: [{
		        region: 'south',
		        xtype: 'voyantfooter'
		    }, {
         	   xtype: 'tabpanel',
        	   region: 'center',
		    	split: true,
        	   items: [{
        		   xtype: 'cirrus',
                   collapsible: true
        	   },{
        		   xtype: 'documentterms',
                   collapsible: true
        	   },{
        		   xtype: 'contexts',
                   collapsible: true
        	   },{
        		   xtype: 'collocatesgraph',
                   collapsible: true
        	   },{
        		   xtype: 'trends',
                   collapsible: true
        	   },{
        		   xtype: 'morelikethis',
                   collapsible: true
        	   }],
        	   flex: 6
           }]
		});
        this.callParent(arguments);
	}
});
Ext.define('Voyant.VoyantNotebookApp', {
	extend : 'Voyant.VoyantApp',
	requires: ['Voyant.panel.VoyantFooter','Voyant.notebook.Notebook','Voyant.data.model.Corpus'],
	name : 'VoyantNotebookApp',
	launch: function() {
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: [{
		    	xtype: 'notebook',
		    	region: 'center'
		    },{
		    	xtype: 'voyantfooter',
		    	region: 'south'
		    }]
		});
		this.callParent(arguments);    	
	}
});
Ext.define('Voyant.VoyantToolApp', {
	extend : 'Voyant.VoyantCorpusApp',
	name : 'VoyantToolApp',
	statics: {
		api: {
			minimal: undefined,
			embeddedApiId: undefined
		}
	},
	launch: function() {
		var items = [], me = this;
		if (!this.getApiParam('minimal')) {
			items.push({
		        region: 'south',
		        xtype: 'voyantfooter'
		    })
		};
		items.push({
	        region: 'center',
	        layout: 'fit',
	        itemId: 'toolcontainer',
	        items: {
		        xtype: this.getApiParam('embeddedApiId') ? 'container' : this.getTool()
	        },
	        listeners: {
	        	afterrender: function(container) {
	        		if (me.getApiParam('embeddedApiId')) {
	    				var dfd = new Ext.Deferred();
	    	    		container.mask(this.localize('loadingConfiguration'));
	        	    	Ext.Ajax.request({
	        	    	    url: me.getTromboneUrl(),
	        	    	    params: {
	        	        		tool: 'resource.StoredResource',
	        	        		retrieveResourceId: this.getApiParam('embeddedApiId')
	        	    	    }
	        	    	}).then(function(response) {
	    					dfd.resolve();
	    	    	    	var json = Ext.util.JSON.decode(response.responseText);
	        	    		var configString = decodeURIComponent(json.storedResource.resource);
	        	    		var config = Ext.decode(configString);
	        	    		var tool = Ext.create({xtype: me.getTool()});
	        	    		tool.setApiParams(config);
	        	    		container.unmask();
	        	    		container.remove(container.down('container'));
	        	    		container.add(tool);
	        	    		if (config.corpus) {
	        	    			me.loadCorpusFromParams(config);
	        	    		}
	        	    	}).otherwise(function(response) {
	        	    		if (me.getTargetEl) {
	            				Voyant.notebook.util.Show.TARGET = me.getTargetEl();
	            				showError(response);
	        	    		}
	        	    		Voyant.application.showError(response);
	        	    		dfd.reject();
	        	    	})
	    			}
	        	},
	        	scope: this
	        }
	    });
		Ext.create('Ext.container.Viewport', {
		    layout: 'border',
		    items: items
		});
		this.callParent(arguments);
	}
});
